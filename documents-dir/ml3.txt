Understanding Machine Learning:
From Theory to Algorithms

c 2014 by Shai Shalev-Shwartz and Shai Ben-David


Published 2014 by Cambridge University Press.
This copy is for personal use only. Not for distribution.
Do not post. Please link to:
http://www.cs.huji.ac.il/~shais/UnderstandingMachineLearning

Please note: This copy is almost, but not entirely, identical to the printed version
of the book. In particular, page numbers are not identical (but section numbers are the
same).

Understanding Machine Learning
Machine learning is one of the fastest growing areas of computer science,
with far-reaching applications. The aim of this textbook is to introduce
machine learning, and the algorithmic paradigms it offers, in a principled way. The book provides an extensive theoretical account of the
fundamental ideas underlying machine learning and the mathematical
derivations that transform these principles into practical algorithms. Following a presentation of the basics of the field, the book covers a wide
array of central topics that have not been addressed by previous textbooks. These include a discussion of the computational complexity of
learning and the concepts of convexity and stability; important algorithmic paradigms including stochastic gradient descent, neural networks,
and structured output learning; and emerging theoretical concepts such as
the PAC-Bayes approach and compression-based bounds. Designed for
an advanced undergraduate or beginning graduate course, the text makes
the fundamentals and algorithms of machine learning accessible to students and nonexpert readers in statistics, computer science, mathematics,
and engineering.
Shai Shalev-Shwartz is an Associate Professor at the School of Computer
Science and Engineering at The Hebrew University, Israel.
Shai Ben-David is a Professor in the School of Computer Science at the
University of Waterloo, Canada.

UNDERSTANDING
MACHINE LEARNING
From Theory to
Algorithms

Shai Shalev-Shwartz
The Hebrew University, Jerusalem

Shai Ben-David
University of Waterloo, Canada

32 Avenue of the Americas, New York, NY 10013-2473, USA
Cambridge University Press is part of the University of Cambridge.
It furthers the Universityâ€™s mission by disseminating knowledge in the pursuit of
education, learning and research at the highest international levels of excellence.
www.cambridge.org
Information on this title: www.cambridge.org/9781107057135
c Shai Shalev-Shwartz and Shai Ben-David 2014
âƒ
This publication is in copyright. Subject to statutory exception
and to the provisions of relevant collective licensing agreements,
no reproduction of any part may take place without the written
permission of Cambridge University Press.
First published 2014
Printed in the United States of America
A catalog record for this publication is available from the British Library
Library of Congress Cataloging in Publication Data
ISBN 978-1-107-05713-5 Hardback
Cambridge University Press has no responsibility for the persistence or accuracy of
URLs for external or third-party Internet Web sites referred to in this publication,
and does not guarantee that any content on such Web sites is, or will remain,
accurate or appropriate.

Triple-S dedicates the book to triple-M

vii

Preface
The term machine learning refers to the automated detection of meaningful
patterns in data. In the past couple of decades it has become a common tool in
almost any task that requires information extraction from large data sets. We are
surrounded by a machine learning based technology: search engines learn how
to bring us the best results (while placing profitable ads), anti-spam software
learns to filter our email messages, and credit card transactions are secured by
a software that learns how to detect frauds. Digital cameras learn to detect
faces and intelligent personal assistance applications on smart-phones learn to
recognize voice commands. Cars are equipped with accident prevention systems
that are built using machine learning algorithms. Machine learning is also widely
used in scientific applications such as bioinformatics, medicine, and astronomy.
One common feature of all of these applications is that, in contrast to more
traditional uses of computers, in these cases, due to the complexity of the patterns
that need to be detected, a human programmer cannot provide an explicit, finedetailed specification of how such tasks should be executed. Taking example from
intelligent beings, many of our skills are acquired or refined through learning from
our experience (rather than following explicit instructions given to us). Machine
learning tools are concerned with endowing programs with the ability to â€œlearnâ€
and adapt.
The first goal of this book is to provide a rigorous, yet easy to follow, introduction to the main concepts underlying machine learning: What is learning?
How can a machine learn? How do we quantify the resources needed to learn a
given concept? Is learning always possible? Can we know if the learning process
succeeded or failed?
The second goal of this book is to present several key machine learning algorithms. We chose to present algorithms that on one hand are successfully used
in practice and on the other hand give a wide spectrum of different learning
techniques. Additionally, we pay specific attention to algorithms appropriate for
large scale learning (a.k.a. â€œBig Dataâ€), since in recent years, our world has become increasingly â€œdigitizedâ€ and the amount of data available for learning is
dramatically increasing. As a result, in many applications data is plentiful and
computation time is the main bottleneck. We therefore explicitly quantify both
the amount of data and the amount of computation time needed to learn a given
concept.
The book is divided into four parts. The first part aims at giving an initial
rigorous answer to the fundamental questions of learning. We describe a generalization of Valiantâ€™s Probably Approximately Correct (PAC) learning model,
which is a first solid answer to the question â€œwhat is learning?â€. We describe
the Empirical Risk Minimization (ERM), Structural Risk Minimization (SRM),
and Minimum Description Length (MDL) learning rules, which shows â€œhow can
a machine learnâ€. We quantify the amount of data needed for learning using
the ERM, SRM, and MDL rules and show how learning might fail by deriving

viii

a â€œno-free-lunchâ€ theorem. We also discuss how much computation time is required for learning. In the second part of the book we describe various learning
algorithms. For some of the algorithms, we first present a more general learning
principle, and then show how the algorithm follows the principle. While the first
two parts of the book focus on the PAC model, the third part extends the scope
by presenting a wider variety of learning models. Finally, the last part of the
book is devoted to advanced theory.
We made an attempt to keep the book as self-contained as possible. However,
the reader is assumed to be comfortable with basic notions of probability, linear
algebra, analysis, and algorithms. The first three parts of the book are intended
for first year graduate students in computer science, engineering, mathematics, or
statistics. It can also be accessible to undergraduate students with the adequate
background. The more advanced chapters can be used by researchers intending
to gather a deeper theoretical understanding.

Acknowledgements
The book is based on Introduction to Machine Learning courses taught by Shai
Shalev-Shwartz at the Hebrew University and by Shai Ben-David at the University of Waterloo. The first draft of the book grew out of the lecture notes for
the course that was taught at the Hebrew University by Shai Shalev-Shwartz
during 2010â€“2013. We greatly appreciate the help of Ohad Shamir, who served
as a TA for the course in 2010, and of Alon Gonen, who served as a TA for the
course in 2011â€“2013. Ohad and Alon prepared few lecture notes and many of
the exercises. Alon, to whom we are indebted for his help throughout the entire
making of the book, has also prepared a solution manual.
We are deeply grateful for the most valuable work of Dana Rubinstein. Dana
has scientifically proofread and edited the manuscript, transforming it from
lecture-based chapters into fluent and coherent text.
Special thanks to Amit Daniely, who helped us with a careful read of the
advanced part of the book and also wrote the advanced chapter on multiclass
learnability. We are also grateful for the members of a book reading club in
Jerusalem that have carefully read and constructively criticized every line of
the manuscript. The members of the reading club are: Maya Alroy, Yossi Arjevani, Aharon Birnbaum, Alon Cohen, Alon Gonen, Roi Livni, Ofer Meshi, Dan
Rosenbaum, Dana Rubinstein, Shahar Somin, Alon Vinnikov, and Yoav Wald.
We would also like to thank Gal Elidan, Amir Globerson, Nika Haghtalab, Shie
Mannor, Amnon Shashua, Nati Srebro, and Ruth Urner for helpful discussions.
Shai Shalev-Shwartz, Jerusalem, Israel
Shai Ben-David, Waterloo, Canada

Contents

Preface
1

Part I

page vii

Introduction
1.1
What Is Learning?
1.2
When Do We Need Machine Learning?
1.3
Types of Learning
1.4
Relations to Other Fields
1.5
How to Read This Book
1.5.1 Possible Course Plans Based on This Book
1.6
Notation

Foundations

19
19
21
22
24
25
26
27
31

2

A Gentle Start
2.1
A Formal Model â€“ The Statistical Learning Framework
2.2
Empirical Risk Minimization
2.2.1 Something May Go Wrong â€“ Overfitting
2.3
Empirical Risk Minimization with Inductive Bias
2.3.1 Finite Hypothesis Classes
2.4
Exercises

33
33
35
35
36
37
41

3

A Formal Learning Model
3.1
PAC Learning
3.2
A More General Learning Model
3.2.1 Releasing the Realizability Assumption â€“ Agnostic PAC
Learning
3.2.2 The Scope of Learning Problems Modeled
3.3
Summary
3.4
Bibliographic Remarks
3.5
Exercises

43
43
44

Learning via Uniform Convergence
4.1
Uniform Convergence Is Sufficient for Learnability
4.2
Finite Classes Are Agnostic PAC Learnable

54
54
55

4

c 2014 by Shai Shalev-Shwartz and Shai Ben-David
Understanding Machine Learning, 
Published 2014 by Cambridge University Press.
Personal use only. Not for distribution. Do not post.
Please link to http://www.cs.huji.ac.il/~shais/UnderstandingMachineLearning

45
47
49
50
50

x

Contents

4.3
4.4
4.5

Summary
Bibliographic Remarks
Exercises

58
58
58

5

The Bias-Complexity Tradeoff
5.1
The No-Free-Lunch Theorem
5.1.1 No-Free-Lunch and Prior Knowledge
5.2
Error Decomposition
5.3
Summary
5.4
Bibliographic Remarks
5.5
Exercises

60
61
63
64
65
66
66

6

The
6.1
6.2
6.3

67
67
68
70
70
71
71
72
72
72
73
73
75
78
78
78

6.4
6.5

6.6
6.7
6.8

VC-Dimension
Infinite-Size Classes Can Be Learnable
The VC-Dimension
Examples
6.3.1 Threshold Functions
6.3.2 Intervals
6.3.3 Axis Aligned Rectangles
6.3.4 Finite Classes
6.3.5 VC-Dimension and the Number of Parameters
The Fundamental Theorem of PAC learning
Proof of Theorem 6.7
6.5.1 Sauerâ€™s Lemma and the Growth Function
6.5.2 Uniform Convergence for Classes of Small Effective Size
Summary
Bibliographic remarks
Exercises

7

Nonuniform Learnability
7.1
Nonuniform Learnability
7.1.1 Characterizing Nonuniform Learnability
7.2
Structural Risk Minimization
7.3
Minimum Description Length and Occamâ€™s Razor
7.3.1 Occamâ€™s Razor
7.4
Other Notions of Learnability â€“ Consistency
7.5
Discussing the Different Notions of Learnability
7.5.1 The No-Free-Lunch Theorem Revisited
7.6
Summary
7.7
Bibliographic Remarks
7.8
Exercises

8

The Runtime of Learning
8.1
Computational Complexity of Learning

83
83
84
85
89
91
92
93
95
96
97
97
100
101

Contents

8.2

8.3
8.4
8.5
8.6
8.7

Part II

8.1.1 Formal Definition*
Implementing the ERM Rule
8.2.1 Finite Classes
8.2.2 Axis Aligned Rectangles
8.2.3 Boolean Conjunctions
8.2.4 Learning 3-Term DNF
Efficiently Learnable, but Not by a Proper ERM
Hardness of Learning*
Summary
Bibliographic Remarks
Exercises

From Theory to Algorithms

xi

102
103
104
105
106
107
107
108
110
110
110
115

9

Linear Predictors
9.1
Halfspaces
9.1.1 Linear Programming for the Class of Halfspaces
9.1.2 Perceptron for Halfspaces
9.1.3 The VC Dimension of Halfspaces
9.2
Linear Regression
9.2.1 Least Squares
9.2.2 Linear Regression for Polynomial Regression Tasks
9.3
Logistic Regression
9.4
Summary
9.5
Bibliographic Remarks
9.6
Exercises

117
118
119
120
122
123
124
125
126
128
128
128

10

Boosting
10.1 Weak Learnability
10.1.1 Efficient Implementation of ERM for Decision Stumps
10.2 AdaBoost
10.3 Linear Combinations of Base Hypotheses
10.3.1 The VC-Dimension of L(B, T )
10.4 AdaBoost for Face Recognition
10.5 Summary
10.6 Bibliographic Remarks
10.7 Exercises

130
131
133
134
137
139
140
141
141
142

11

Model Selection and Validation
11.1 Model Selection Using SRM
11.2 Validation
11.2.1 Hold Out Set
11.2.2 Validation for Model Selection
11.2.3 The Model-Selection Curve

144
145
146
146
147
148

xii

Contents

11.3
11.4
11.5

11.2.4 k-Fold Cross Validation
11.2.5 Train-Validation-Test Split
What to Do If Learning Fails
Summary
Exercises

149
150
151
154
154

12

Convex Learning Problems
12.1 Convexity, Lipschitzness, and Smoothness
12.1.1 Convexity
12.1.2 Lipschitzness
12.1.3 Smoothness
12.2 Convex Learning Problems
12.2.1 Learnability of Convex Learning Problems
12.2.2 Convex-Lipschitz/Smooth-Bounded Learning Problems
12.3 Surrogate Loss Functions
12.4 Summary
12.5 Bibliographic Remarks
12.6 Exercises

156
156
156
160
162
163
164
166
167
168
169
169

13

Regularization and Stability
13.1 Regularized Loss Minimization
13.1.1 Ridge Regression
13.2 Stable Rules Do Not Overfit
13.3 Tikhonov Regularization as a Stabilizer
13.3.1 Lipschitz Loss
13.3.2 Smooth and Nonnegative Loss
13.4 Controlling the Fitting-Stability Tradeoff
13.5 Summary
13.6 Bibliographic Remarks
13.7 Exercises

171
171
172
173
174
176
177
178
180
180
181

14

Stochastic Gradient Descent
14.1 Gradient Descent
14.1.1 Analysis of GD for Convex-Lipschitz Functions
14.2 Subgradients
14.2.1 Calculating Subgradients
14.2.2 Subgradients of Lipschitz Functions
14.2.3 Subgradient Descent
14.3 Stochastic Gradient Descent (SGD)
14.3.1 Analysis of SGD for Convex-Lipschitz-Bounded Functions
14.4 Variants
14.4.1 Adding a Projection Step
14.4.2 Variable Step Size
14.4.3 Other Averaging Techniques

184
185
186
188
189
190
190
191
191
193
193
194
195

Contents

14.5

14.6
14.7
14.8

14.4.4 Strongly Convex Functions*
Learning with SGD
14.5.1 SGD for Risk Minimization
14.5.2 Analyzing SGD for Convex-Smooth Learning Problems
14.5.3 SGD for Regularized Loss Minimization
Summary
Bibliographic Remarks
Exercises

xiii

195
196
196
198
199
200
200
201

15

Support Vector Machines
15.1 Margin and Hard-SVM
15.1.1 The Homogenous Case
15.1.2 The Sample Complexity of Hard-SVM
15.2 Soft-SVM and Norm Regularization
15.2.1 The Sample Complexity of Soft-SVM
15.2.2 Margin and Norm-Based Bounds versus Dimension
15.2.3 The Ramp Loss*
15.3 Optimality Conditions and â€œSupport Vectorsâ€*
15.4 Duality*
15.5 Implementing Soft-SVM Using SGD
15.6 Summary
15.7 Bibliographic Remarks
15.8 Exercises

202
202
205
205
206
208
208
209
210
211
212
213
213
214

16

Kernel Methods
16.1 Embeddings into Feature Spaces
16.2 The Kernel Trick
16.2.1 Kernels as a Way to Express Prior Knowledge
16.2.2 Characterizing Kernel Functions*
16.3 Implementing Soft-SVM with Kernels
16.4 Summary
16.5 Bibliographic Remarks
16.6 Exercises

215
215
217
221
222
222
224
225
225

17

Multiclass, Ranking, and Complex Prediction Problems
17.1 One-versus-All and All-Pairs
17.2 Linear Multiclass Predictors
17.2.1 How to Construct Î¨
17.2.2 Cost-Sensitive Classification
17.2.3 ERM
17.2.4 Generalized Hinge Loss
17.2.5 Multiclass SVM and SGD
17.3 Structured Output Prediction
17.4 Ranking

227
227
230
230
232
232
233
234
236
238

xiv

Contents

17.4.1 Linear Predictors for Ranking
Bipartite Ranking and Multivariate Performance Measures
17.5.1 Linear Predictors for Bipartite Ranking
Summary
Bibliographic Remarks
Exercises

240
243
245
247
247
248

18

Decision Trees
18.1 Sample Complexity
18.2 Decision Tree Algorithms
18.2.1 Implementations of the Gain Measure
18.2.2 Pruning
18.2.3 Threshold-Based Splitting Rules for Real-Valued Features
18.3 Random Forests
18.4 Summary
18.5 Bibliographic Remarks
18.6 Exercises

250
251
252
253
254
255
255
256
256
256

19

Nearest Neighbor
19.1 k Nearest Neighbors
19.2 Analysis
19.2.1 A Generalization Bound for the 1-NN Rule
19.2.2 The â€œCurse of Dimensionalityâ€
19.3 Efficient Implementation*
19.4 Summary
19.5 Bibliographic Remarks
19.6 Exercises

258
258
259
260
263
264
264
264
265

20

Neural Networks
20.1 Feedforward Neural Networks
20.2 Learning Neural Networks
20.3 The Expressive Power of Neural Networks
20.3.1 Geometric Intuition
20.4 The Sample Complexity of Neural Networks
20.5 The Runtime of Learning Neural Networks
20.6 SGD and Backpropagation
20.7 Summary
20.8 Bibliographic Remarks
20.9 Exercises

268
269
270
271
273
274
276
277
281
281
282

Part III

Additional Learning Models

285

21

Online Learning
21.1 Online Classification in the Realizable Case

287
288

17.5
17.6
17.7
17.8

Contents

xv

21.1.1 Online Learnability
Online Classification in the Unrealizable Case
21.2.1 Weighted-Majority
Online Convex Optimization
The Online Perceptron Algorithm
Summary
Bibliographic Remarks
Exercises

290
294
295
300
301
304
305
305

22

Clustering
22.1 Linkage-Based Clustering Algorithms
22.2 k-Means and Other Cost Minimization Clusterings
22.2.1 The k-Means Algorithm
22.3 Spectral Clustering
22.3.1 Graph Cut
22.3.2 Graph Laplacian and Relaxed Graph Cuts
22.3.3 Unnormalized Spectral Clustering
22.4 Information Bottleneck*
22.5 A High Level View of Clustering
22.6 Summary
22.7 Bibliographic Remarks
22.8 Exercises

307
310
311
313
315
315
315
317
317
318
320
320
320

23

Dimensionality Reduction
23.1 Principal Component Analysis (PCA)
23.1.1 A More Efficient Solution for the Case d  m
23.1.2 Implementation and Demonstration
23.2 Random Projections
23.3 Compressed Sensing
23.3.1 Proofs*
23.4 PCA or Compressed Sensing?
23.5 Summary
23.6 Bibliographic Remarks
23.7 Exercises

323
324
326
326
329
330
333
338
338
339
339

24

Generative Models
24.1 Maximum Likelihood Estimator
24.1.1 Maximum Likelihood Estimation for Continuous Random Variables
24.1.2 Maximum Likelihood and Empirical Risk Minimization
24.1.3 Generalization Analysis
24.2 Naive Bayes
24.3 Linear Discriminant Analysis
24.4 Latent Variables and the EM Algorithm

342
343

21.2
21.3
21.4
21.5
21.6
21.7

344
345
345
347
347
348

xvi

Contents

24.5
24.6
24.7
24.8

24.4.1 EM as an Alternate Maximization Algorithm
24.4.2 EM for Mixture of Gaussians (Soft k-Means)
Bayesian Reasoning
Summary
Bibliographic Remarks
Exercises

350
352
353
355
355
356

25

Feature Selection and Generation
25.1 Feature Selection
25.1.1 Filters
25.1.2 Greedy Selection Approaches
25.1.3 Sparsity-Inducing Norms
25.2 Feature Manipulation and Normalization
25.2.1 Examples of Feature Transformations
25.3 Feature Learning
25.3.1 Dictionary Learning Using Auto-Encoders
25.4 Summary
25.5 Bibliographic Remarks
25.6 Exercises

357
358
359
360
363
365
367
368
368
370
371
371

Part IV

Advanced Theory

373

26

Rademacher Complexities
26.1 The Rademacher Complexity
26.1.1 Rademacher Calculus
26.2 Rademacher Complexity of Linear Classes
26.3 Generalization Bounds for SVM
26.4 Generalization Bounds for Predictors with Low `1 Norm
26.5 Bibliographic Remarks

375
375
379
382
383
386
386

27

Covering Numbers
27.1 Covering
27.1.1 Properties
27.2 From Covering to Rademacher Complexity via Chaining
27.3 Bibliographic Remarks

388
388
388
389
391

28

Proof of the Fundamental Theorem of Learning Theory
28.1 The Upper Bound for the Agnostic Case
28.2 The Lower Bound for the Agnostic Case
28.2.1 Showing That m(, Î´) â‰¥ 0.5 log(1/(4Î´))/2
28.2.2 Showing That m(, 1/8) â‰¥ 8d/2
28.3 The Upper Bound for the Realizable Case
28.3.1 From -Nets to PAC Learnability

392
392
393
393
395
398
401

Contents

xvii

29

Multiclass Learnability
29.1 The Natarajan Dimension
29.2 The Multiclass Fundamental Theorem
29.2.1 On the Proof of Theorem 29.3
29.3 Calculating the Natarajan Dimension
29.3.1 One-versus-All Based Classes
29.3.2 General Multiclass-to-Binary Reductions
29.3.3 Linear Multiclass Predictors
29.4 On Good and Bad ERMs
29.5 Bibliographic Remarks
29.6 Exercises

402
402
403
403
404
404
405
405
406
408
409

30

Compression Bounds
30.1 Compression Bounds
30.2 Examples
30.2.1 Axis Aligned Rectangles
30.2.2 Halfspaces
30.2.3 Separating Polynomials
30.2.4 Separation with Margin
30.3 Bibliographic Remarks

410
410
412
412
412
413
414
414

31

PAC-Bayes
31.1 PAC-Bayes Bounds
31.2 Bibliographic Remarks
31.3 Exercises

415
415
417
417

Appendix A

Technical Lemmas

419

Appendix B

Measure Concentration

422

Appendix C

Linear Algebra

430

Notes
References
Index

435
437
447

1

Introduction

The subject of this book is automated learning, or, as we will more often call
it, Machine Learning (ML). That is, we wish to program computers so that
they can â€œlearnâ€ from input available to them. Roughly speaking, learning is
the process of converting experience into expertise or knowledge. The input to
a learning algorithm is training data, representing experience, and the output
is some expertise, which usually takes the form of another computer program
that can perform some task. Seeking a formal-mathematical understanding of
this concept, weâ€™ll have to be more explicit about what we mean by each of the
involved terms: What is the training data our programs will access? How can
the process of learning be automated? How can we evaluate the success of such
a process (namely, the quality of the output of a learning program)?

1.1

What Is Learning?
Let us begin by considering a couple of examples from naturally occurring animal learning. Some of the most fundamental issues in ML arise already in that
context, which we are all familiar with.
Bait Shyness â€“ Rats Learning to Avoid Poisonous Baits: When rats encounter
food items with novel look or smell, they will first eat very small amounts, and
subsequent feeding will depend on the flavor of the food and its physiological
effect. If the food produces an ill effect, the novel food will often be associated
with the illness, and subsequently, the rats will not eat it. Clearly, there is a
learning mechanism in play here â€“ the animal used past experience with some
food to acquire expertise in detecting the safety of this food. If past experience
with the food was negatively labeled, the animal predicts that it will also have
a negative effect when encountered in the future.
Inspired by the preceding example of successful learning, let us demonstrate a
typical machine learning task. Suppose we would like to program a machine that
learns how to filter spam e-mails. A naive solution would be seemingly similar
to the way rats learn how to avoid poisonous baits. The machine will simply
memorize all previous e-mails that had been labeled as spam e-mails by the
human user. When a new e-mail arrives, the machine will search for it in the set
c 2014 by Shai Shalev-Shwartz and Shai Ben-David
Understanding Machine Learning, 
Published 2014 by Cambridge University Press.
Personal use only. Not for distribution. Do not post.
Please link to http://www.cs.huji.ac.il/~shais/UnderstandingMachineLearning

20

Introduction

of previous spam e-mails. If it matches one of them, it will be trashed. Otherwise,
it will be moved to the userâ€™s inbox folder.
While the preceding â€œlearning by memorizationâ€ approach is sometimes useful, it lacks an important aspect of learning systems â€“ the ability to label unseen
e-mail messages. A successful learner should be able to progress from individual
examples to broader generalization. This is also referred to as inductive reasoning
or inductive inference. In the bait shyness example presented previously, after
the rats encounter an example of a certain type of food, they apply their attitude
toward it on new, unseen examples of food of similar smell and taste. To achieve
generalization in the spam filtering task, the learner can scan the previously seen
e-mails, and extract a set of words whose appearance in an e-mail message is
indicative of spam. Then, when a new e-mail arrives, the machine can check
whether one of the suspicious words appears in it, and predict its label accordingly. Such a system would potentially be able correctly to predict the label of
unseen e-mails.
However, inductive reasoning might lead us to false conclusions. To illustrate
this, let us consider again an example from animal learning.
Pigeon Superstition: In an experiment performed by the psychologist B. F. Skinner,
he placed a bunch of hungry pigeons in a cage. An automatic mechanism had
been attached to the cage, delivering food to the pigeons at regular intervals
with no reference whatsoever to the birdsâ€™ behavior. The hungry pigeons went
around the cage, and when food was first delivered, it found each pigeon engaged
in some activity (pecking, turning the head, etc.). The arrival of food reinforced
each birdâ€™s specific action, and consequently, each bird tended to spend some
more time doing that very same action. That, in turn, increased the chance that
the next random food delivery would find each bird engaged in that activity
again. What results is a chain of events that reinforces the pigeonsâ€™ association
of the delivery of the food with whatever chance actions they had been performing when it was first delivered. They subsequently continue to perform these
same actions diligently.1
What distinguishes learning mechanisms that result in superstition from useful
learning? This question is crucial to the development of automated learners.
While human learners can rely on common sense to filter out random meaningless
learning conclusions, once we export the task of learning to a machine, we must
provide well defined crisp principles that will protect the program from reaching
senseless or useless conclusions. The development of such principles is a central
goal of the theory of machine learning.
What, then, made the ratsâ€™ learning more successful than that of the pigeons?
As a first step toward answering this question, let us have a closer look at the
bait shyness phenomenon in rats.
Bait Shyness revisited â€“ rats fail to acquire conditioning between food and
electric shock or between sound and nausea: The bait shyness mechanism in
1

See: http://psychclassics.yorku.ca/Skinner/Pigeon

1.2 When Do We Need Machine Learning?

21

rats turns out to be more complex than what one may expect. In experiments
carried out by Garcia (Garcia & Koelling 1996), it was demonstrated that if the
unpleasant stimulus that follows food consumption is replaced by, say, electrical
shock (rather than nausea), then no conditioning occurs. Even after repeated
trials in which the consumption of some food is followed by the administration of
unpleasant electrical shock, the rats do not tend to avoid that food. Similar failure
of conditioning occurs when the characteristic of the food that implies nausea
(such as taste or smell) is replaced by a vocal signal. The rats seem to have
some â€œbuilt inâ€ prior knowledge telling them that, while temporal correlation
between food and nausea can be causal, it is unlikely that there would be a
causal relationship between food consumption and electrical shocks or between
sounds and nausea.
We conclude that one distinguishing feature between the bait shyness learning
and the pigeon superstition is the incorporation of prior knowledge that biases
the learning mechanism. This is also referred to as inductive bias. The pigeons in
the experiment are willing to adopt any explanation for the occurrence of food.
However, the rats â€œknowâ€ that food cannot cause an electric shock and that the
co-occurrence of noise with some food is not likely to affect the nutritional value
of that food. The ratsâ€™ learning process is biased toward detecting some kind of
patterns while ignoring other temporal correlations between events.
It turns out that the incorporation of prior knowledge, biasing the learning
process, is inevitable for the success of learning algorithms (this is formally stated
and proved as the â€œNo-Free-Lunch theoremâ€ in Chapter 5). The development of
tools for expressing domain expertise, translating it into a learning bias, and
quantifying the effect of such a bias on the success of learning is a central theme
of the theory of machine learning. Roughly speaking, the stronger the prior
knowledge (or prior assumptions) that one starts the learning process with, the
easier it is to learn from further examples. However, the stronger these prior
assumptions are, the less flexible the learning is â€“ it is bound, a priori, by the
commitment to these assumptions. We shall discuss these issues explicitly in
Chapter 5.

1.2

When Do We Need Machine Learning?
When do we need machine learning rather than directly program our computers
to carry out the task at hand? Two aspects of a given problem may call for the
use of programs that learn and improve on the basis of their â€œexperienceâ€: the
problemâ€™s complexity and the need for adaptivity.
Tasks That Are Too Complex to Program.
â€¢ Tasks Performed by Animals/Humans: There are numerous tasks that
we human beings perform routinely, yet our introspection concerning how we do them is not sufficiently elaborate to extract a well

22

Introduction

defined program. Examples of such tasks include driving, speech
recognition, and image understanding. In all of these tasks, state
of the art machine learning programs, programs that â€œlearn from
their experience,â€ achieve quite satisfactory results, once exposed
to sufficiently many training examples.
â€¢ Tasks beyond Human Capabilities: Another wide family of tasks that
benefit from machine learning techniques are related to the analysis of very large and complex data sets: astronomical data, turning
medical archives into medical knowledge, weather prediction, analysis of genomic data, Web search engines, and electronic commerce.
With more and more available digitally recorded data, it becomes
obvious that there are treasures of meaningful information buried
in data archives that are way too large and too complex for humans
to make sense of. Learning to detect meaningful patterns in large
and complex data sets is a promising domain in which the combination of programs that learn with the almost unlimited memory
capacity and ever increasing processing speed of computers opens
up new horizons.
Adaptivity. One limiting feature of programmed tools is their rigidity â€“ once
the program has been written down and installed, it stays unchanged.
However, many tasks change over time or from one user to another.
Machine learning tools â€“ programs whose behavior adapts to their input
data â€“ offer a solution to such issues; they are, by nature, adaptive
to changes in the environment they interact with. Typical successful
applications of machine learning to such problems include programs that
decode handwritten text, where a fixed program can adapt to variations
between the handwriting of different users; spam detection programs,
adapting automatically to changes in the nature of spam e-mails; and
speech recognition programs.

1.3

Types of Learning
Learning is, of course, a very wide domain. Consequently, the field of machine
learning has branched into several subfields dealing with different types of learning tasks. We give a rough taxonomy of learning paradigms, aiming to provide
some perspective of where the content of this book sits within the wide field of
machine learning.
We describe four parameters along which learning paradigms can be classified.
Supervised versus Unsupervised Since learning involves an interaction between the learner and the environment, one can divide learning tasks
according to the nature of that interaction. The first distinction to note
is the difference between supervised and unsupervised learning. As an

1.3 Types of Learning

23

illustrative example, consider the task of learning to detect spam e-mail
versus the task of anomaly detection. For the spam detection task, we
consider a setting in which the learner receives training e-mails for which
the label spam/not-spam is provided. On the basis of such training the
learner should figure out a rule for labeling a newly arriving e-mail message. In contrast, for the task of anomaly detection, all the learner gets
as training is a large body of e-mail messages (with no labels) and the
learnerâ€™s task is to detect â€œunusualâ€ messages.
More abstractly, viewing learning as a process of â€œusing experience
to gain expertise,â€ supervised learning describes a scenario in which the
â€œexperience,â€ a training example, contains significant information (say,
the spam/not-spam labels) that is missing in the unseen â€œtest examplesâ€
to which the learned expertise is to be applied. In this setting, the acquired expertise is aimed to predict that missing information for the test
data. In such cases, we can think of the environment as a teacher that
â€œsupervisesâ€ the learner by providing the extra information (labels). In
unsupervised learning, however, there is no distinction between training
and test data. The learner processes input data with the goal of coming
up with some summary, or compressed version of that data. Clustering
a data set into subsets of similar objets is a typical example of such a
task.
There is also an intermediate learning setting in which, while the
training examples contain more information than the test examples, the
learner is required to predict even more information for the test examples. For example, one may try to learn a value function that describes for
each setting of a chess board the degree by which Whiteâ€™s position is better than the Blackâ€™s. Yet, the only information available to the learner at
training time is positions that occurred throughout actual chess games,
labeled by who eventually won that game. Such learning frameworks are
mainly investigated under the title of reinforcement learning.
Active versus Passive Learners Learning paradigms can vary by the role
played by the learner. We distinguish between â€œactiveâ€ and â€œpassiveâ€
learners. An active learner interacts with the environment at training
time, say, by posing queries or performing experiments, while a passive
learner only observes the information provided by the environment (or
the teacher) without influencing or directing it. Note that the learner of a
spam filter is usually passive â€“ waiting for users to mark the e-mails coming to them. In an active setting, one could imagine asking users to label
specific e-mails chosen by the learner, or even composed by the learner, to
enhance
its
understanding
of
what
spam is.
Helpfulness of the Teacher When one thinks about human learning, of a
baby at home or a student at school, the process often involves a helpful
teacher, who is trying to feed the learner with the information most use-

24

Introduction

ful for achieving the learning goal. In contrast, when a scientist learns
about nature, the environment, playing the role of the teacher, can be
best thought of as passive â€“ apples drop, stars shine, and the rain falls
without regard to the needs of the learner. We model such learning scenarios by postulating that the training data (or the learnerâ€™s experience)
is generated by some random process. This is the basic building block in
the branch of â€œstatistical learning.â€ Finally, learning also occurs when
the learnerâ€™s input is generated by an adversarial â€œteacher.â€ This may be
the case in the spam filtering example (if the spammer makes an effort
to mislead the spam filtering designer) or in learning to detect fraud.
One also uses an adversarial teacher model as a worst-case scenario,
when no milder setup can be safely assumed. If you can learn against an
adversarial teacher, you are guaranteed to succeed interacting any odd
teacher.
Online versus Batch Learning Protocol The last parameter we mention is
the distinction between situations in which the learner has to respond
online, throughout the learning process, and settings in which the learner
has to engage the acquired expertise only after having a chance to process
large amounts of data. For example, a stockbroker has to make daily
decisions, based on the experience collected so far. He may become an
expert over time, but might have made costly mistakes in the process. In
contrast, in many data mining settings, the learner â€“ the data miner â€“
has large amounts of training data to play with before having to output
conclusions.
In this book we shall discuss only a subset of the possible learning paradigms.
Our main focus is on supervised statistical batch learning with a passive learner
(for example, trying to learn how to generate patientsâ€™ prognoses, based on large
archives of records of patients that were independently collected and are already
labeled by the fate of the recorded patients). We shall also briefly discuss online
learning and batch unsupervised learning (in particular, clustering).

1.4

Relations to Other Fields
As an interdisciplinary field, machine learning shares common threads with the
mathematical fields of statistics, information theory, game theory, and optimization. It is naturally a subfield of computer science, as our goal is to program
machines so that they will learn. In a sense, machine learning can be viewed as
a branch of AI (Artificial Intelligence), since, after all, the ability to turn experience into expertise or to detect meaningful patterns in complex sensory data
is a cornerstone of human (and animal) intelligence. However, one should note
that, in contrast with traditional AI, machine learning is not trying to build
automated imitation of intelligent behavior, but rather to use the strengths and

1.5 How to Read This Book

25

special abilities of computers to complement human intelligence, often performing tasks that fall way beyond human capabilities. For example, the ability to
scan and process huge databases allows machine learning programs to detect
patterns that are outside the scope of human perception.
The component of experience, or training, in machine learning often refers
to data that is randomly generated. The task of the learner is to process such
randomly generated examples toward drawing conclusions that hold for the environment from which these examples are picked. This description of machine
learning highlights its close relationship with statistics. Indeed there is a lot in
common between the two disciplines, in terms of both the goals and techniques
used. There are, however, a few significant differences of emphasis; if a doctor
comes up with the hypothesis that there is a correlation between smoking and
heart disease, it is the statisticianâ€™s role to view samples of patients and check
the validity of that hypothesis (this is the common statistical task of hypothesis testing). In contrast, machine learning aims to use the data gathered from
samples of patients to come up with a description of the causes of heart disease.
The hope is that automated techniques may be able to figure out meaningful
patterns (or hypotheses) that may have been missed by the human observer.
In contrast with traditional statistics, in machine learning in general, and
in this book in particular, algorithmic considerations play a major role. Machine learning is about the execution of learning by computers; hence algorithmic issues are pivotal. We develop algorithms to perform the learning tasks and
are concerned with their computational efficiency. Another difference is that
while statistics is often interested in asymptotic behavior (like the convergence
of sample-based statistical estimates as the sample sizes grow to infinity), the
theory of machine learning focuses on finite sample bounds. Namely, given the
size of available samples, machine learning theory aims to figure out the degree
of accuracy that a learner can expect on the basis of such samples.
There are further differences between these two disciplines, of which we shall
mention only one more here. While in statistics it is common to work under the
assumption of certain presubscribed data models (such as assuming the normality of data-generating distributions, or the linearity of functional dependencies),
in machine learning the emphasis is on working under a â€œdistribution-freeâ€ setting, where the learner assumes as little as possible about the nature of the
data distribution and allows the learning algorithm to figure out which models
best approximate the data-generating process. A precise discussion of this issue
requires some technical preliminaries, and we will come back to it later in the
book, and in particular in Chapter 5.

1.5

How to Read This Book
The first part of the book provides the basic theoretical principles that underlie
machine learning (ML). In a sense, this is the foundation upon which the rest

26

Introduction

of the book is built. This part could serve as a basis for a minicourse on the
theoretical foundations of ML.
The second part of the book introduces the most commonly used algorithmic
approaches to supervised machine learning. A subset of these chapters may also
be used for introducing machine learning in a general AI course to computer
science, Math, or engineering students.
The third part of the book extends the scope of discussion from statistical
classification to other learning models. It covers online learning, unsupervised
learning, dimensionality reduction, generative models, and feature learning.
The fourth part of the book, Advanced Theory, is geared toward readers who
have interest in research and provides the more technical mathematical techniques that serve to analyze and drive forward the field of theoretical machine
learning.
The Appendixes provide some technical tools used in the book. In particular,
we list basic results from measure concentration and linear algebra.
A few sections are marked by an asterisk, which means they are addressed to
more advanced students. Each chapter is concluded with a list of exercises. A
solution manual is provided in the course Web site.

1.5.1

Possible Course Plans Based on This Book
A 14 Week Introduction Course for Graduate Students:
1.
2.
3.
4.
5.
6.
7.
8.
9.
10.
11.
12.
13.
14.

Chapters 2â€“4.
Chapter 9 (without the VC calculation).
Chapters 5â€“6 (without proofs).
Chapter 10.
Chapters 7, 11 (without proofs).
Chapters 12, 13 (with some of the easier proofs).
Chapter 14 (with some of the easier proofs).
Chapter 15.
Chapter 16.
Chapter 18.
Chapter 22.
Chapter 23 (without proofs for compressed sensing).
Chapter 24.
Chapter 25.

A 14 Week Advanced Course for Graduate Students:
1.
2.
3.
4.
5.

Chapters 26, 27.
(continued)
Chapters 6, 28.
Chapter 7.
Chapter 31.

1.6 Notation

6.
7.
8.
9.
10.
11.
12.
13.
14.

1.6

27

Chapter 30.
Chapters 12, 13.
Chapter 14.
Chapter 8.
Chapter 17.
Chapter 29.
Chapter 19.
Chapter 20.
Chapter 21.

Notation
Most of the notation we use throughout the book is either standard or defined
on the spot. In this section we describe our main conventions and provide a
table summarizing our notation (Table 1.1). The reader is encouraged to skip
this section and return to it if during the reading of the book some notation is
unclear.
We denote scalars and abstract objects with lowercase letters (e.g. x and Î»).
Often, we would like to emphasize that some object is a vector and then we
use boldface letters (e.g. x and Î»). The ith element of a vector x is denoted
by xi . We use uppercase letters to denote matrices, sets, and sequences. The
meaning should be clear from the context. As we will see momentarily, the input
of a learning algorithm is a sequence of training examples. We denote by z an
abstract example and by S = z1 , . . . , zm a sequence of m examples. Historically,
S is often referred to as a training set; however, we will always assume that S is
a sequence rather than a set. A sequence of m vectors is denoted by x1 , . . . , xm .
The ith element of xt is denoted by xt,i .
Throughout the book, we make use of basic notions from probability. We
denote by D a distribution over some set,2 for example, Z. We use the notation
z âˆ¼ D to denote that z is sampled according to D. Given a random variable
f : Z â†’ R, its expected value is denoted by Ezâˆ¼D [f (z)]. We sometimes use the
shorthand E[f ] when the dependence on z is clear from the context. For f : Z â†’
{true, false} we also use Pzâˆ¼D [f (z)] to denote D({z : f (z) = true}). In the
next chapter we will also introduce the notation Dm to denote the probability
over Z m induced by sampling (z1 , . . . , zm ) where each point zi is sampled from
D independently of the other points.
In general, we have made an effort to avoid asymptotic notation. However, we
occasionally use it to clarify the main results. In particular, given f : R â†’ R+
and g : R â†’ R+ we write f = O(g) if there exist x0 , Î± âˆˆ R+ such that for all
x > x0 we have f (x) â‰¤ Î±g(x). We write f = o(g) if for every Î± > 0 there exists
2

To be mathematically precise, D should be defined over some Ïƒ-algebra of subsets of Z.
The user who is not familiar with measure theory can skip the few footnotes and remarks
regarding more formal measurability definitions and assumptions.

28

Introduction

symbol
R
Rd
R+
N
O, o, Î˜, Ï‰, â„¦, OÌƒ
1[Boolean expression]
[a]+
[n]
x, v, w
xi , v i , w i
hx, vi
kxk2 or kxk
kxk1
kxkâˆž
kxk0
A âˆˆ Rd,k
A>
Ai,j
x x>
x1 , . . . , xm
xi,j
w(1) , . . . , w(T )
(t)
wi
X
Y
Z
H
` : H Ã— Z â†’ R+
D
D(A)
zâˆ¼D
S = z1 , . . . , z m
S âˆ¼ Dm
P, E
Pzâˆ¼D [f (z)]
Ezâˆ¼D [f (z)]
N (Âµ, C)
f 0 (x)
f 00 (x)
âˆ‚f (w)
âˆ‚wi

âˆ‡f (w)
âˆ‚f (w)
minxâˆˆC f (x)
maxxâˆˆC f (x)
argminxâˆˆC f (x)
argmaxxâˆˆC f (x)
log

Table 1.1 Summary of notation
meaning
the set of real numbers
the set of d-dimensional vectors over R
the set of non-negative real numbers
the set of natural numbers
asymptotic notation (see text)
indicator function (equals 1 if expression is true and 0 o.w.)
= max{0, a}
the set {1, . . . , n} (for n âˆˆ N)
(column) vectors
the ith element of a vector
P
= p di=1 xi vi (inner product)
= hx, xi (the `2 norm of x)
P
= di=1 |xi | (the `1 norm of x)
= maxi |xi | (the `âˆž norm of x)
the number of nonzero elements of x
a d Ã— k matrix over R
the transpose of A
the (i, j) element of A
the d Ã— d matrix A s.t. Ai,j = xi xj (where x âˆˆ Rd )
a sequence of m vectors
the jth element of the ith vector in the sequence
the values of a vector w during an iterative algorithm
the ith element of the vector w(t)
instances domain (a set)
labels domain (a set)
examples domain (a set)
hypothesis class (a set)
loss function
a distribution over some set (usually over Z or over X )
the probability of a set A âŠ† Z according to D
sampling z according to D
a sequence of m examples
sampling S = z1 , . . . , zm i.i.d. according to D
probability and expectation of a random variable
= D({z : f (z) = true}) for f : Z â†’ {true, false}
expectation of the random variable f : Z â†’ R
Gaussian distribution with expectation Âµ and covariance C
the derivative of a function f : R â†’ R at x
the second derivative of a function f : R â†’ R at x
the partial derivative of a function f : Rd â†’ R at w w.r.t. wi
the gradient of a function f : Rd â†’ R at w
the differential set of a function f : Rd â†’ R at w
= min{f (x) : x âˆˆ C} (minimal value of f over C)
= max{f (x) : x âˆˆ C} (maximal value of f over C)
the set {x âˆˆ C : f (x) = minzâˆˆC f (z)}
the set {x âˆˆ C : f (x) = maxzâˆˆC f (z)}
the natural logarithm

1.6 Notation

29

x0 such that for all x > x0 we have f (x) â‰¤ Î±g(x). We write f = â„¦(g) if there
exist x0 , Î± âˆˆ R+ such that for all x > x0 we have f (x) â‰¥ Î±g(x). The notation
f = Ï‰(g) is defined analogously. The notation f = Î˜(g) means that f = O(g)
and g = O(f ). Finally, the notation f = OÌƒ(g) means that there exists k âˆˆ N
such that f (x) = O(g(x) logk (g(x))).
The inner product between vectors x and w is denoted by hx, wi. Whenever we
do not specify the vector space we assume that it is the d-dimensional Euclidean
Pd
space and
pthen hx, wi = i=1 xi wi . The Euclidean (or `2 ) norm of a vector w is
kwk2 = hw, wi. We omit the subscript from the `2 norm when it is clear from
P
1/p
the context. We also use other `p norms, kwkp = ( i |wi |p ) , and in particular
P
kwk1 = i |wi | and kwkâˆž = maxi |wi |.
We use the notation minxâˆˆC f (x) to denote the minimum value of the set
{f (x) : x âˆˆ C}. To be mathematically more precise, we should use inf xâˆˆC f (x)
whenever the minimum is not achievable. However, in the context of this book
the distinction between infimum and minimum is often of little interest. Hence,
to simplify the presentation, we sometimes use the min notation even when inf
is more adequate. An analogous remark applies to max versus sup.

Part I
Foundations

2

A Gentle Start

Let us begin our mathematical analysis by showing how successful learning can be
achieved in a relatively simplified setting. Imagine you have just arrived in some
small Pacific island. You soon find out that papayas are a significant ingredient
in the local diet. However, you have never before tasted papayas. You have to
learn how to predict whether a papaya you see in the market is tasty or not.
First, you need to decide which features of a papaya your prediction should be
based on. On the basis of your previous experience with other fruits, you decide
to use two features: the papayaâ€™s color, ranging from dark green, through orange
and red to dark brown, and the papayaâ€™s softness, ranging from rock hard to
mushy. Your input for figuring out your prediction rule is a sample of papayas
that you have examined for color and softness and then tasted and found out
whether they were tasty or not. Let us analyze this task as a demonstration of
the considerations involved in learning problems.
Our first step is to describe a formal model aimed to capture such learning
tasks.

2.1

A Formal Model â€“ The Statistical Learning Framework
â€¢ The learnerâ€™s input: In the basic statistical learning setting, the learner has
access to the following:
â€“ Domain set: An arbitrary set, X . This is the set of objects that we
may wish to label. For example, in the papaya learning problem mentioned before, the domain set will be the set of all papayas. Usually,
these domain points will be represented by a vector of features (like
the papayaâ€™s color and softness). We also refer to domain points as
instances and to X as instance space.
â€“ Label set: For our current discussion, we will restrict the label set to
be a two-element set, usually {0, 1} or {âˆ’1, +1}. Let Y denote our
set of possible labels. For our papayas example, let Y be {0, 1}, where
1 represents being tasty and 0 stands for being not-tasty.
â€“ Training data: S = ((x1 , y1 ) . . . (xm , ym )) is a finite sequence of pairs in
X Ã— Y: that is, a sequence of labeled domain points. This is the input
that the learner has access to (like a set of papayas that have been
c 2014 by Shai Shalev-Shwartz and Shai Ben-David
Understanding Machine Learning, 
Published 2014 by Cambridge University Press.
Personal use only. Not for distribution. Do not post.
Please link to http://www.cs.huji.ac.il/~shais/UnderstandingMachineLearning

34

A Gentle Start

tasted and their color, softness, and tastiness). Such labeled examples
are often called training examples. We sometimes also refer to S as a
training set.1
â€¢ The learnerâ€™s output: The learner is requested to output a prediction rule,
h : X â†’ Y. This function is also called a predictor, a hypothesis, or a classifier. The predictor can be used to predict the label of new domain points.
In our papayas example, it is a rule that our learner will employ to predict
whether future papayas he examines in the farmersâ€™ market are going to
be tasty or not. We use the notation A(S) to denote the hypothesis that a
learning algorithm, A, returns upon receiving the training sequence S.
â€¢ A simple data-generation model We now explain how the training data is
generated. First, we assume that the instances (the papayas we encounter)
are generated by some probability distribution (in this case, representing
the environment). Let us denote that probability distribution over X by
D. It is important to note that we do not assume that the learner knows
anything about this distribution. For the type of learning tasks we discuss,
this could be any arbitrary probability distribution. As to the labels, in the
current discussion we assume that there is some â€œcorrectâ€ labeling function,
f : X â†’ Y, and that yi = f (xi ) for all i. This assumption will be relaxed in
the next chapter. The labeling function is unknown to the learner. In fact,
this is just what the learner is trying to figure out. In summary, each pair
in the training data S is generated by first sampling a point xi according
to D and then labeling it by f .
â€¢ Measures of success: We define the error of a classifier to be the probability
that it does not predict the correct label on a random data point generated
by the aforementioned underlying distribution. That is, the error of h is
the probability to draw a random instance x, according to the distribution
D, such that h(x) does not equal f (x).
Formally, given a domain subset,2 A âŠ‚ X , the probability distribution,
D, assigns a number, D(A), which determines how likely it is to observe a
point x âˆˆ A. In many cases, we refer to A as an event and express it using
a function Ï€ : X â†’ {0, 1}, namely, A = {x âˆˆ X : Ï€(x) = 1}. In that case,
we also use the notation Pxâˆ¼D [Ï€(x)] to express D(A).
We define the error of a prediction rule, h : X â†’ Y, to be
def

LD,f (h) =

def

P [h(x) 6= f (x)] = D({x : h(x) 6= f (x)}).

xâˆ¼D

(2.1)

That is, the error of such h is the probability of randomly choosing an
example x for which h(x) 6= f (x). The subscript (D, f ) indicates that the
error is measured with respect to the probability distribution D and the
1
2

Despite the â€œsetâ€ notation, S is a sequence. In particular, the same example may appear
twice in S and some algorithms can take into account the order of examples in S.
Strictly speaking, we should be more careful and require that A is a member of some
Ïƒ-algebra of subsets of X , over which D is defined. We will formally define our
measurability assumptions in the next chapter.

2.2 Empirical Risk Minimization

35

correct labeling function f . We omit this subscript when it is clear from
the context. L(D,f ) (h) has several synonymous names such as the generalization error, the risk, or the true error of h, and we will use these names
interchangeably throughout the book. We use the letter L for the error,
since we view this error as the loss of the learner. We will later also discuss
other possible formulations of such loss.
â€¢ A note about the information available to the learner The learner is
blind to the underlying distribution D over the world and to the labeling
function f. In our papayas example, we have just arrived in a new island
and we have no clue as to how papayas are distributed and how to predict
their tastiness. The only way the learner can interact with the environment
is through observing the training set.
In the next section we describe a simple learning paradigm for the preceding
setup and analyze its performance.

2.2

Empirical Risk Minimization
As mentioned earlier, a learning algorithm receives as input a training set S,
sampled from an unknown distribution D and labeled by some target function
f , and should output a predictor hS : X â†’ Y (the subscript S emphasizes the
fact that the output predictor depends on S). The goal of the algorithm is to
find hS that minimizes the error with respect to the unknown D and f .
Since the learner does not know what D and f are, the true error is not directly
available to the learner. A useful notion of error that can be calculated by the
learner is the training error â€“ the error the classifier incurs over the training
sample:
def |{i âˆˆ [m] : h(xi ) 6= yi }|
,
(2.2)
LS (h) =
m
where [m] = {1, . . . , m}.
The terms empirical error and empirical risk are often used interchangeably
for this error.
Since the training sample is the snapshot of the world that is available to the
learner, it makes sense to search for a solution that works well on that data.
This learning paradigm â€“ coming up with a predictor h that minimizes LS (h) â€“
is called Empirical Risk Minimization or ERM for short.

2.2.1

Something May Go Wrong â€“ Overfitting
Although the ERM rule seems very natural, without being careful, this approach
may fail miserably.
To demonstrate such a failure, let us go back to the problem of learning to

36

A Gentle Start

predict the taste of a papaya on the basis of its softness and color. Consider a
sample as depicted in the following:

Assume that the probability distribution D is such that instances are distributed
uniformly within the gray square and the labeling function, f , determines the
label to be 1 if the instance is within the inner blue square, and 0 otherwise. The
area of the gray square in the picture is 2 and the area of the blue square is 1.
Consider the following predictor:
(
yi if âˆƒi âˆˆ [m] s.t. xi = x
(2.3)
hS (x) =
0 otherwise.
While this predictor might seem rather artificial, in Exercise 1 we show a natural
representation of it using polynomials. Clearly, no matter what the sample is,
LS (hS ) = 0, and therefore this predictor may be chosen by an ERM algorithm (it
is one of the empirical-minimum-cost hypotheses; no classifier can have smaller
error). On the other hand, the true error of any classifier that predicts the label
1 only on a finite number of instances is, in this case, 1/2. Thus, LD (hS ) = 1/2.
We have found a predictor whose performance on the training set is excellent,
yet its performance on the true â€œworldâ€ is very poor. This phenomenon is called
overfitting. Intuitively, overfitting occurs when our hypothesis fits the training
data â€œtoo wellâ€ (perhaps like the everyday experience that a person who provides
a perfect detailed explanation for each of his single actions may raise suspicion).

2.3

Empirical Risk Minimization with Inductive Bias
We have just demonstrated that the ERM rule might lead to overfitting. Rather
than giving up on the ERM paradigm, we will look for ways to rectify it. We will
search for conditions under which there is a guarantee that ERM does not overfit,
namely, conditions under which when the ERM predictor has good performance
with respect to the training data, it is also highly likely to perform well over the
underlying data distribution.
A common solution is to apply the ERM learning rule over a restricted search
space. Formally, the learner should choose in advance (before seeing the data) a
set of predictors. This set is called a hypothesis class and is denoted by H. Each
h âˆˆ H is a function mapping from X to Y. For a given class H, and a training
sample, S, the ERMH learner uses the ERM rule to choose a predictor h âˆˆ H,

2.3 Empirical Risk Minimization with Inductive Bias

37

with the lowest possible error over S. Formally,
ERMH (S) âˆˆ argmin LS (h),
hâˆˆH

where argmin stands for the set of hypotheses in H that achieve the minimum
value of LS (h) over H. By restricting the learner to choosing a predictor from
H, we bias it toward a particular set of predictors. Such restrictions are often
called an inductive bias. Since the choice of such a restriction is determined
before the learner sees the training data, it should ideally be based on some
prior knowledge about the problem to be learned. For example, for the papaya
taste prediction problem we may choose the class H to be the set of predictors
that are determined by axis aligned rectangles (in the space determined by the
color and softness coordinates). We will later show that ERMH over this class is
guaranteed not to overfit. On the other hand, the example of overfitting that we
have seen previously, demonstrates that choosing H to be a class of predictors
that includes all functions that assign the value 1 to a finite set of domain points
does not suffice to guarantee that ERMH will not overfit.
A fundamental question in learning theory is, over which hypothesis classes
ERMH learning will not result in overfitting. We will study this question later
in the book.
Intuitively, choosing a more restricted hypothesis class better protects us
against overfitting but at the same time might cause us a stronger inductive
bias. We will get back to this fundamental tradeoff later.

2.3.1

Finite Hypothesis Classes
The simplest type of restriction on a class is imposing an upper bound on its size
(that is, the number of predictors h in H). In this section, we show that if H is
a finite class then ERMH will not overfit, provided it is based on a sufficiently
large training sample (this size requirement will depend on the size of H).
Limiting the learner to prediction rules within some finite hypothesis class may
be considered as a reasonably mild restriction. For example, H can be the set of
all predictors that can be implemented by a C++ program written in at most
109 bits of code. In our papayas example, we mentioned previously the class of
axis aligned rectangles. While this is an infinite class, if we discretize the representation of real numbers, say, by using a 64 bits floating-point representation,
the hypothesis class becomes a finite class.
Let us now analyze the performance of the ERMH learning rule assuming that
H is a finite class. For a training sample, S, labeled according to some f : X â†’ Y,
let hS denote a result of applying ERMH to S, namely,
hS âˆˆ argmin LS (h).

(2.4)

hâˆˆH

In this chapter, we make the following simplifying assumption (which will be
relaxed in the next chapter).

38

A Gentle Start

definition 2.1 (The Realizability Assumption) There exists h? âˆˆ H s.t.
L(D,f ) (h? ) = 0. Note that this assumption implies that with probability 1 over
random samples, S, where the instances of S are sampled according to D and
are labeled by f , we have LS (h? ) = 0.
The realizability assumption implies that for every ERM hypothesis we have
that3 LS (hS ) = 0. However, we are interested in the true risk of hS , L(D,f ) (hS ),
rather than its empirical risk.
Clearly, any guarantee on the error with respect to the underlying distribution,
D, for an algorithm that has access only to a sample S should depend on the
relationship between D and S. The common assumption in statistical machine
learning is that the training sample S is generated by sampling points from the
distribution D independently of each other. Formally,
â€¢ The i.i.d. assumption: The examples in the training set are independently
and identically distributed (i.i.d.) according to the distribution D. That is,
every xi in S is freshly sampled according to D and then labeled according
to the labeling function, f . We denote this assumption by S âˆ¼ Dm where
m is the size of S, and Dm denotes the probability over m-tuples induced
by applying D to pick each element of the tuple independently of the other
members of the tuple.
Intuitively, the training set S is a window through which the learner
gets partial information about the distribution D over the world and the
labeling function, f . The larger the sample gets, the more likely it is to
reflect more accurately the distribution and labeling used to generate it.
Since L(D,f ) (hS ) depends on the training set, S, and that training set is picked
by a random process, there is randomness in the choice of the predictor hS
and, consequently, in the risk L(D,f ) (hS ). Formally, we say that it is a random
variable. It is not realistic to expect that with full certainty S will suffice to
direct the learner toward a good classifier (from the point of view of D), as
there is always some probability that the sampled training data happens to
be very nonrepresentative of the underlying D. If we go back to the papaya
tasting example, there is always some (small) chance that all the papayas we
have happened to taste were not tasty, in spite of the fact that, say, 70% of the
papayas in our island are tasty. In such a case, ERMH (S) may be the constant
function that labels every papaya as â€œnot tastyâ€ (and has 70% error on the true
distribution of papapyas in the island). We will therefore address the probability
to sample a training set for which L(D,f ) (hS ) is not too large. Usually, we denote
the probability of getting a nonrepresentative sample by Î´, and call (1 âˆ’ Î´) the
confidence parameter of our prediction.
On top of that, since we cannot guarantee perfect label prediction, we introduce another parameter for the quality of prediction, the accuracy parameter,
3

Mathematically speaking, this holds with probability 1. To simplify the presentation, we
sometimes omit the â€œwith probability 1â€ specifier.

2.3 Empirical Risk Minimization with Inductive Bias

39

commonly denoted by . We interpret the event L(D,f ) (hS ) >  as a failure of the
learner, while if L(D,f ) (hS ) â‰¤  we view the output of the algorithm as an approximately correct predictor. Therefore (fixing some labeling function f : X â†’ Y),
we are interested in upper bounding the probability to sample m-tuple of instances that will lead to failure of the learner. Formally, let S|x = (x1 , . . . , xm )
be the instances of the training set. We would like to upper bound
Dm ({S|x : L(D,f ) (hS ) > }).
Let HB be the set of â€œbadâ€ hypotheses, that is,
HB = {h âˆˆ H : L(D,f ) (h) > }.
In addition, let
M = {S|x : âˆƒh âˆˆ HB , LS (h) = 0}
be the set of misleading samples: Namely, for every S|x âˆˆ M , there is a â€œbadâ€
hypothesis, h âˆˆ HB , that looks like a â€œgoodâ€ hypothesis on S|x . Now, recall that
we would like to bound the probability of the event L(D,f ) (hS ) > . But, since
the realizability assumption implies that LS (hS ) = 0, it follows that the event
L(D,f ) (hS ) >  can only happen if for some h âˆˆ HB we have LS (h) = 0. In
other words, this event will only happen if our sample is in the set of misleading
samples, M . Formally, we have shown that
{S|x : L(D,f ) (hS ) > } âŠ† M .
Note that we can rewrite M as
M=

[

{S|x : LS (h) = 0}.

(2.5)

hâˆˆHB

Hence,
Dm ({S|x : L(D,f ) (hS ) > }) â‰¤ Dm (M ) = Dm (âˆªhâˆˆHB {S|x : LS (h) = 0}).
(2.6)
Next, we upper bound the right-hand side of the preceding equation using the
union bound â€“ a basic property of probabilities.
lemma 2.2 (Union Bound)
have

For any two sets A, B and a distribution D we

D(A âˆª B) â‰¤ D(A) + D(B).
Applying the union bound to the right-hand side of Equation (2.6) yields
X
Dm ({S|x : L(D,f ) (hS ) > }) â‰¤
Dm ({S|x : LS (h) = 0}).
(2.7)
hâˆˆHB

Next, let us bound each summand of the right-hand side of the preceding inequality. Fix some â€œbadâ€ hypothesis h âˆˆ HB . The event LS (h) = 0 is equivalent

40

A Gentle Start

to the event âˆ€i, h(xi ) = f (xi ). Since the examples in the training set are sampled
i.i.d. we get that
Dm ({S|x : LS (h) = 0}) = Dm ({S|x : âˆ€i, h(xi ) = f (xi )})
m
Y
=
D({xi : h(xi ) = f (xi )}).

(2.8)

i=1

For each individual sampling of an element of the training set we have
D({xi : h(xi ) = yi }) = 1 âˆ’ L(D,f ) (h) â‰¤ 1 âˆ’ ,
where the last inequality follows from the fact that h âˆˆ HB . Combining the
previous equation with Equation (2.8) and using the inequality 1 âˆ’  â‰¤ eâˆ’ we
obtain that for every h âˆˆ HB ,
Dm ({S|x : LS (h) = 0}) â‰¤ (1 âˆ’ )m â‰¤ eâˆ’m .

(2.9)

Combining this equation with Equation (2.7) we conclude that
Dm ({S|x : L(D,f ) (hS ) > }) â‰¤ |HB | eâˆ’m â‰¤ |H| eâˆ’ m .
A graphical illustration which explains how we used the union bound is given in
Figure 2.1.

Figure 2.1 Each point in the large circle represents a possible m-tuple of instances.
Each colored oval represents the set of â€œmisleadingâ€ m-tuple of instances for some
â€œbadâ€ predictor h âˆˆ HB . The ERM can potentially overfit whenever it gets a
misleading training set S. That is, for some h âˆˆ HB we have LS (h) = 0.
Equation (2.9) guarantees that for each individual bad hypothesis, h âˆˆ HB , at most
(1 âˆ’ )m -fraction of the training sets would be misleading. In particular, the larger m
is, the smaller each of these colored ovals becomes. The union bound formalizes the
fact that the area representing the training sets that are misleading with respect to
some h âˆˆ HB (that is, the training sets in M ) is at most the sum of the areas of the
colored ovals. Therefore, it is bounded by |HB | times the maximum size of a colored
oval. Any sample S outside the colored ovals cannot cause the ERM rule to overfit.

corollary 2.3

Let H be a finite hypothesis class. Let Î´ âˆˆ (0, 1) and  > 0

2.4 Exercises

41

and let m be an integer that satisfies
log(|H|/Î´)
.

Then, for any labeling function, f , and for any distribution, D, for which the
realizability assumption holds (that is, for some h âˆˆ H, L(D,f ) (h) = 0), with
probability of at least 1 âˆ’ Î´ over the choice of an i.i.d. sample S of size m, we
have that for every ERM hypothesis, hS , it holds that
mâ‰¥

L(D,f ) (hS ) â‰¤ .
The preceeding corollary tells us that for a sufficiently large m, the ERMH rule
over a finite hypothesis class will be probably (with confidence 1âˆ’Î´) approximately
(up to an error of ) correct. In the next chapter we formally define the model
of Probably Approximately Correct (PAC) learning.

2.4

Exercises
1. Overfitting of polynomial matching: We have shown that the predictor
defined in Equation (2.3) leads to overfitting. While this predictor seems to
be very unnatural, the goal of this exercise is to show that it can be described
as a thresholded polynomial. That is, show that given a training set S =
d
m
{(xi , f (xi ))}m
i=1 âŠ† (R Ã— {0, 1}) , there exists a polynomial pS such that
hS (x) = 1 if and only if pS (x) â‰¥ 0, where hS is as defined in Equation (2.3).
It follows that learning the class of all thresholded polynomials using the ERM
rule may lead to overfitting.
2. Let H be a class of binary classifiers over a domain X . Let D be an unknown
distribution over X , and let f be the target hypothesis in H. Fix some h âˆˆ H.
Show that the expected value of LS (h) over the choice of S|x equals L(D,f ) (h),
namely,
E

S|x âˆ¼D m

[LS (h)] = L(D,f ) (h).

3. Axis aligned rectangles: An axis aligned rectangle classifier in the plane
is a classifier that assigns the value 1 to a point if and only if it is inside a
certain rectangle. Formally, given real numbers a1 â‰¤ b1 , a2 â‰¤ b2 , define the
classifier h(a1 ,b1 ,a2 ,b2 ) by
(
1 if a1 â‰¤ x1 â‰¤ b1 and a2 â‰¤ x2 â‰¤ b2
h(a1 ,b1 ,a2 ,b2 ) (x1 , x2 ) =
.
(2.10)
0 otherwise
The class of all axis aligned rectangles in the plane is defined as
2
Hrec
= {h(a1 ,b1 ,a2 ,b2 ) : a1 â‰¤ b1 , and a2 â‰¤ b2 }.

Note that this is an infinite size hypothesis class. Throughout this exercise we
rely on the realizability assumption.

42

A Gentle Start

1. Let A be the algorithm that returns the smallest rectangle enclosing all
positive examples in the training set. Show that A is an ERM.
2. Show that if A receives a training set of size â‰¥ 4 log(4/Î´)
then, with proba
bility of at least 1 âˆ’ Î´ it returns a hypothesis with error of at most .
Hint: Fix some distribution D over X , let Râˆ— = R(aâˆ—1 , bâˆ—1 , aâˆ—2 , bâˆ—2 ) be the rectangle that generates the labels, and let f be the corresponding hypothesis.
Let a1 â‰¥ aâˆ—1 be a number such that the probability mass (with respect
to D) of the rectangle R1 = R(aâˆ—1 , a1 , aâˆ—2 , bâˆ—2 ) is exactly /4. Similarly, let
b1 , a2 , b2 be numbers such that the probability masses of the rectangles
R2 = R(b1 , bâˆ—1 , aâˆ—2 , bâˆ—2 ), R3 = R(aâˆ—1 , bâˆ—1 , aâˆ—2 , a2 ), R4 = R(aâˆ—1 , bâˆ—1 , b2 , bâˆ—2 ) are all
exactly /4. Let R(S) be the rectangle returned by A. See illustration in
Figure 2.2.

Râˆ—

-

+
R(S)

+

-

+
+

+
R1
Figure 2.2 Axis aligned rectangles.

â€¢ Show that R(S) âŠ† Râˆ— .
â€¢ Show that if S contains (positive) examples in all of the rectangles
R1 , R2 , R3 , R4 , then the hypothesis returned by A has error of at
most .
â€¢ For each i âˆˆ {1, . . . , 4}, upper bound the probability that S does not
contain an example from Ri .
â€¢ Use the union bound to conclude the argument.
3. Repeat the previous question for the class of axis aligned rectangles in Rd .
4. Show that the runtime of applying the algorithm A mentioned earlier is
polynomial in d, 1/, and in log(1/Î´).

3

A Formal Learning Model

In this chapter we define our main formal learning model â€“ the PAC learning
model and its extensions. We will consider other notions of learnability in Chapter 7.

3.1

PAC Learning
In the previous chapter we have shown that for a finite hypothesis class, if the
ERM rule with respect to that class is applied on a sufficiently large training
sample (whose size is independent of the underlying distribution or labeling
function) then the output hypothesis will be probably approximately correct.
More generally, we now define Probably Approximately Correct (PAC) learning.
definition 3.1 (PAC Learnability) A hypothesis class H is PAC learnable
if there exist a function mH : (0, 1)2 â†’ N and a learning algorithm with the
following property: For every , Î´ âˆˆ (0, 1), for every distribution D over X , and
for every labeling function f : X â†’ {0, 1}, if the realizable assumption holds
with respect to H, D, f , then when running the learning algorithm on m â‰¥
mH (, Î´) i.i.d. examples generated by D and labeled by f , the algorithm returns
a hypothesis h such that, with probability of at least 1 âˆ’ Î´ (over the choice of
the examples), L(D,f ) (h) â‰¤ .
The definition of Probably Approximately Correct learnability contains two
approximation parameters. The accuracy parameter  determines how far the
output classifier can be from the optimal one (this corresponds to the â€œapproximately correctâ€), and a confidence parameter Î´ indicating how likely the classifier is to meet that accuracy requirement (corresponds to the â€œprobablyâ€ part
of â€œPACâ€). Under the data access model that we are investigating, these approximations are inevitable. Since the training set is randomly generated, there
may always be a small chance that it will happen to be noninformative (for example, there is always some chance that the training set will contain only one
domain point, sampled over and over again). Furthermore, even when we are
lucky enough to get a training sample that does faithfully represent D, because
it is just a finite sample, there may always be some fine details of D that it fails
c 2014 by Shai Shalev-Shwartz and Shai Ben-David
Understanding Machine Learning, 
Published 2014 by Cambridge University Press.
Personal use only. Not for distribution. Do not post.
Please link to http://www.cs.huji.ac.il/~shais/UnderstandingMachineLearning

44

A Formal Learning Model

to reflect. Our accuracy parameter, , allows â€œforgivingâ€ the learnerâ€™s classifier
for making minor errors.

Sample Complexity
The function mH : (0, 1)2 â†’ N determines the sample complexity of learning H:
that is, how many examples are required to guarantee a probably approximately
correct solution. The sample complexity is a function of the accuracy () and
confidence (Î´) parameters. It also depends on properties of the hypothesis class
H â€“ for example, for a finite class we showed that the sample complexity depends
on log the size of H.
Note that if H is PAC learnable, there are many functions mH that satisfy the
requirements given in the definition of PAC learnability. Therefore, to be precise,
we will define the sample complexity of learning H to be the â€œminimal function,â€
in the sense that for any , Î´, mH (, Î´) is the minimal integer that satisfies the
requirements of PAC learning with accuracy  and confidence Î´.
Let us now recall the conclusion of the analysis of finite hypothesis classes
from the previous chapter. It can be rephrased as stating:
corollary 3.2
complexity

Every finite hypothesis class is PAC learnable with sample

mH (, Î´) â‰¤


log(|H|/Î´)
.


There are infinite classes that are learnable as well (see, for example, Exercise 3). Later on we will show that what determines the PAC learnability of
a class is not its finiteness but rather a combinatorial measure called the VC
dimension.

3.2

A More General Learning Model
The model we have just described can be readily generalized, so that it can be
made relevant to a wider scope of learning tasks. We consider generalizations in
two aspects:

Removing the Realizability Assumption
We have required that the learning algorithm succeeds on a pair of data distribution D and labeling function f provided that the realizability assumption is
met. For practical learning tasks, this assumption may be too strong (can we
really guarantee that there is a rectangle in the color-hardness space that fully
determines which papayas are tasty?). In the next subsection, we will describe
the agnostic PAC model in which this realizability assumption is waived.

3.2 A More General Learning Model

45

Learning Problems beyond Binary Classification
The learning task that we have been discussing so far has to do with predicting a
binary label to a given example (like being tasty or not). However, many learning
tasks take a different form. For example, one may wish to predict a real valued
number (say, the temperature at 9:00 p.m. tomorrow) or a label picked from
a finite set of labels (like the topic of the main story in tomorrowâ€™s paper). It
turns out that our analysis of learning can be readily extended to such and many
other scenarios by allowing a variety of loss functions. We shall discuss that in
Section 3.2.2 later.

3.2.1

Releasing the Realizability Assumption â€“ Agnostic PAC Learning
A More Realistic Model for the Data-Generating Distribution
Recall that the realizability assumption requires that there exists h? âˆˆ H such
that Pxâˆ¼D [h? (x) = f (x)] = 1. In many practical problems this assumption does
not hold. Furthermore, it is maybe more realistic not to assume that the labels
are fully determined by the features we measure on input elements (in the case of
the papayas, it is plausible that two papayas of the same color and softness will
have different taste). In the following, we relax the realizability assumption by
replacing the â€œtarget labeling functionâ€ with a more flexible notion, a data-labels
generating distribution.
Formally, from now on, let D be a probability distribution over X Ã— Y, where,
as before, X is our domain set and Y is a set of labels (usually we will consider
Y = {0, 1}). That is, D is a joint distribution over domain points and labels. One
can view such a distribution as being composed of two parts: a distribution Dx
over unlabeled domain points (sometimes called the marginal distribution) and
a conditional probability over labels for each domain point, D((x, y)|x). In the
papaya example, Dx determines the probability of encountering a papaya whose
color and hardness fall in some color-hardness values domain, and the conditional
probability is the probability that a papaya with color and hardness represented
by x is tasty. Indeed, such modeling allows for two papayas that share the same
color and hardness to belong to different taste categories.

The empirical and the True Error Revised
For a probability distribution, D, over X Ã— Y, one can measure how likely h is
to make an error when labeled points are randomly drawn according to D. We
redefine the true error (or risk) of a prediction rule h to be
def

LD (h) =

P

def

[h(x) 6= y] = D({(x, y) : h(x) 6= y}).

(3.1)

(x,y)âˆ¼D

We would like to find a predictor, h, for which that error will be minimized.
However, the learner does not know the data generating D. What the learner
does have access to is the training data, S. The definition of the empirical risk

46

A Formal Learning Model

remains the same as before, namely,
def

LS (h) =

|{i âˆˆ [m] : h(xi ) 6= yi }|
.
m

Given S, a learner can compute LS (h) for any function h : X â†’ {0, 1}. Note
that LS (h) = LD(uniform over S) (h).

The Goal
We wish to find some hypothesis, h : X â†’ Y, that (probably approximately)
minimizes the true risk, LD (h).

The Bayes Optimal Predictor.
Given any probability distribution D over X Ã— {0, 1}, the best label predicting
function from X to {0, 1} will be
(
1 if P[y = 1|x] â‰¥ 1/2
fD (x) =
0 otherwise
It is easy to verify (see Exercise 7) that for every probability distribution D,
the Bayes optimal predictor fD is optimal, in the sense that no other classifier,
g : X â†’ {0, 1} has a lower error. That is, for every classifier g, LD (fD ) â‰¤ LD (g).
Unfortunately, since we do not know D, we cannot utilize this optimal predictor
fD . What the learner does have access to is the training sample. We can now
present the formal definition of agnostic PAC learnability, which is a natural
extension of the definition of PAC learnability to the more realistic, nonrealizable,
learning setup we have just discussed.
Clearly, we cannot hope that the learning algorithm will find a hypothesis
whose error is smaller than the minimal possible error, that of the Bayes predictor.
Furthermore, as we shall prove later, once we make no prior assumptions
about the data-generating distribution, no algorithm can be guaranteed to find
a predictor that is as good as the Bayes optimal one. Instead, we require that
the learning algorithm will find a predictor whose error is not much larger than
the best possible error of a predictor in some given benchmark hypothesis class.
Of course, the strength of such a requirement depends on the choice of that
hypothesis class.
definition 3.3 (Agnostic PAC Learnability) A hypothesis class H is agnostic
PAC learnable if there exist a function mH : (0, 1)2 â†’ N and a learning algorithm
with the following property: For every , Î´ âˆˆ (0, 1) and for every distribution D
over X Ã—Y, when running the learning algorithm on m â‰¥ mH (, Î´) i.i.d. examples
generated by D, the algorithm returns a hypothesis h such that, with probability
of at least 1 âˆ’ Î´ (over the choice of the m training examples),
LD (h) â‰¤ min
LD (h0 ) + .
0
h âˆˆH

3.2 A More General Learning Model

47

Clearly, if the realizability assumption holds, agnostic PAC learning provides
the same guarantee as PAC learning. In that sense, agnostic PAC learning generalizes the definition of PAC learning. When the realizability assumption does not
hold, no learner can guarantee an arbitrarily small error. Nevertheless, under the
definition of agnostic PAC learning, a learner can still declare success if its error
is not much larger than the best error achievable by a predictor from the class H.
This is in contrast to PAC learning, in which the learner is required to achieve
a small error in absolute terms and not relative to the best error achievable by
the hypothesis class.

3.2.2

The Scope of Learning Problems Modeled
We next extend our model so that it can be applied to a wide variety of learning
tasks. Let us consider some examples of different learning tasks.
â€¢

Multiclass Classification Our classification does not have to be binary.
Take, for example, the task of document classification: We wish to design a
program that will be able to classify given documents according to topics
(e.g., news, sports, biology, medicine). A learning algorithm for such a task
will have access to examples of correctly classified documents and, on the
basis of these examples, should output a program that can take as input a
new document and output a topic classification for that document. Here,
the domain set is the set of all potential documents. Once again, we would
usually represent documents by a set of features that could include counts
of different key words in the document, as well as other possibly relevant
features like the size of the document or its origin. The label set in this task
will be the set of possible document topics (so Y will be some large finite
set). Once we determine our domain and label sets, the other components
of our framework look exactly the same as in the papaya tasting example;
Our training sample will be a finite sequence of (feature vector, label) pairs,
the learnerâ€™s output will be a function from the domain set to the label set,
and, finally, for our measure of success, we can use the probability, over
(document, topic) pairs, of the event that our predictor suggests a wrong
label.
â€¢ Regression In this task, one wishes to find some simple pattern in the data â€“
a functional relationship between the X and Y components of the data. For
example, one wishes to find a linear function that best predicts a babyâ€™s
birth weight on the basis of ultrasound measures of his head circumference,
abdominal circumference, and femur length. Here, our domain set X is some
subset of R3 (the three ultrasound measurements), and the set of â€œlabels,â€
Y, is the the set of real numbers (the weight in grams). In this context,
it is more adequate to call Y the target set. Our training data as well as
the learnerâ€™s output are as before (a finite sequence of (x, y) pairs, and
a function from X to Y respectively). However, our measure of success is

48

A Formal Learning Model

different. We may evaluate the quality of a hypothesis function, h : X â†’ Y,
by the expected square difference between the true labels and their predicted
values, namely,
def

LD (h) =

E

(h(x) âˆ’ y)2 .

(3.2)

(x,y)âˆ¼D

To accommodate a wide range of learning tasks we generalize our formalism
of the measure of success as follows:

Generalized Loss Functions
Given any set H (that plays the role of our hypotheses, or models) and some
domain Z let ` be any function from HÃ—Z to the set of nonnegative real numbers,
` : H Ã— Z â†’ R+ .
We call such functions loss functions.
Note that for prediction problems, we have that Z = X Ã— Y. However, our
notion of the loss function is generalized beyond prediction tasks, and therefore
it allows Z to be any domain of examples (for instance, in unsupervised learning
tasks such as the one described in Chapter 22, Z is not a product of an instance
domain and a label domain).
We now define the risk function to be the expected loss of a classifier, h âˆˆ H,
with respect to a probability distribution D over Z, namely,
def

LD (h) =

E [`(h, z)].

zâˆ¼D

(3.3)

That is, we consider the expectation of the loss of h over objects z picked randomly according to D. Similarly, we define the empirical risk to be the expected
loss over a given sample S = (z1 , . . . , zm ) âˆˆ Z m , namely,
m

def

LS (h) =

1 X
`(h, zi ).
m i=1

(3.4)

The loss functions used in the preceding examples of classification and regression tasks are as follows:
â€¢ 0â€“1 loss: Here, our random variable z ranges over the set of pairs X Ã— Y and
the loss function is
(
0 if h(x) = y
def
`0âˆ’1 (h, (x, y)) =
1 if h(x) 6= y
This loss function is used in binary or multiclass classification problems.
One should note that, for a random variable, Î±, taking the values {0, 1},
EÎ±âˆ¼D [Î±] = PÎ±âˆ¼D [Î± = 1]. Consequently, for this loss function, the definitions of LD (h) given in Equation (3.3) and Equation (3.1) coincide.
â€¢ Square Loss: Here, our random variable z ranges over the set of pairs X Ã— Y
and the loss function is
def

`sq (h, (x, y)) = (h(x) âˆ’ y)2 .

3.3 Summary

49

This loss function is used in regression problems.
We will later see more examples of useful instantiations of loss functions.

To summarize, we formally define agnostic PAC learnability for general loss
functions.
definition 3.4 (Agnostic PAC Learnability for General Loss Functions) A
hypothesis class H is agnostic PAC learnable with respect to a set Z and a
loss function ` : H Ã— Z â†’ R+ , if there exist a function mH : (0, 1)2 â†’ N
and a learning algorithm with the following property: For every , Î´ âˆˆ (0, 1)
and for every distribution D over Z, when running the learning algorithm on
m â‰¥ mH (, Î´) i.i.d. examples generated by D, the algorithm returns h âˆˆ H
such that, with probability of at least 1 âˆ’ Î´ (over the choice of the m training
examples),
LD (h) â‰¤ min
LD (h0 ) + ,
0
h âˆˆH

where LD (h) = Ezâˆ¼D [`(h, z)].
Remark 3.1 (A Note About Measurability*) In the aforementioned definition,
for every h âˆˆ H, we view the function `(h, Â·) : Z â†’ R+ as a random variable and
define LD (h) to be the expected value of this random variable. For that, we need
to require that the function `(h, Â·) is measurable. Formally, we assume that there
is a Ïƒ-algebra of subsets of Z, over which the probability D is defined, and that
the preimage of every initial segment in R+ is in this Ïƒ-algebra. In the specific
case of binary classification with the 0âˆ’1 loss, the Ïƒ-algebra is over X Ã— {0, 1}
and our assumption on ` is equivalent to the assumption that for every h, the
set {(x, h(x)) : x âˆˆ X } is in the Ïƒ-algebra.
Remark 3.2 (Proper versus Representation-Independent Learning*) In the preceding definition, we required that the algorithm will return a hypothesis from
H. In some situations, H is a subset of a set H0 , and the loss function can be
naturally extended to be a function from H0 Ã— Z to the reals. In this case, we
may allow the algorithm to return a hypothesis h0 âˆˆ H0 , as long as it satisfies
the requirement LD (h0 ) â‰¤ minhâˆˆH LD (h) + . Allowing the algorithm to output
a hypothesis from H0 is called representation independent learning, while proper
learning occurs when the algorithm must output a hypothesis from H. Representation independent learning is sometimes called â€œimproper learning,â€ although
there is nothing improper in representation independent learning.

3.3

Summary
In this chapter we defined our main formal learning model â€“ PAC learning. The
basic model relies on the realizability assumption, while the agnostic variant does

50

A Formal Learning Model

not impose any restrictions on the underlying distribution over the examples. We
also generalized the PAC model to arbitrary loss functions. We will sometimes
refer to the most general model simply as PAC learning, omitting the â€œagnosticâ€
prefix and letting the reader infer what the underlying loss function is from the
context. When we would like to emphasize that we are dealing with the original
PAC setting we mention that the realizability assumption holds. In Chapter 7
we will discuss other notions of learnability.

3.4

Bibliographic Remarks
Our most general definition of agnostic PAC learning with general loss functions follows the works of Vladimir Vapnik and Alexey Chervonenkis (Vapnik &
Chervonenkis 1971). In particular, we follow Vapnikâ€™s general setting of learning
(Vapnik 1982, Vapnik 1992, Vapnik 1995, Vapnik 1998).
PAC learning was introduced by Valiant (1984). Valiant was named the winner
of the 2010 Turing Award for the introduction of the PAC model. Valiantâ€™s
definition requires that the sample complexity will be polynomial in 1/ and
in 1/Î´, as well as in the representation size of hypotheses in the class (see also
Kearns & Vazirani (1994)). As we will see in Chapter 6, if a problem is at all PAC
learnable then the sample complexity depends polynomially on 1/ and log(1/Î´).
Valiantâ€™s definition also requires that the runtime of the learning algorithm will
be polynomial in these quantities. In contrast, we chose to distinguish between
the statistical aspect of learning and the computational aspect of learning. We
will elaborate on the computational aspect later on in Chapter 8, where we
introduce the full PAC learning model of Valiant. For expository reasons, we
use the term PAC learning even when we ignore the runtime aspect of learning.
Finally, the formalization of agnostic PAC learning is due to Haussler (1992).

3.5

Exercises
1. Monotonicity of Sample Complexity: Let H be a hypothesis class for a
binary classification task. Suppose that H is PAC learnable and its sample
complexity is given by mH (Â·, Â·). Show that mH is monotonically nonincreasing
in each of its parameters. That is, show that given Î´ âˆˆ (0, 1), and given 0 <
1 â‰¤ 2 < 1, we have that mH (1 , Î´) â‰¥ mH (2 , Î´). Similarly, show that given
 âˆˆ (0, 1), and given 0 < Î´1 â‰¤ Î´2 < 1, we have that mH (, Î´1 ) â‰¥ mH (, Î´2 ).
2. Let X be a discrete domain, and let HSingleton = {hz : z âˆˆ X } âˆª {hâˆ’ }, where
for each z âˆˆ X , hz is the function defined by hz (x) = 1 if x = z and hz (x) = 0
if x 6= z. hâˆ’ is simply the all-negative hypothesis, namely, âˆ€x âˆˆ X, hâˆ’ (x) = 0.
The realizability assumption here implies that the true hypothesis f labels
negatively all examples in the domain, perhaps except one.

3.5 Exercises

51

1. Describe an algorithm that implements the ERM rule for learning HSingleton
in the realizable setup.
2. Show that HSingleton is PAC learnable. Provide an upper bound on the
sample complexity.
3. Let X = R2 , Y = {0, 1}, and let H be the class of concentric circles in the
plane, that is, H = {hr : r âˆˆ R+ }, where hr (x) = 1[kxkâ‰¤r] . Prove that H is
PAC learnable (assume realizability), and its sample complexity is bounded
by



log(1/Î´)
mH (, Î´) â‰¤
.

4. In this question, we study the hypothesis class of Boolean conjunctions defined
as follows. The instance space is X = {0, 1}d and the label set is Y = {0, 1}. A
literal over the variables x1 , . . . , xd is a simple Boolean function that takes the
form f (x) = xi , for some i âˆˆ [d], or f (x) = 1 âˆ’ xi for some i âˆˆ [d]. We use the
notation xÌ„i as a shorthand for 1 âˆ’ xi . A conjunction is any product of literals.
In Boolean logic, the product is denoted using the âˆ§ sign. For example, the
function h(x) = x1 Â· (1 âˆ’ x2 ) is written as x1 âˆ§ xÌ„2 .
We consider the hypothesis class of all conjunctions of literals over the d
variables. The empty conjunction is interpreted as the all-positive hypothesis
(namely, the function that returns h(x) = 1 for all x). The conjunction x1 âˆ§ xÌ„1
(and similarly any conjunction involving a literal and its negation) is allowed
and interpreted as the all-negative hypothesis (namely, the conjunction that
returns h(x) = 0 for all x). We assume realizability: Namely, we assume
that there exists a Boolean conjunction that generates the labels. Thus, each
example (x, y) âˆˆ X Ã— Y consists of an assignment to the d Boolean variables
x1 , . . . , xd , and its truth value (0 for false and 1 for true).
For instance, let d = 3 and suppose that the true conjunction is x1 âˆ§ xÌ„2 .
Then, the training set S might contain the following instances:
((1, 1, 1), 0), ((1, 0, 1), 1), ((0, 1, 0), 0)((1, 0, 0), 1).
Prove that the hypothesis class of all conjunctions over d variables is
PAC learnable and bound its sample complexity. Propose an algorithm that
implements the ERM rule, whose runtime is polynomial in d Â· m.
5. Let X be a domain and let D1 , D2 , . . . , Dm be a sequence of distributions
over X . Let H be a finite class of binary classifiers over X and let f âˆˆ H.
Suppose we are getting a sample S of m examples, such that the instances are
independent but are not identically distributed; the ith instance is sampled
from Di and then yi is set to be f (xi ). Let DÌ„m denote the average, that is,
DÌ„m = (D1 + Â· Â· Â· + Dm )/m.
Fix an accuracy parameter  âˆˆ (0, 1). Show that


P âˆƒh âˆˆ H s.t. L(DÌ„m ,f ) (h) >  and L(S,f ) (h) = 0 â‰¤ |H|eâˆ’m .

52

A Formal Learning Model

Hint: Use the geometric-arithmetic mean inequality.
6. Let H be a hypothesis class of binary classifiers. Show that if H is agnostic
PAC learnable, then H is PAC learnable as well. Furthermore, if A is a successful agnostic PAC learner for H, then A is also a successful PAC learner
for H.
7. (*) The Bayes optimal predictor: Show that for every probability distribution D, the Bayes optimal predictor fD is optimal, in the sense that for
every classifier g from X to {0, 1}, LD (fD ) â‰¤ LD (g).
8. (*) We say that a learning algorithm A is better than B with respect to some
probability distribution, D, if
LD (A(S)) â‰¤ LD (B(S))
for all samples S âˆˆ (X Ã—{0, 1})m . We say that a learning algorithm A is better
than B, if it is better than B with respect to all probability distributions D
over X Ã— {0, 1}.
1. A probabilistic label predictor is a function that assigns to every domain
point x a probability value, h(x) âˆˆ [0, 1], that determines the probability of
predicting the label 1. That is, given such an h and an input, x, the label for
x is predicted by tossing a coin with bias h(x) toward Heads and predicting
1 iff the coin comes up Heads. Formally, we define a probabilistic label
predictor as a function, h : X â†’ [0, 1]. The loss of such h on an example
(x, y) is defined to be |h(x) âˆ’ y|, which is exactly the probability that the
prediction of h will not be equal to y. Note that if h is deterministic, that
is, returns values in {0, 1}, then |h(x) âˆ’ y| = 1[h(x)6=y] .
Prove that for every data-generating distribution D over X Ã— {0, 1}, the
Bayes optimal predictor has the smallest risk (w.r.t. the loss function
`(h, (x, y)) = |h(x)âˆ’y|, among all possible label predictors, including probabilistic ones).
2. Let X be a domain and {0, 1} be a set of labels. Prove that for every
distribution D over X Ã— {0, 1}, there exist a learning algorithm AD that is
better than any other learning algorithm with respect to D.
3. Prove that for every learning algorithm A there exist a probability distribution, D, and a learning algorithm B such that A is not better than B
w.r.t. D.
9. Consider a variant of the PAC model in which there are two example oracles: one that generates positive examples and one that generates negative
examples, both according to the underlying distribution D on X . Formally,
given a target function f : X â†’ {0, 1}, let D+ be the distribution over
X + = {x âˆˆ X : f (x) = 1} defined by D+ (A) = D(A)/D(X + ), for every
A âŠ‚ X + . Similarly, Dâˆ’ is the distribution over X âˆ’ induced by D.
The definition of PAC learnability in the two-oracle model is the same as the
standard definition of PAC learnability except that here the learner has access
+
âˆ’
âˆ’
to m+
H (, Î´) i.i.d. examples from D and m (, Î´) i.i.d. examples from D . The
learnerâ€™s goal is to output h s.t. with probability at least 1 âˆ’ Î´ (over the choice

3.5 Exercises

53

of the two training sets, and possibly over the nondeterministic decisions made
by the learning algorithm), both L(D+ ,f ) (h) â‰¤  and L(Dâˆ’,f ) (h) â‰¤ .
1. (*) Show that if H is PAC learnable (in the standard one-oracle model),
then H is PAC learnable in the two-oracle model.
2. (**) Define h+ to be the always-plus hypothesis and hâˆ’ to be the alwaysminus hypothesis. Assume that h+ , hâˆ’ âˆˆ H. Show that if H is PAC learnable in the two-oracle model, then H is PAC learnable in the standard
one-oracle model.

4

Learning via Uniform Convergence

The first formal learning model that we have discussed was the PAC model.
In Chapter 2 we have shown that under the realizability assumption, any finite
hypothesis class is PAC learnable. In this chapter we will develop a general tool,
uniform convergence, and apply it to show that any finite class is learnable in
the agnostic PAC model with general loss functions, as long as the range loss
function is bounded.

4.1

Uniform Convergence Is Sufficient for Learnability
The idea behind the learning condition discussed in this chapter is very simple.
Recall that, given a hypothesis class, H, the ERM learning paradigm works
as follows: Upon receiving a training sample, S, the learner evaluates the risk
(or error) of each h in H on the given sample and outputs a member of H that
minimizes this empirical risk. The hope is that an h that minimizes the empirical
risk with respect to S is a risk minimizer (or has risk close to the minimum) with
respect to the true data probability distribution as well. For that, it suffices to
ensure that the empirical risks of all members of H are good approximations of
their true risk. Put another way, we need that uniformly over all hypotheses in
the hypothesis class, the empirical risk will be close to the true risk, as formalized
in the following.
definition 4.1 (-representative sample) A training set S is called -representative
(w.r.t. domain Z, hypothesis class H, loss function `, and distribution D) if
âˆ€h âˆˆ H, |LS (h) âˆ’ LD (h)| â‰¤ .
The next simple lemma states that whenever the sample is (/2)-representative,
the ERM learning rule is guaranteed to return a good hypothesis.
lemma 4.2 Assume that a training set S is 2 -representative (w.r.t. domain
Z, hypothesis class H, loss function `, and distribution D). Then, any output of
ERMH (S), namely, any hS âˆˆ argminhâˆˆH LS (h), satisfies
LD (hS ) â‰¤ min LD (h) + .
hâˆˆH

c 2014 by Shai Shalev-Shwartz and Shai Ben-David
Understanding Machine Learning, 
Published 2014 by Cambridge University Press.
Personal use only. Not for distribution. Do not post.
Please link to http://www.cs.huji.ac.il/~shais/UnderstandingMachineLearning

4.2 Finite Classes Are Agnostic PAC Learnable

Proof

55

For every h âˆˆ H,
LD (hS ) â‰¤ LS (hS ) +


2

â‰¤ LS (h) +


2

â‰¤ LD (h) +


2

+


2

= LD (h) + ,

where the first and third inequalities are due to the assumption that S is 2 representative (Definition 4.1) and the second inequality holds since hS is an
ERM predictor.
The preceding lemma implies that to ensure that the ERM rule is an agnostic
PAC learner, it suffices to show that with probability of at least 1 âˆ’ Î´ over the
random choice of a training set, it will be an -representative training set. The
uniform convergence condition formalizes this requirement.
definition 4.3 (Uniform Convergence) We say that a hypothesis class H has
the uniform convergence property (w.r.t. a domain Z and a loss function `) if
2
there exists a function mUC
H : (0, 1) â†’ N such that for every , Î´ âˆˆ (0, 1) and
for every probability distribution D over Z, if S is a sample of m â‰¥ mUC
H (, Î´)
examples drawn i.i.d. according to D, then, with probability of at least 1 âˆ’ Î´, S
is -representative.
Similar to the definition of sample complexity for PAC learning, the function
mH measures the (minimal) sample complexity of obtaining the uniform convergence property, namely, how many examples we need to ensure that with
probability of at least 1 âˆ’ Î´ the sample would be -representative.
The term uniform here refers to having a fixed sample size that works for all
members of H and over all possible probability distributions over the domain.
The following corollary follows directly from Lemma 4.2 and the definition of
uniform convergence.
UC

corollary 4.4 If a class H has the uniform convergence property with a
function mUC
H then the class is agnostically PAC learnable with the sample complexity mH (, Î´) â‰¤ mUC
H (/2, Î´). Furthermore, in that case, the ERMH paradigm
is a successful agnostic PAC learner for H.

4.2

Finite Classes Are Agnostic PAC Learnable
In view of Corollary 4.4, the claim that every finite hypothesis class is agnostic
PAC learnable will follow once we establish that uniform convergence holds for
a finite hypothesis class.
To show that uniform convergence holds we follow a two step argument, similar
to the derivation in Chapter 2. The first step applies the union bound while the
second step employs a measure concentration inequality. We now explain these
two steps in detail.
Fix some , Î´. We need to find a sample size m that guarantees that for any
D, with probability of at least 1 âˆ’ Î´ of the choice of S = (z1 , . . . , zm ) sampled

56

Learning via Uniform Convergence

i.i.d. from D we have that for all h âˆˆ H, |LS (h) âˆ’ LD (h)| â‰¤ . That is,
Dm ({S : âˆ€h âˆˆ H, |LS (h) âˆ’ LD (h)| â‰¤ }) â‰¥ 1 âˆ’ Î´.
Equivalently, we need to show that
Dm ({S : âˆƒh âˆˆ H, |LS (h) âˆ’ LD (h)| > }) < Î´.
Writing
{S : âˆƒh âˆˆ H, |LS (h) âˆ’ LD (h)| > } = âˆªhâˆˆH {S : |LS (h) âˆ’ LD (h)| > },
and applying the union bound (Lemma 2.2) we obtain
X
Dm ({S : âˆƒh âˆˆ H, |LS (h) âˆ’ LD (h)| > }) â‰¤
Dm ({S : |LS (h) âˆ’ LD (h)| > }).
hâˆˆH

(4.1)
Our second step will be to argue that each summand of the right-hand side
of this inequality is small enough (for a sufficiently large m). That is, we will
show that for any fixed hypothesis, h, (which is chosen in advance prior to the
sampling of the training set), the gap between the true and empirical risks,
|LS (h) âˆ’ LD (h)|, is likely to be small.
Pm
1
Recall that LD (h) = Ezâˆ¼D [`(h, z)] and that LS (h) = m
i=1 `(h, zi ). Since
each zi is sampled i.i.d. from D, the expected value of the random variable
`(h, zi ) is LD (h). By the linearity of expectation, it follows that LD (h) is also
the expected value of LS (h). Hence, the quantity |LD (h)âˆ’LS (h)| is the deviation
of the random variable LS (h) from its expectation. We therefore need to show
that the measure of LS (h) is concentrated around its expected value.
A basic statistical fact, the law of large numbers, states that when m goes to
infinity, empirical averages converge to their true expectation. This is true for
LS (h), since it is the empirical average of m i.i.d random variables. However, since
the law of large numbers is only an asymptotic result, it provides no information
about the gap between the empirically estimated error and its true value for any
given, finite, sample size.
Instead, we will use a measure concentration inequality due to Hoeffding, which
quantifies the gap between empirical averages and their expected value.
lemma 4.5 (Hoeffdingâ€™s Inequality) Let Î¸1 , . . . , Î¸m be a sequence of i.i.d. random variables and assume that for all i, E[Î¸i ] = Âµ and P[a â‰¤ Î¸i â‰¤ b] = 1. Then,
for any  > 0

#
" m

 X


1
Î¸i âˆ’ Âµ >  â‰¤ 2 exp âˆ’2 m 2 /(b âˆ’ a)2 .
P m


i=1

The proof can be found in Appendix B.
Getting back to our problem, let Î¸i be the random variable `(h, zi ). Since h
is fixed and z1 , . . . , zm are sampled i.i.d., it follows that Î¸1 , . . . , Î¸m are also i.i.d.
Pm
1
random variables. Furthermore, LS (h) = m
i=1 Î¸i and LD (h) = Âµ. Let us

4.2 Finite Classes Are Agnostic PAC Learnable

57

further assume that the range of ` is [0, 1] and therefore Î¸i âˆˆ [0, 1]. We therefore
obtain that

#
" m
 X




1
Dm ({S : |LS (h) âˆ’ LD (h)| > }) = P  m
Î¸i âˆ’ Âµ >  â‰¤ 2 exp âˆ’2 m 2 .


i=1
(4.2)
Combining this with Equation (4.1) yields
X

Dm ({S : âˆƒh âˆˆ H, |LS (h) âˆ’ LD (h)| > }) â‰¤
2 exp âˆ’2 m 2
hâˆˆH


= 2 |H| exp âˆ’2 m 2 .
Finally, if we choose
mâ‰¥

log(2|H|/Î´)
22

then
Dm ({S : âˆƒh âˆˆ H, |LS (h) âˆ’ LD (h)| > }) â‰¤ Î´.
corollary 4.6 Let H be a finite hypothesis class, let Z be a domain, and let
` : H Ã— Z â†’ [0, 1] be a loss function. Then, H enjoys the uniform convergence
property with sample complexity


log(2|H|/Î´)
UC
mH (, Î´) â‰¤
.
22
Furthermore, the class is agnostically PAC learnable using the ERM algorithm
with sample complexity


2 log(2|H|/Î´)
.
mH (, Î´) â‰¤ mUC
(/2,
Î´)
â‰¤
H
2
Remark 4.1 (The â€œDiscretization Trickâ€) While the preceding corollary only
applies to finite hypothesis classes, there is a simple trick that allows us to get
a very good estimate of the practical sample complexity of infinite hypothesis
classes. Consider a hypothesis class that is parameterized by d parameters. For
example, let X = R, Y = {Â±1}, and the hypothesis class, H, be all functions
of the form hÎ¸ (x) = sign(x âˆ’ Î¸). That is, each hypothesis is parameterized by
one parameter, Î¸ âˆˆ R, and the hypothesis outputs 1 for all instances larger than
Î¸ and outputs âˆ’1 for instances smaller than Î¸. This is a hypothesis class of an
infinite size. However, if we are going to learn this hypothesis class in practice,
using a computer, we will probably maintain real numbers using floating point
representation, say, of 64 bits. It follows that in practice, our hypothesis class
is parameterized by the set of scalars that can be represented using a 64 bits
floating point number. There are at most 264 such numbers; hence the actual
size of our hypothesis class is at most 264 . More generally, if our hypothesis class
is parameterized by d numbers, in practice we learn a hypothesis class of size at
most 264d . Applying Corollary 4.6 we obtain that the sample complexity of such

58

Learning via Uniform Convergence

classes is bounded by 128d+2log(2/Î´)
. This upper bound on the sample complex2
ity has the deficiency of being dependent on the specific representation of real
numbers used by our machine. In Chapter 6 we will introduce a rigorous way
to analyze the sample complexity of infinite size hypothesis classes. Nevertheless, the discretization trick can be used to get a rough estimate of the sample
complexity in many practical situations.

4.3

Summary
If the uniform convergence property holds for a hypothesis class H then in most
cases the empirical risks of hypotheses in H will faithfully represent their true
risks. Uniform convergence suffices for agnostic PAC learnability using the ERM
rule. We have shown that finite hypothesis classes enjoy the uniform convergence
property and are hence agnostic PAC learnable.

4.4

Bibliographic Remarks
Classes of functions for which the uniform convergence property holds are also
called Glivenko-Cantelli classes, named after Valery Ivanovich Glivenko and
Francesco Paolo Cantelli, who proved the first uniform convergence result in
the 1930s. See (Dudley, Gine & Zinn 1991). The relation between uniform convergence and learnability was thoroughly studied by Vapnik â€“ see (Vapnik 1992,
Vapnik 1995, Vapnik 1998). In fact, as we will see later in Chapter 6, the fundamental theorem of learning theory states that in binary classification problems,
uniform convergence is not only a sufficient condition for learnability but is also
a necessary condition. This is not the case for more general learning problems
(see (Shalev-Shwartz, Shamir, Srebro & Sridharan 2010)).

4.5

Exercises
1. In this exercise, we show that the (, Î´) requirement on the convergence of
errors in our definitions of PAC learning, is, in fact, quite close to a simpler looking requirement about averages (or expectations). Prove that the
following two statements are equivalent (for any learning algorithm A, any
probability distribution D, and any loss function whose range is [0, 1]):
1. For every , Î´ > 0, there exists m(, Î´) such that âˆ€m â‰¥ m(, Î´)
P

Sâˆ¼D m

[LD (A(S)) > ] < Î´

2.
lim

E

mâ†’âˆž Sâˆ¼D m

[LD (A(S))] = 0

4.5 Exercises

59

(where ESâˆ¼Dm denotes the expectation over samples S of size m).
2. Bounded loss functions: In Corollary 4.6 we assumed that the range of the
loss function is [0, 1]. Prove that if the range of the loss function is [a, b] then
the sample complexity satisfies


2 log(2|H|/Î´)(b âˆ’ a)2
UC
.
mH (, Î´) â‰¤ mH (/2, Î´) â‰¤
2

5

The Bias-Complexity Tradeoff

In Chapter 2 we saw that unless one is careful, the training data can mislead the
learner, and result in overfitting. To overcome this problem, we restricted the
search space to some hypothesis class H. Such a hypothesis class can be viewed
as reflecting some prior knowledge that the learner has about the task â€“ a belief
that one of the members of the class H is a low-error model for the task. For
example, in our papayas taste problem, on the basis of our previous experience
with other fruits, we may assume that some rectangle in the color-hardness plane
predicts (at least approximately) the papayaâ€™s tastiness.
Is such prior knowledge really necessary for the success of learning? Maybe
there exists some kind of universal learner, that is, a learner who has no prior
knowledge about a certain task and is ready to be challenged by any task? Let
us elaborate on this point. A specific learning task is defined by an unknown
distribution D over X Ã— Y, where the goal of the learner is to find a predictor
h : X â†’ Y, whose risk, LD (h), is small enough. The question is therefore whether
there exist a learning algorithm A and a training set size m, such that for every
distribution D, if A receives m i.i.d. examples from D, there is a high chance it
outputs a predictor h that has a low risk.
The first part of this chapter addresses this question formally. The No-FreeLunch theorem states that no such universal learner exists. To be more precise,
the theorem states that for binary classification prediction tasks, for every learner
there exists a distribution on which it fails. We say that the learner fails if, upon
receiving i.i.d. examples from that distribution, its output hypothesis is likely
to have a large risk, say, â‰¥ 0.3, whereas for the same distribution, there exists
another learner that will output a hypothesis with a small risk. In other words,
the theorem states that no learner can succeed on all learnable tasks â€“ every
learner has tasks on which it fails while other learners succeed.
Therefore, when approaching a particular learning problem, defined by some
distribution D, we should have some prior knowledge on D. One type of such prior
knowledge is that D comes from some specific parametric family of distributions.
We will study learning under such assumptions later on in Chapter 24. Another
type of prior knowledge on D, which we assumed when defining the PAC learning
model, is that there exists h in some predefined hypothesis class H, such that
LD (h) = 0. A softer type of prior knowledge on D is assuming that minhâˆˆH LD (h)
is small. In a sense, this weaker assumption on D is a prerequisite for using the
c 2014 by Shai Shalev-Shwartz and Shai Ben-David
Understanding Machine Learning, 
Published 2014 by Cambridge University Press.
Personal use only. Not for distribution. Do not post.
Please link to http://www.cs.huji.ac.il/~shais/UnderstandingMachineLearning

5.1 The No-Free-Lunch Theorem

61

agnostic PAC model, in which we require that the risk of the output hypothesis
will not be much larger than minhâˆˆH LD (h).
In the second part of this chapter we study the benefits and pitfalls of using
a hypothesis class as a means of formalizing prior knowledge. We decompose
the error of an ERM algorithm over a class H into two components. The first
component reflects the quality of our prior knowledge, measured by the minimal
risk of a hypothesis in our hypothesis class, minhâˆˆH LD (h). This component is
also called the approximation error, or the bias of the algorithm toward choosing
a hypothesis from H. The second component is the error due to overfitting,
which depends on the size or the complexity of the class H and is called the
estimation error. These two terms imply a tradeoff between choosing a more
complex H (which can decrease the bias but increases the risk of overfitting)
or a less complex H (which might increase the bias but decreases the potential
overfitting).

5.1

The No-Free-Lunch Theorem
In this part we prove that there is no universal learner. We do this by showing
that no learner can succeed on all learning tasks, as formalized in the following
theorem:
theorem 5.1 (No-Free-Lunch) Let A be any learning algorithm for the task
of binary classification with respect to the 0 âˆ’ 1 loss over a domain X . Let m
be any number smaller than |X |/2, representing a training set size. Then, there
exists a distribution D over X Ã— {0, 1} such that:
1. There exists a function f : X â†’ {0, 1} with LD (f ) = 0.
2. With probability of at least 1/7 over the choice of S âˆ¼ Dm we have that
LD (A(S)) â‰¥ 1/8.
This theorem states that for every learner, there exists a task on which it fails,
even though that task can be successfully learned by another learner. Indeed, a
trivial successful learner in this case would be an ERM learner with the hypothesis class H = {f }, or more generally, ERM with respect to any finite hypothesis
class that contains f and whose size satisfies the equation m â‰¥ 8 log(7|H|/6) (see
Corollary 2.3).
Proof Let C be a subset of X of size 2m. The intuition of the proof is that
any learning algorithm that observes only half of the instances in C has no
information on what should be the labels of the rest of the instances in C.
Therefore, there exists a â€œreality,â€ that is, some target function f , that would
contradict the labels that A(S) predicts on the unobserved instances in C.
Note that there are T = 22m possible functions from C to {0, 1}. Denote these
functions by f1 , . . . , fT . For each such function, let Di be a distribution over

62

The Bias-Complexity Tradeoff

C Ã— {0, 1} defined by
(
Di ({(x, y)}) =

1/|C| if y = fi (x)
0

otherwise.

That is, the probability to choose a pair (x, y) is 1/|C| if the label y is indeed
the true label according to fi , and the probability is 0 if y 6= fi (x). Clearly,
LDi (fi ) = 0.
We will show that for every algorithm, A, that receives a training set of m
examples from C Ã— {0, 1} and returns a function A(S) : C â†’ {0, 1}, it holds that
max

E [LDi (A(S))] â‰¥ 1/4.

iâˆˆ[T ] Sâˆ¼Dim

(5.1)

Clearly, this means that for every algorithm, A0 , that receives a training set of m
examples from X Ã—{0, 1} there exist a function f : X â†’ {0, 1} and a distribution
D over X Ã— {0, 1}, such that LD (f ) = 0 and
E [LD (A0 (S))] â‰¥ 1/4.

Sâˆ¼D m

(5.2)

It is easy to verify that the preceding suffices for showing that P[LD (A0 (S)) â‰¥
1/8] â‰¥ 1/7, which is what we need to prove (see Exercise 1).
We now turn to proving that Equation (5.1) holds. There are k = (2m)m
possible sequences of m examples from C. Denote these sequences by S1 , . . . , Sk .
Also, if Sj = (x1 , . . . , xm ) we denote by Sji the sequence containing the instances
in Sj labeled by the function fi , namely, Sji = ((x1 , fi (x1 )), . . . , (xm , fi (xm ))). If
the distribution is Di then the possible training sets A can receive are S1i , . . . , Ski ,
and all these training sets have the same probability of being sampled. Therefore,
E m [LDi (A(S))] =

Sâˆ¼Di

k
1 X
LDi (A(Sji )).
k j=1

(5.3)

Using the facts that â€œmaximumâ€ is larger than â€œaverageâ€ and that â€œaverageâ€ is
larger than â€œminimum,â€ we have
max
iâˆˆ[T ]

k
T
k
1 X
1X 1 X
LDi (A(Sji )) â‰¥
LDi (A(Sji ))
k j=1
T i=1 k j=1

=

k
T
1X 1X
LDi (A(Sji ))
k j=1 T i=1

â‰¥ min
jâˆˆ[k]

T
1X
LDi (A(Sji )).
T i=1

(5.4)

Next, fix some j âˆˆ [k]. Denote Sj = (x1 , . . . , xm ) and let v1 , . . . , vp be the
examples in C that do not appear in Sj . Clearly, p â‰¥ m. Therefore, for every

5.1 The No-Free-Lunch Theorem

63

function h : C â†’ {0, 1} and every i we have
LDi (h) =
â‰¥
â‰¥

1 X
1[h(x)6=fi (x)]
2m
1
2m
1
2p

xâˆˆC
p
X

1[h(vr )6=fi (vr )]

r=1
p
X

1[h(vr )6=fi (vr )] .

(5.5)

r=1

Hence,
p
T
T
1X
1X 1 X
i
LDi (A(Sji )) â‰¥
1
T i=1
T i=1 2p r=1 [A(Sj )(vr )6=fi (vr )]

=

p
T
1 X1X
i
1
2p r=1 T i=1 [A(Sj )(vr )6=fi (vr )]

â‰¥

T
1X
1
Â· min
1[A(Sji )(vr )6=fi (vr )] .
2
râˆˆ[p] T
i=1

(5.6)

Next, fix some r âˆˆ [p]. We can partition all the functions in f1 , . . . , fT into T /2
disjoint pairs, where for a pair (fi , fi0 ) we have that for every c âˆˆ C, fi (c) 6= fi0 (c)
0
if and only if c = vr . Since for such a pair we must have Sji = Sji , it follows that
1[A(Sji )(vr )6=fi (vr )] + 1[A(S i0 )(vr )6=f 0 (vr )] = 1,
j

i

which yields
T
1 X
1
1[A(Sji )(vr )6=fi (vr )] = .
T i=1
2

Combining this with Equation (5.6), Equation (5.4), and Equation (5.3), we
obtain that Equation (5.1) holds, which concludes our proof.

5.1.1

No-Free-Lunch and Prior Knowledge
How does the No-Free-Lunch result relate to the need for prior knowledge? Let us
consider an ERM predictor over the hypothesis class H of all the functions f from
X to {0, 1}. This class represents lack of prior knowledge: Every possible function
from the domain to the label set is considered a good candidate. According to the
No-Free-Lunch theorem, any algorithm that chooses its output from hypotheses
in H, and in particular the ERM predictor, will fail on some learning task.
Therefore, this class is not PAC learnable, as formalized in the following corollary:
corollary 5.2 Let X be an infinite domain set and let H be the set of all
functions from X to {0, 1}. Then, H is not PAC learnable.

64

The Bias-Complexity Tradeoff

Proof Assume, by way of contradiction, that the class is learnable. Choose
some  < 1/8 and Î´ < 1/7. By the definition of PAC learnability, there must
be some learning algorithm A and an integer m = m(, Î´), such that for any
data-generating distribution over X Ã— {0, 1}, if for some function f : X â†’ {0, 1},
LD (f ) = 0, then with probability greater than 1 âˆ’ Î´ when A is applied to
samples S of size m, generated i.i.d. by D, LD (A(S)) â‰¤ . However, applying
the No-Free-Lunch theorem, since |X | > 2m, for every learning algorithm (and
in particular for the algorithm A), there exists a distribution D such that with
probability greater than 1/7 > Î´, LD (A(S)) > 1/8 > , which leads to the
desired contradiction.
How can we prevent such failures? We can escape the hazards foreseen by the
No-Free-Lunch theorem by using our prior knowledge about a specific learning
task, to avoid the distributions that will cause us to fail when learning that task.
Such prior knowledge can be expressed by restricting our hypothesis class.
But how should we choose a good hypothesis class? On the one hand, we want
to believe that this class includes the hypothesis that has no error at all (in the
PAC setting), or at least that the smallest error achievable by a hypothesis from
this class is indeed rather small (in the agnostic setting). On the other hand,
we have just seen that we cannot simply choose the richest class â€“ the class of
all functions over the given domain. This tradeoff is discussed in the following
section.

5.2

Error Decomposition
To answer this question we decompose the error of an ERMH predictor into two
components as follows. Let hS be an ERMH hypothesis. Then, we can write
LD (hS ) = app + est where : app = min LD (h),
hâˆˆH

est = LD (hS ) âˆ’ app . (5.7)

â€¢ The Approximation Error â€“ the minimum risk achievable by a predictor
in the hypothesis class. This term measures how much risk we have because
we restrict ourselves to a specific class, namely, how much inductive bias we
have. The approximation error does not depend on the sample size and is
determined by the hypothesis class chosen. Enlarging the hypothesis class
can decrease the approximation error.
Under the realizability assumption, the approximation error is zero. In
the agnostic case, however, the approximation error can be large.1
1

In fact, it always includes the error of the Bayes optimal predictor (see Chapter 3), the
minimal yet inevitable error, because of the possible nondeterminism of the world in this
model. Sometimes in the literature the term approximation error refers not to
minhâˆˆH LD (h), but rather to the excess error over that of the Bayes optimal predictor,
namely, minhâˆˆH LD (h) âˆ’ Bayes .

5.3 Summary

65

â€¢ The Estimation Error â€“ the difference between the approximation error
and the error achieved by the ERM predictor. The estimation error results
because the empirical risk (i.e., training error) is only an estimate of the
true risk, and so the predictor minimizing the empirical risk is only an
estimate of the predictor minimizing the true risk.
The quality of this estimation depends on the training set size and
on the size, or complexity, of the hypothesis class. As we have shown, for
a finite hypothesis class, est increases (logarithmically) with |H| and decreases with m. We can think of the size of H as a measure of its complexity.
In future chapters we will define other complexity measures of hypothesis
classes.
Since our goal is to minimize the total risk, we face a tradeoff, called the biascomplexity tradeoff. On one hand, choosing H to be a very rich class decreases the
approximation error but at the same time might increase the estimation error,
as a rich H might lead to overfitting. On the other hand, choosing H to be a
very small set reduces the estimation error but might increase the approximation
error or, in other words, might lead to underfitting. Of course, a great choice for
H is the class that contains only one classifier â€“ the Bayes optimal classifier. But
the Bayes optimal classifier depends on the underlying distribution D, which we
do not know (indeed, learning would have been unnecessary had we known D).
Learning theory studies how rich we can make H while still maintaining reasonable estimation error. In many cases, empirical research focuses on designing
good hypothesis classes for a certain domain. Here, â€œgoodâ€ means classes for
which the approximation error would not be excessively high. The idea is that
although we are not experts and do not know how to construct the optimal classifier, we still have some prior knowledge of the specific problem at hand, which
enables us to design hypothesis classes for which both the approximation error
and the estimation error are not too large. Getting back to our papayas example,
we do not know how exactly the color and hardness of a papaya predict its taste,
but we do know that papaya is a fruit and on the basis of previous experience
with other fruit we conjecture that a rectangle in the color-hardness space may
be a good predictor.

5.3

Summary
The No-Free-Lunch theorem states that there is no universal learner. Every
learner has to be specified to some task, and use some prior knowledge about
that task, in order to succeed. So far we have modeled our prior knowledge by
restricting our output hypothesis to be a member of a chosen hypothesis class.
When choosing this hypothesis class, we face a tradeoff, between a larger, or
more complex, class that is more likely to have a small approximation error,
and a more restricted class that would guarantee that the estimation error will

66

The Bias-Complexity Tradeoff

be small. In the next chapter we will study in more detail the behavior of the
estimation error. In Chapter 7 we will discuss alternative ways to express prior
knowledge.

5.4

Bibliographic Remarks
(Wolpert & Macready 1997) proved several no-free-lunch theorems for optimization, but these are rather different from the theorem we prove here. The theorem
we prove here is closely related to lower bounds in VC theory, as we will study
in the next chapter.

5.5

Exercises
1. Prove that Equation (5.2) suffices for showing that P[LD (A(S)) â‰¥ 1/8] â‰¥ 1/7.
Hint: Let Î¸ be a random variable that receives values in [0, 1] and whose
expectation satisfies E[Î¸] â‰¥ 1/4. Use Lemma B.1 to show that P[Î¸ â‰¥ 1/8] â‰¥
1/7.
2. Assume you are asked to design a learning algorithm to predict whether patients are going to suffer a heart attack. Relevant patient features the algorithm may have access to include blood pressure (BP), body-mass index
(BMI), age (A), level of physical activity (P), and income (I).
You have to choose between two algorithms; the first picks an axis aligned
rectangle in the two dimensional space spanned by the features BP and BMI
and the other picks an axis aligned rectangle in the five dimensional space
spanned by all the preceding features.
1. Explain the pros and cons of each choice.
2. Explain how the number of available labeled training samples will affect
your choice.
3. Prove that if |X | â‰¥ km for a positive integer k â‰¥ 2, then we can replace
1
1
the lower bound of 1/4 in the No-Free-Lunch theorem with kâˆ’1
2k = 2 âˆ’ 2k .
Namely, let A be a learning algorithm for the task of binary classification. Let
m be any number smaller than |X |/k, representing a training set size. Then,
there exists a distribution D over X Ã— {0, 1} such that:
â€¢ There exists a function f : X â†’ {0, 1} with LD (f ) = 0.
1
.
â€¢ ESâˆ¼Dm [LD (A(S))] â‰¥ 21 âˆ’ 2k

6

The VC-Dimension

In the previous chapter, we decomposed the error of the ERMH rule into approximation error and estimation error. The approximation error depends on
the fit of our prior knowledge (as reflected by the choice of the hypothesis class
H) to the underlying unknown distribution. In contrast, the definition of PAC
learnability requires that the estimation error would be bounded uniformly over
all distributions.
Our current goal is to figure out which classes H are PAC learnable, and to
characterize exactly the sample complexity of learning a given hypothesis class.
So far we have seen that finite classes are learnable, but that the class of all
functions (over an infinite size domain) is not. What makes one class learnable
and the other unlearnable? Can infinite-size classes be learnable, and, if so, what
determines their sample complexity?
We begin the chapter by showing that infinite classes can indeed be learnable, and thus, finiteness of the hypothesis class is not a necessary condition for
learnability. We then present a remarkably crisp characterization of the family
of learnable classes in the setup of binary valued classification with the zero-one
loss. This characterization was first discovered by Vladimir Vapnik and Alexey
Chervonenkis in 1970 and relies on a combinatorial notion called the VapnikChervonenkis dimension (VC-dimension). We formally define the VC-dimension,
provide several examples, and then state the fundamental theorem of statistical
learning theory, which integrates the concepts of learnability, VC-dimension, the
ERM rule, and uniform convergence.

6.1

Infinite-Size Classes Can Be Learnable
In Chapter 4 we saw that finite classes are learnable, and in fact the sample
complexity of a hypothesis class is upper bounded by the log of its size. To show
that the size of the hypothesis class is not the right characterization of its sample
complexity, we first present a simple example of an infinite-size hypothesis class
that is learnable.
Example 6.1 Let H be the set of threshold functions over the real line, namely,
H = {ha : a âˆˆ R}, where ha : R â†’ {0, 1} is a function such that ha (x) = 1[x<a] .
To remind the reader, 1[x<a] is 1 if x < a and 0 otherwise. Clearly, H is of infinite
c 2014 by Shai Shalev-Shwartz and Shai Ben-David
Understanding Machine Learning, 
Published 2014 by Cambridge University Press.
Personal use only. Not for distribution. Do not post.
Please link to http://www.cs.huji.ac.il/~shais/UnderstandingMachineLearning

68

The VC-Dimension

size. Nevertheless, the following lemma shows that H is learnable in the PAC
model using the ERM algorithm.
Lemma 6.1 Let H be the class of thresholds as defined earlier. Then, H is
PAC learnable, using the ERM rule, with sample complexity of mH (, Î´) â‰¤
dlog(2/Î´)/e.
Proof Let a? be a threshold such that the hypothesis h? (x) = 1[x<a? ] achieves
LD (h? ) = 0. Let Dx be the marginal distribution over the domain X and let
a0 < a? < a1 be such that
P [x âˆˆ (a0 , a? )] =

xâˆ¼Dx

P [x âˆˆ (a? , a1 )] = .

xâˆ¼Dx

 mass

 mass

a0

a1

a?

(If Dx (âˆ’âˆž, a? ) â‰¤  we set a0 = âˆ’âˆž and similarly for a1 ). Given a training set
S, let b0 = max{x : (x, 1) âˆˆ S} and b1 = min{x : (x, 0) âˆˆ S} (if no example in S
is positive we set b0 = âˆ’âˆž and if no example in S is negative we set b1 = âˆž).
Let bS be a threshold corresponding to an ERM hypothesis, hS , which implies
that bS âˆˆ (b0 , b1 ). Therefore, a sufficient condition for LD (hS ) â‰¤  is that both
b0 â‰¥ a0 and b1 â‰¤ a1 . In other words,
P [LD (hS ) > ] â‰¤

Sâˆ¼D m

P [b0 < a0 âˆ¨ b1 > a1 ],

Sâˆ¼D m

and using the union bound we can bound the preceding by
P [LD (hS ) > ] â‰¤

Sâˆ¼D m

P [b0 < a0 ] +

Sâˆ¼D m

P [b1 > a1 ].

Sâˆ¼D m

(6.1)

The event b0 < a0 happens if and only if all examples in S are not in the interval
(a0 , aâˆ— ), whose probability mass is defined to be , namely,
P [b0 < a0 ] =

Sâˆ¼D m

P [âˆ€(x, y) âˆˆ S, x 6âˆˆ (a0 , a? )] = (1 âˆ’ )m â‰¤ eâˆ’ m .

Sâˆ¼D m

Since we assume m > log(2/Î´)/ it follows that the equation is at most Î´/2.
In the same way it is easy to see that PSâˆ¼Dm [b1 > a1 ] â‰¤ Î´/2. Combining with
Equation (6.1) we conclude our proof.

6.2

The VC-Dimension
We see, therefore, that while finiteness of H is a sufficient condition for learnability, it is not a necessary condition. As we will show, a property called the
VC-dimension of a hypothesis class gives the correct characterization of its learnability. To motivate the definition of the VC-dimension, let us recall the No-FreeLunch theorem (Theorem 5.1) and its proof. There, we have shown that without

6.2 The VC-Dimension

69

restricting the hypothesis class, for any learning algorithm, an adversary can
construct a distribution for which the learning algorithm will perform poorly,
while there is another learning algorithm that will succeed on the same distribution. To do so, the adversary used a finite set C âŠ‚ X and considered a family
of distributions that are concentrated on elements of C. Each distribution was
derived from a â€œtrueâ€ target function from C to {0, 1}. To make any algorithm
fail, the adversary used the power of choosing a target function from the set of
all possible functions from C to {0, 1}.
When considering PAC learnability of a hypothesis class H, the adversary
is restricted to constructing distributions for which some hypothesis h âˆˆ H
achieves a zero risk. Since we are considering distributions that are concentrated
on elements of C, we should study how H behaves on C, which leads to the
following definition.
definition 6.2 (Restriction of H to C) Let H be a class of functions from X
to {0, 1} and let C = {c1 , . . . , cm } âŠ‚ X . The restriction of H to C is the set of
functions from C to {0, 1} that can be derived from H. That is,
HC = {(h(c1 ), . . . , h(cm )) : h âˆˆ H},
where we represent each function from C to {0, 1} as a vector in {0, 1}|C| .
If the restriction of H to C is the set of all functions from C to {0, 1}, then
we say that H shatters the set C. Formally:
definition 6.3 (Shattering) A hypothesis class H shatters a finite set C âŠ‚ X
if the restriction of H to C is the set of all functions from C to {0, 1}. That is,
|HC | = 2|C| .
Example 6.2 Let H be the class of threshold functions over R. Take a set
C = {c1 }. Now, if we take a = c1 + 1, then we have ha (c1 ) = 1, and if we take
a = c1 âˆ’ 1, then we have ha (c1 ) = 0. Therefore, HC is the set of all functions
from C to {0, 1}, and H shatters C. Now take a set C = {c1 , c2 }, where c1 â‰¤ c2 .
No h âˆˆ H can account for the labeling (0, 1), because any threshold that assigns
the label 0 to c1 must assign the label 0 to c2 as well. Therefore not all functions
from C to {0, 1} are included in HC ; hence C is not shattered by H.
Getting back to the construction of an adversarial distribution as in the proof
of the No-Free-Lunch theorem (Theorem 5.1), we see that whenever some set C
is shattered by H, the adversary is not restricted by H, as they can construct
a distribution over C based on any target function from C to {0, 1}, while still
maintaining the realizability assumption. This immediately yields:
corollary 6.4 Let H be a hypothesis class of functions from X to {0, 1}. Let
m be a training set size. Assume that there exists a set C âŠ‚ X of size 2m that is
shattered by H. Then, for any learning algorithm, A, there exist a distribution D
over X Ã— {0, 1} and a predictor h âˆˆ H such that LD (h) = 0 but with probability
of at least 1/7 over the choice of S âˆ¼ Dm we have that LD (A(S)) â‰¥ 1/8.

70

The VC-Dimension

Corollary 6.4 tells us that if H shatters some set C of size 2m then we cannot
learn H using m examples. Intuitively, if a set C is shattered by H, and we
receive a sample containing half the instances of C, the labels of these instances
give us no information about the labels of the rest of the instances in C â€“ every
possible labeling of the rest of the instances can be explained by some hypothesis
in H. Philosophically,
If someone can explain every phenomenon, his explanations are worthless.

This leads us directly to the definition of the VC dimension.
definition 6.5 (VC-dimension) The VC-dimension of a hypothesis class H,
denoted VCdim(H), is the maximal size of a set C âŠ‚ X that can be shattered
by H. If H can shatter sets of arbitrarily large size we say that H has infinite
VC-dimension.
A direct consequence of Corollary 6.4 is therefore:
theorem 6.6
learnable.

Let H be a class of infinite VC-dimension. Then, H is not PAC

Proof Since H has an infinite VC-dimension, for any training set size m, there
exists a shattered set of size 2m, and the claim follows by Corollary 6.4.
We shall see later in this chapter that the converse is also true: A finite VCdimension guarantees learnability. Hence, the VC-dimension characterizes PAC
learnability. But before delving into more theory, we first show several examples.

6.3

Examples
In this section we calculate the VC-dimension of several hypothesis classes. To
show that VCdim(H) = d we need to show that
1. There exists a set C of size d that is shattered by H.
2. Every set C of size d + 1 is not shattered by H.

6.3.1

Threshold Functions
Let H be the class of threshold functions over R. Recall Example 6.2, where
we have shown that for an arbitrary set C = {c1 }, H shatters C; therefore
VCdim(H) â‰¥ 1. We have also shown that for an arbitrary set C = {c1 , c2 } where
c1 â‰¤ c2 , H does not shatter C. We therefore conclude that VCdim(H) = 1.

6.3 Examples

6.3.2

71

Intervals
Let H be the class of intervals over R, namely, H = {ha,b : a, b âˆˆ R, a < b},
where ha,b : R â†’ {0, 1} is a function such that ha,b (x) = 1[xâˆˆ(a,b)] . Take the set
C = {1, 2}. Then, H shatters C (make sure you understand why) and therefore
VCdim(H) â‰¥ 2. Now take an arbitrary set C = {c1 , c2 , c3 } and assume without
loss of generality that c1 â‰¤ c2 â‰¤ c3 . Then, the labeling (1, 0, 1) cannot be obtained
by an interval and therefore H does not shatter C. We therefore conclude that
VCdim(H) = 2.

6.3.3

Axis Aligned Rectangles
Let H be the class of axis aligned rectangles, formally:
H = {h(a1 ,a2 ,b1 ,b2 ) : a1 â‰¤ a2 and b1 â‰¤ b2 }
where
(
h(a1 ,a2 ,b1 ,b2 ) (x1 , x2 ) =

1

if a1 â‰¤ x1 â‰¤ a2 and b1 â‰¤ x2 â‰¤ b2

0

otherwise

(6.2)

We shall show in the following that VCdim(H) = 4. To prove this we need
to find a set of 4 points that are shattered by H, and show that no set of 5
points can be shattered by H. Finding a set of 4 points that are shattered is
easy (see Figure 6.1). Now, consider any set C âŠ‚ R2 of 5 points. In C, take a
leftmost point (whose first coordinate is the smallest in C), a rightmost point
(first coordinate is the largest), a lowest point (second coordinate is the smallest),
and a highest point (second coordinate is the largest). Without loss of generality,
denote C = {c1 , . . . , c5 } and let c5 be the point that was not selected. Now,
define the labeling (1, 1, 1, 1, 0). It is impossible to obtain this labeling by an
axis aligned rectangle. Indeed, such a rectangle must contain c1 , . . . , c4 ; but in
this case the rectangle contains c5 as well, because its coordinates are within
the intervals defined by the selected points. So, C is not shattered by H, and
therefore VCdim(H) = 4.
c1
c4

c5

c2

c3

Figure 6.1 Left: 4 points that are shattered by axis aligned rectangles. Right: Any axis

aligned rectangle cannot label c5 by 0 and the rest of the points by 1.

72

The VC-Dimension

6.3.4

Finite Classes
Let H be a finite class. Then, clearly, for any set C we have |HC | â‰¤ |H| and thus C
cannot be shattered if |H| < 2|C| . This implies that VCdim(H) â‰¤ log2 (|H|). This
shows that the PAC learnability of finite classes follows from the more general
statement of PAC learnability of classes with finite VC-dimension, which we shall
see in the next section. Note, however, that the VC-dimension of a finite class
H can be significantly smaller than log2 (|H|). For example, let X = {1, . . . , k},
for some integer k, and consider the class of threshold functions (as defined in
Example 6.2). Then, |H| = k but VCdim(H) = 1. Since k can be arbitrarily
large, the gap between log2 (|H|) and VCdim(H) can be arbitrarily large.

6.3.5

VC-Dimension and the Number of Parameters
In the previous examples, the VC-dimension happened to equal the number of
parameters defining the hypothesis class. While this is often the case, it is not
always true. Consider, for example, the domain X = R, and the hypothesis class
H = {hÎ¸ : Î¸ âˆˆ R} where hÎ¸ : X â†’ {0, 1} is defined by hÎ¸ (x) = d0.5 sin(Î¸x)e. It
is possible to prove that VCdim(H) = âˆž, namely, for every d, one can find d
points that are shattered by H (see Exercise 8).

6.4

The Fundamental Theorem of PAC learning
We have already shown that a class of infinite VC-dimension is not learnable. The
converse statement is also true, leading to the fundamental theorem of statistical
learning theory:
theorem 6.7 (The Fundamental Theorem of Statistical Learning) Let H be a
hypothesis class of functions from a domain X to {0, 1} and let the loss function
be the 0 âˆ’ 1 loss. Then, the following are equivalent:
1.
2.
3.
4.
5.
6.

H has the uniform convergence property.
Any ERM rule is a successful agnostic PAC learner for H.
H is agnostic PAC learnable.
H is PAC learnable.
Any ERM rule is a successful PAC learner for H.
H has a finite VC-dimension.

The proof of the theorem is given in the next section.
Not only does the VC-dimension characterize PAC learnability; it even determines the sample complexity.
theorem 6.8 (The Fundamental Theorem of Statistical Learning â€“ Quantitative Version) Let H be a hypothesis class of functions from a domain X to {0, 1}
and let the loss function be the 0 âˆ’ 1 loss. Assume that VCdim(H) = d < âˆž.
Then, there are absolute constants C1 , C2 such that:

6.5 Proof of Theorem 6.7

73

1. H has the uniform convergence property with sample complexity
d + log(1/Î´)
d + log(1/Î´)
â‰¤ mUC
H (, Î´) â‰¤ C2
2
2
2. H is agnostic PAC learnable with sample complexity
C1

d + log(1/Î´)
d + log(1/Î´)
â‰¤ mH (, Î´) â‰¤ C2
2

2
3. H is PAC learnable with sample complexity
C1

d + log(1/Î´)
d log(1/) + log(1/Î´)
â‰¤ mH (, Î´) â‰¤ C2


The proof of this theorem is given in Chapter 28.
C1

Remark 6.3 We stated the fundamental theorem for binary classification tasks.
A similar result holds for some other learning problems such as regression with
the absolute loss or the squared loss. However, the theorem does not hold for
all learning tasks. In particular, learnability is sometimes possible even though
the uniform convergence property does not hold (we will see an example in
Chapter 13, Exercise 2). Furthermore, in some situations, the ERM rule fails
but learnability is possible with other learning rules.

6.5

Proof of Theorem 6.7
We have already seen that 1 â†’ 2 in Chapter 4. The implications 2 â†’ 3 and
3 â†’ 4 are trivial and so is 2 â†’ 5. The implications 4 â†’ 6 and 5 â†’ 6 follow from
the No-Free-Lunch theorem. The difficult part is to show that 6 â†’ 1. The proof
is based on two main claims:
â€¢ If VCdim(H) = d, then even though H might be infinite, when restricting it
to a finite set C âŠ‚ X , its â€œeffectiveâ€ size, |HC |, is only O(|C|d ). That is,
the size of HC grows polynomially rather than exponentially with |C|. This
claim is often referred to as Sauerâ€™s lemma, but it has also been stated and
proved independently by Shelah and by Perles. The formal statement is
given in Section 6.5.1 later.
â€¢ In Section 4 we have shown that finite hypothesis classes enjoy the uniform
convergence property. In Section 6.5.2 later we generalize this result and
show that uniform convergence holds whenever the hypothesis class has a
â€œsmall effective size.â€ By â€œsmall effective sizeâ€ we mean classes for which
|HC | grows polynomially with |C|.

6.5.1

Sauerâ€™s Lemma and the Growth Function
We defined the notion of shattering, by considering the restriction of H to a finite
set of instances. The growth function measures the maximal â€œeffectiveâ€ size of
H on a set of m examples. Formally:

74

The VC-Dimension

definition 6.9 (Growth Function) Let H be a hypothesis class. Then the
growth function of H, denoted Ï„H : N â†’ N, is defined as


HC  .
Ï„H (m) =
max
CâŠ‚X :|C|=m

In words, Ï„H (m) is the number of different functions from a set C of size m to
{0, 1} that can be obtained by restricting H to C.
Obviously, if VCdim(H) = d then for any m â‰¤ d we have Ï„H (m) = 2m . In
such cases, H induces all possible functions from C to {0, 1}. The following beautiful lemma, proposed independently by Sauer, Shelah, and Perles, shows that
when m becomes larger than the VC-dimension, the growth function increases
polynomially rather than exponentially with m.
lemma 6.10 (Sauer-Shelah-Perles) Let H be a hypothesis class with VCdim(H) â‰¤
Pd
d < âˆž. Then, for all m, Ï„H (m) â‰¤ i=0 mi . In particular, if m > d + 1 then
Ï„H (m) â‰¤ (em/d)d .

Proof of Sauerâ€™s Lemma *
To prove the lemma it suffices to prove the following stronger claim: For any
C = {c1 , . . . , cm } we have
âˆ€ H,

|HC | â‰¤ |{B âŠ† C : H shatters B}|.

(6.3)

The reason why Equation (6.3) is sufficient to prove the lemma is that if VCdim(H) â‰¤
d then no set whose size is larger than d is shattered by H and therefore
d  
X
m
.
|{B âŠ† C : H shatters B}| â‰¤
i
i=0
When m > d + 1 the right-hand side of the preceding is at most (em/d)d (see
Lemma A.5 in Appendix A).
We are left with proving Equation (6.3) and we do it using an inductive argument. For m = 1, no matter what H is, either both sides of Equation (6.3) equal
1 or both sides equal 2 (the empty set is always considered to be shattered by
H). Assume Equation (6.3) holds for sets of size k < m and let us prove it for
sets of size m. Fix H and C = {c1 , . . . , cm }. Denote C 0 = {c2 , . . . , cm } and in
addition, define the following two sets:
Y0 = {(y2 , . . . , ym ) : (0, y2 , . . . , ym ) âˆˆ HC âˆ¨ (1, y2 , . . . , ym ) âˆˆ HC },
and
Y1 = {(y2 , . . . , ym ) : (0, y2 , . . . , ym ) âˆˆ HC âˆ§ (1, y2 , . . . , ym ) âˆˆ HC }.
It is easy to verify that |HC | = |Y0 | + |Y1 |. Additionally, since Y0 = HC 0 , using
the induction assumption (applied on H and C 0 ) we have that
|Y0 | = |HC 0 | â‰¤ |{B âŠ† C 0 : H shatters B}| = |{B âŠ† C : c1 6âˆˆ B âˆ§ H shatters B}|.

6.5 Proof of Theorem 6.7

75

Next, define H0 âŠ† H to be
H0 = {h âˆˆ H : âˆƒh0 âˆˆ H s.t. (1 âˆ’ h0 (c1 ), h0 (c2 ), . . . , h0 (cm ))
= (h(c1 ), h(c2 ), . . . , h(cm )},
namely, H0 contains pairs of hypotheses that agree on C 0 and differ on c1 . Using
this definition, it is clear that if H0 shatters a set B âŠ† C 0 then it also shatters
0
the set B âˆª {c1 } and vice versa. Combining this with the fact that Y1 = HC
0 and
using the inductive assumption (now applied on H0 and C 0 ) we obtain that
0
0
0
0
0
|Y1 | = |HC
0 | â‰¤ |{B âŠ† C : H shatters B}| = |{B âŠ† C : H shatters B âˆª {c1 }}|

= |{B âŠ† C : c1 âˆˆ B âˆ§ H0 shatters B}| â‰¤ |{B âŠ† C : c1 âˆˆ B âˆ§ H shatters B}|.
Overall, we have shown that
|HC | = |Y0 | + |Y1 |
â‰¤ |{B âŠ† C : c1 6âˆˆ B âˆ§ H shatters B}| + |{B âŠ† C : c1 âˆˆ B âˆ§ H shatters B}|
= |{B âŠ† C : H shatters B}|,
which concludes our proof.

6.5.2

Uniform Convergence for Classes of Small Effective Size
In this section we prove that if H has small effective size then it enjoys the
uniform convergence property. Formally,
theorem 6.11 Let H be a class and let Ï„H be its growth function. Then, for
every D and every Î´ âˆˆ (0, 1), with probability of at least 1 âˆ’ Î´ over the choice of
S âˆ¼ Dm we have
p
4 + log(Ï„H (2m))
âˆš
.
|LD (h) âˆ’ LS (h)| â‰¤
Î´ 2m
Before proving the theorem, let us first conclude the proof of Theorem 6.7.
Proof of Theorem 6.7 It suffices to prove that if the VC-dimension is finite then
the uniform convergence property holds. We will prove that


16d
16 d log(2e/d)
16d
UC
log
+
.
mH (, Î´) â‰¤ 4
(Î´)2
(Î´)2
(Î´)2
From Sauerâ€™s lemma we have that for m > d, Ï„H (2m) â‰¤ (2em/d)d . Combining
this with Theorem 6.11 we obtain that with probability of at least 1 âˆ’ Î´,
p
4 + d log(2em/d)
âˆš
.
|LS (h) âˆ’ LD (h)| â‰¤
Î´ 2m
p
For simplicity assume that d log(2em/d) â‰¥ 4; hence,
r
2d log(2em/d)
1
|LS (h) âˆ’ LD (h)| â‰¤
.
Î´
m

76

The VC-Dimension

To ensure that the preceding is at most  we need that
mâ‰¥

2d log(m) 2 d log(2e/d)
+
.
(Î´)2
(Î´)2

Standard algebraic manipulations (see Lemma A.2 in Appendix A) show that a
sufficient condition for the preceding to hold is that


2d
4 d log(2e/d)
2d
log
+
.
mâ‰¥4
(Î´)2
(Î´)2
(Î´)2

Remark 6.4 The upper bound on mUC
H we derived in the proof Theorem 6.7
is not the tightest possible. A tighter analysis that yields the bounds given in
Theorem 6.8 can be found in Chapter 28.

Proof of Theorem 6.11 *
We will start by showing that
p


4 + log(Ï„H (2m))
âˆš
.
E
sup |LD (h) âˆ’ LS (h)| â‰¤
Sâˆ¼D m hâˆˆH
2m

(6.4)

Since the random variable suphâˆˆH |LD (h) âˆ’ LS (h)| is nonnegative, the proof of
the theorem follows directly from the preceding using Markovâ€™s inequality (see
Section B.1).
To bound the left-hand side of Equation (6.4) we first note that for every
0
is an
h âˆˆ H, we can rewrite LD (h) = ES 0 âˆ¼Dm [LS 0 (h)], where S 0 = z10 , . . . , zm
additional i.i.d. sample. Therefore,







E m sup |LD (h) âˆ’ LS (h)| = E m sup  0 E m LS 0 (h) âˆ’ LS (h) .
Sâˆ¼D

Sâˆ¼D

hâˆˆH

hâˆˆH S âˆ¼D

A generalization of the triangle inequality yields




 0 E m [LS 0 (h) âˆ’ LS (h)] â‰¤ 0 E m |LS 0 (h) âˆ’ LS (h)|,
S âˆ¼D

S âˆ¼D

and the fact that supermum of expectation is smaller than expectation of supremum yields
sup

E

0
m
hâˆˆH S âˆ¼D

|LS 0 (h) âˆ’ LS (h)| â‰¤

E

sup |LS 0 (h) âˆ’ LS (h)|.

S 0 âˆ¼D m hâˆˆH

Formally, the previous two inequalities follow from Jensenâ€™s inequality. Combining all we obtain




0
E
sup |LD (h) âˆ’ LS (h)| â‰¤
E
sup |LS (h) âˆ’ LS (h)|
Sâˆ¼D m hâˆˆH
S,S 0 âˆ¼D m hâˆˆH

#
"
m

1 X

0
=
E
sup
(`(h,
z
)
âˆ’
`(h,
z
))

 .
i
i
S,S 0 âˆ¼D m hâˆˆH m 

i=1

(6.5)

6.5 Proof of Theorem 6.7

77

The expectation on the right-hand side is over a choice of two i.i.d. samples
0
S = z1 , . . . , zm and S 0 = z10 , . . . , zm
. Since all of these 2m vectors are chosen
i.i.d., nothing will change if we replace the name of the random vector zi with the
name of the random vector zi0 . If we do it, instead of the term (`(h, zi0 ) âˆ’ `(h, zi ))
in Equation (6.5) we will have the term âˆ’(`(h, zi0 ) âˆ’ `(h, zi )). It follows that for
every Ïƒ âˆˆ {Â±1}m we have that Equation (6.5) equals
m
#
"

1 X

0
Ïƒ
(`(h,
z
)
âˆ’
`(h,
z
))
E
sup


i
i
i
S,S 0 âˆ¼D m hâˆˆH m 

i=1

m

Since this holds for every Ïƒ âˆˆ {Â±1} , it also holds if we sample each component
of Ïƒ uniformly at random from the uniform distribution over {Â±1}, denoted UÂ± .
Hence, Equation (6.5) also equals
#
m
"

1 X

0
E m 0E m sup
Ïƒi (`(h, zi ) âˆ’ `(h, zi )) ,

Ïƒâˆ¼UÂ± S,S âˆ¼D

hâˆˆH m 
i=1

and by the linearity of expectation it also equals
#
m
"

1 X

0
E
E
sup
Ïƒ
(`(h,
z
)
âˆ’
`(h,
z
))
 .

i
i
i
m
S,S 0 âˆ¼D m Ïƒâˆ¼UÂ±


hâˆˆH m i=1
Next, fix S and S 0 , and let C be the instances appearing in S and S 0 . Then, we
can take the supremum only over h âˆˆ HC . Therefore,
#
m
"

1 X

E m sup
Ïƒi (`(h, zi0 ) âˆ’ `(h, zi ))

Ïƒâˆ¼UÂ± hâˆˆH m 

i=1
#
m
"

1 X

0
= E m max
Ïƒi (`(h, zi ) âˆ’ `(h, zi )) .

Ïƒâˆ¼UÂ± hâˆˆHC m 

i=1
Pm
1
0
Fix some h âˆˆ HC and denote Î¸h = m
i=1 Ïƒi (`(h, zi ) âˆ’ `(h, zi )). Since E[Î¸h ] = 0
and Î¸h is an average of independent variables, each of which takes values in
[âˆ’1, 1], we have by Hoeffdingâ€™s inequality that for every Ï > 0,

P[|Î¸h | > Ï] â‰¤ 2 exp âˆ’2 m Ï2 .
Applying the union bound over h âˆˆ HC , we obtain that for any Ï > 0,



P max |Î¸h | > Ï â‰¤ 2 |HC | exp âˆ’2 m Ï2 .
hâˆˆHC

Finally, Lemma A.4 in Appendix A tells us that the preceding implies
p


4 + log(|HC |)
âˆš
.
E max |Î¸h | â‰¤
hâˆˆHC
2m
Combining all with the definition of Ï„H , we have shown that
p


4 + log(Ï„H (2m))
âˆš
E
sup |LD (h) âˆ’ LS (h)| â‰¤
.
Sâˆ¼D m hâˆˆH
2m

78

The VC-Dimension

6.6

Summary
The fundamental theorem of learning theory characterizes PAC learnability of
classes of binary classifiers using VC-dimension. The VC-dimension of a class
is a combinatorial property that denotes the maximal sample size that can be
shattered by the class. The fundamental theorem states that a class is PAC learnable if and only if its VC-dimension is finite and specifies the sample complexity
required for PAC learning. The theorem also shows that if a problem is at all
learnable, then uniform convergence holds and therefore the problem is learnable
using the ERM rule.

6.7

Bibliographic remarks
The definition of VC-dimension and its relation to learnability and to uniform
convergence is due to the seminal work of Vapnik & Chervonenkis (1971). The
relation to the definition of PAC learnability is due to Blumer, Ehrenfeucht,
Haussler & Warmuth (1989).
Several generalizations of the VC-dimension have been proposed. For example, the fat-shattering dimension characterizes learnability of some regression
problems (Kearns, Schapire & Sellie 1994, Alon, Ben-David, Cesa-Bianchi &
Haussler 1997, Bartlett, Long & Williamson 1994, Anthony & Bartlet 1999), and
the Natarajan dimension characterizes learnability of some multiclass learning
problems (Natarajan 1989). However, in general, there is no equivalence between
learnability and uniform convergence. See (Shalev-Shwartz, Shamir, Srebro &
Sridharan 2010, Daniely, Sabato, Ben-David & Shalev-Shwartz 2011).
Sauerâ€™s lemma has been proved by Sauer in response to a problem of Erdos
(Sauer 1972). Shelah (with Perles) proved it as a useful lemma for Shelahâ€™s theory
of stable models (Shelah 1972). Gil Kalai tells1 us that at some later time, Benjy
Weiss asked Perles about such a result in the context of ergodic theory, and
Perles, who forgot that he had proved it once, proved it again. Vapnik and
Chervonenkis proved the lemma in the context of statistical learning theory.

6.8

Exercises
1. Show the following monotonicity property of VC-dimension: For every two
hypothesis classes if H0 âŠ† H then VCdim(H0 ) â‰¤ VCdim(H).
2. Given some finite domain set, X , and a number k â‰¤ |X |, figure out the VCdimension of each of the following classes (and prove your claims):
X
1. H=k
= {h âˆˆ {0, 1}X : |{x : h(x) = 1}| = k}. That is, the set of all functions
that assign the value 1 to exactly k elements of X .
1

http://gilkalai.wordpress.com/2008/09/28/
extremal-combinatorics-iii-some-basic-theorems

6.8 Exercises

79

2. Hatâˆ’mostâˆ’k = {h âˆˆ {0, 1}X : |{x : h(x) = 1}| â‰¤ k or |{x : h(x) = 0}| â‰¤ k}.
3. Let X be the Boolean hypercube {0, 1}n . For a set I âŠ† {1, 2, . . . , n} we define
a parity function hI as follows. On a binary vector x = (x1 , x2 , . . . , xn ) âˆˆ
{0, 1}n ,
!
X
hI (x) =
xi mod 2 .
iâˆˆI

(That is, hI computes parity of bits in I.) What is the VC-dimension of the
class of all such parity functions, Hn-parity = {hI : I âŠ† {1, 2, . . . , n}}?
4. We proved Sauerâ€™s lemma by proving that for every class H of finite VCdimension d, and every subset A of the domain,
|HA | â‰¤ |{B âŠ† A : H shatters B}| â‰¤


d 
X
|A|
i=0

i

.

Show that there are cases in which the previous two inequalities are strict
(namely, the â‰¤ can be replaced by <) and cases in which they can be replaced
by equalities. Demonstrate all four combinations of = and <.
d
5. VC-dimension of axis aligned rectangles in Rd : Let Hrec
be the class of
d
2
) = 4.
axis aligned rectangles in R . We have already seen that VCdim(Hrec
d
) = 2d.
Prove that in general, VCdim(Hrec
d
6. VC-dimension of Boolean conjunctions: Let Hcon
be the class of Boolean
conjunctions over the variables x1 , . . . , xd (d â‰¥ 2). We already know that this
class is finite and thus (agnostic) PAC learnable. In this question we calculate
d
).
VCdim(Hcon
1.
2.
3.
4.

d
| â‰¤ 3d + 1.
Show that |Hcon
Conclude that VCdim(H) â‰¤ d log 3.
d
Show that Hcon
shatters the set of unit vectors {ei : i â‰¤ d}.
d
(**) Show that VCdim(Hcon
) â‰¤ d.
Hint: Assume by contradiction that there exists a set C = {c1 , . . . , cd+1 }
d
d
that is shattered by Hcon
. Let h1 , . . . , hd+1 be hypotheses in Hcon
that
satisfy
(
0 i=j
âˆ€i, j âˆˆ [d + 1], hi (cj ) =
1 otherwise

For each i âˆˆ [d + 1], hi (or more accurately, the conjunction that corresponds to hi ) contains some literal `i which is false on ci and true on cj
for each j 6= i. Use the Pigeonhole principle to show that there must be a
pair i < j â‰¤ d + 1 such that `i and `j use the same xk and use that fact
to derive a contradiction to the requirements from the conjunctions hi , hj .
d
5. Consider the class Hmcon
of monotone Boolean conjunctions over {0, 1}d .
Monotonicity here means that the conjunctions do not contain negations.

80

The VC-Dimension

d
As in Hcon
, the empty conjunction is interpreted as the all-positive hyd
pothesis. We augment Hmcon
with the all-negative hypothesis hâˆ’ . Show
d
that VCdim(Hmcon ) = d.
7. We have shown that for a finite hypothesis class H, VCdim(H) â‰¤ blog(|H|)c.
However, this is just an upper bound. The VC-dimension of a class can be
much lower than that:
1. Find an example of a class H of functions over the real interval X = [0, 1]
such that H is infinite while VCdim(H) = 1.
2. Give an example of a finite hypothesis class H over the domain X = [0, 1],
where VCdim(H) = blog2 (|H|)c.
8. (*) It is often the case that the VC-dimension of a hypothesis class equals (or
can be bounded above by) the number of parameters one needs to set in order
to define each hypothesis in the class. For instance, if H is the class of axis
aligned rectangles in Rd , then VCdim(H) = 2d, which is equal to the number
of parameters used to define a rectangle in Rd . Here is an example that shows
that this is not always the case. We will see that a hypothesis class might
be very complex and even not learnable, although it has a small number of
parameters.
Consider the domain X = R, and the hypothesis class

H = {x 7â†’ dsin(Î¸x)e : Î¸ âˆˆ R}
(here, we take dâˆ’1e = 0). Prove that VCdim(H) = âˆž.
Hint: There is more than one way to prove the required result. One option
is by applying the following lemma: If 0.x1 x2 x3 . . ., is the binary expansion of
x âˆˆ (0, 1), then for any natural number m, dsin(2m Ï€x)e = (1 âˆ’ xm ), provided
that âˆƒk â‰¥ m s.t. xk = 1.
9. Let H be the class of signed intervals, that is,
H = {ha,b,s : a â‰¤ b, s âˆˆ {âˆ’1, 1}} where
(
s
if x âˆˆ [a, b]
ha,b,s (x) =
âˆ’s if x âˆˆ
/ [a, b]
Calculate VCdim(H).
10. Let H be a class of functions from X to {0, 1}.
1. Prove that if VCdim(H) â‰¥ d, for any d, then for some probability distribution D over X Ã— {0, 1}, for every sample size, m,
E m [LD (A(S))] â‰¥ min LD (h) +

Sâˆ¼D

hâˆˆH

dâˆ’m
2d

Hint: Use Exercise 3 in Chapter 5.
2. Prove that for every H that is PAC learnable, VCdim(H) < âˆž. (Note that
this is the implication 3 â†’ 6 in Theorem 6.7.)
11. VC of union: Let H1 , . . . , Hr be hypothesis classes over some fixed domain
set X . Let d = maxi VCdim(Hi ) and assume for simplicity that d â‰¥ 3.

6.8 Exercises

81

1. Prove that
VCdim (âˆªri=1 Hi ) â‰¤ 4d log(2d) + 2 log(r) .
Hint: Take a set of k examples and assume that they are shattered by
the union class. Therefore, the union class can produce all 2k possible
labelings on these examples. Use Sauerâ€™s lemma to show that the union
class cannot produce more than rk d labelings. Therefore, 2k < rk d . Now
use Lemma A.2.
2. (*) Prove that for r = 2 it holds that
VCdim (H1 âˆª H2 ) â‰¤ 2d + 1.
12. Dudley classes: In this question we discuss an algebraic framework for
defining concept classes over Rn and show a connection between the VC
dimension of such classes and their algebraic properties. Given a function
f : Rn â†’ R we define the corresponding function, POS (f )(x) = 1[f (x)>0] . For
a class F of real valued functions we define a corresponding class of functions
POS (F) = {POS (f ) : f âˆˆ F}. We say that a family, F, of real valued functions is linearly closed if for all f, g âˆˆ F and r âˆˆ R, (f + rg) âˆˆ F (where
addition and scalar multiplication of functions are defined point wise, namely,
for all x âˆˆ Rn , (f + rg)(x) = f (x) + rg(x)). Note that if a family of functions
is linearly closed then we can view it as a vector space over the reals. For a
def
function g : Rn â†’ R and a family of functions F, let F +g = {f +g : f âˆˆ F}.
Hypothesis classes that have a representation as POS (F + g) for some vector
space of functions F and some function g are called Dudley classes.
1. Show that for every g : Rn â†’ R and every vector space of functions F as
defined earlier, VCdim(POS (F + g)) = VCdim(POS (F)).
2. (**) For every linearly closed family of real valued functions F, the VCdimension of the corresponding class POS (F) equals the linear dimension
of F (as a vector space). Hint: Let f1 , . . . , fd be a basis for the vector space
F. Consider the mapping x 7â†’ (f1 (x), . . . , fd (x)) (from Rn to Rd ). Note
that this mapping induces a matching between functions over Rn of the
form POS (f ) and homogeneous linear halfspaces in Rd (the VC-dimension
of the class of homogeneous linear halfspaces is analyzed in Chapter 9).
3. Show that each of the following classes can be represented as a Dudley
class:
1. The class HSn of halfspaces over Rn (see Chapter 9).
2. The class HHSn of all homogeneous halfspaces over Rn (see Chapter 9).
3. The class Bd of all functions defined by (open) balls in Rd . Use the
Dudley representation to figure out the VC-dimension of this class.
4. Let Pnd denote the class of functions defined by polynomial inequalities
of degree â‰¤ d, namely,
Pnd = {hp : p is a polynomial of degree â‰¤ d in the variables x1 , . . . , xn },

82

The VC-Dimension

where, for x = (x1 . . . . , xn ), hp (x) = 1[p(x)â‰¥0] (the degree of a multivariable polynomial is the maximal sum of variable exponents over all
of its terms. For example, the degree of p(x) = 3x31 x22 + 4x3 x27 is 5).
1. Use the Dudley representation to figure out the VC-dimension of the
class P1d â€“ the class of all d-degree polynomials over R.
2. Prove that the class of all polynomial classifiers over R has infinite
VC-dimension.
3. Use the Dudley representation to figure out the VC-dimension of the
class Pnd (as a function of d and n).

7

Nonuniform Learnability

The notions of PAC learnability discussed so far in the book allow the sample
sizes to depend on the accuracy and confidence parameters, but they are uniform
with respect to the labeling rule and the underlying data distribution. Consequently, classes that are learnable in that respect are limited (they must have
a finite VC-dimension, as stated by Theorem 6.7). In this chapter we consider
more relaxed, weaker notions of learnability. We discuss the usefulness of such
notions and provide characterization of the concept classes that are learnable
using these definitions.
We begin this discussion by defining a notion of â€œnonuniform learnabilityâ€ that
allows the sample size to depend on the hypothesis to which the learner is compared. We then provide a characterization of nonuniform learnability and show
that nonuniform learnability is a strict relaxation of agnostic PAC learnability.
We also show that a sufficient condition for nonuniform learnability is that H is
a countable union of hypothesis classes, each of which enjoys the uniform convergence property. These results will be proved in Section 7.2 by introducing a
new learning paradigm, which is called Structural Risk Minimization (SRM). In
Section 7.3 we specify the SRM paradigm for countable hypothesis classes, which
yields the Minimum Description Length (MDL) paradigm. The MDL paradigm
gives a formal justification to a philosophical principle of induction called Occamâ€™s razor. Next, in Section 7.4 we introduce consistency as an even weaker
notion of learnability. Finally, we discuss the significance and usefulness of the
different notions of learnability.

7.1

Nonuniform Learnability
â€œNonuniform learnabilityâ€ allows the sample size to be nonuniform with respect
to the different hypotheses with which the learner is competing. We say that a
hypothesis h is (, Î´)-competitive with another hypothesis h0 if, with probability
higher than (1 âˆ’ Î´),
LD (h) â‰¤ LD (h0 ) + .
In PAC learnability, this notion of â€œcompetitivenessâ€ is not very useful, as we
are looking for a hypothesis with an absolute low risk (in the realizable case) or
c 2014 by Shai Shalev-Shwartz and Shai Ben-David
Understanding Machine Learning, 
Published 2014 by Cambridge University Press.
Personal use only. Not for distribution. Do not post.
Please link to http://www.cs.huji.ac.il/~shais/UnderstandingMachineLearning

84

Nonuniform Learnability

with a low risk compared to the minimal risk achieved by hypotheses in our class
(in the agnostic case). Therefore, the sample size depends only on the accuracy
and confidence parameters. In nonuniform learnability, however, we allow the
sample size to be of the form mH (, Î´, h); namely, it depends also on the h with
which we are competing. Formally,
definition 7.1 A hypothesis class H is nonuniformly learnable if there exist a
2
learning algorithm, A, and a function mNUL
H : (0, 1) Ã—H â†’ N such that, for every
NUL
, Î´ âˆˆ (0, 1) and for every h âˆˆ H, if m â‰¥ mH (, Î´, h) then for every distribution
D, with probability of at least 1 âˆ’ Î´ over the choice of S âˆ¼ Dm , it holds that
LD (A(S)) â‰¤ LD (h) + .
At this point it might be useful to recall the definition of agnostic PAC learnability (Definition 3.3):
A hypothesis class H is agnostically PAC learnable if there exist a learning algorithm, A, and a function mH : (0, 1)2 â†’ N such that, for every , Î´ âˆˆ (0, 1) and
for every distribution D, if m â‰¥ mH (, Î´), then with probability of at least 1 âˆ’ Î´
over the choice of S âˆ¼ Dm it holds that
LD (A(S)) â‰¤ min
LD (h0 ) + .
0
h âˆˆH

Note that this implies that for every h âˆˆ H
LD (A(S)) â‰¤ LD (h) + .
In both types of learnability, we require that the output hypothesis will be
(, Î´)-competitive with every other hypothesis in the class. But the difference
between these two notions of learnability is the question of whether the sample
size m may depend on the hypothesis h to which the error of A(S) is compared.
Note that that nonuniform learnability is a relaxation of agnostic PAC learnability. That is, if a class is agnostic PAC learnable then it is also nonuniformly
learnable.

7.1.1

Characterizing Nonuniform Learnability
Our goal now is to characterize nonuniform learnability. In the previous chapter
we have found a crisp characterization of PAC learnable classes, by showing
that a class of binary classifiers is agnostic PAC learnable if and only if its VCdimension is finite. In the following theorem we find a different characterization
for nonuniform learnable classes for the task of binary classification.
theorem 7.2 A hypothesis class H of binary classifiers is nonuniformly learnable if and only if it is a countable union of agnostic PAC learnable hypothesis
classes.
The proof of Theorem 7.2 relies on the following result of independent interest:

7.2 Structural Risk Minimization

85

theorem 7.3 Let H be a hypothesis class that can be written as a countable
S
union of hypothesis classes, H = nâˆˆN Hn , where each Hn enjoys the uniform
convergence property. Then, H is nonuniformly learnable.
Recall that in Chapter 4 we have shown that uniform convergence is sufficient
for agnostic PAC learnability. Theorem 7.3 generalizes this result to nonuniform learnability. The proof of this theorem will be given in the next section by
introducing a new learning paradigm. We now turn to proving Theorem 7.2.
S
Proof of Theorem 7.2 First assume that H = nâˆˆN Hn where each Hn is agnostic PAC learnable. Using the fundamental theorem of statistical learning, it
follows that each Hn has the uniform convergence property. Therefore, using
Theorem 7.3 we obtain that H is nonuniform learnable.
For the other direction, assume that H is nonuniform learnable using some
algorithm A. For every n âˆˆ N, let Hn = {h âˆˆ H : mNUL
H (1/8, 1/7, h) â‰¤ n}.
we know that
Clearly, H = âˆªnâˆˆN Hn . In addition, using the definition of mNUL
H
for any distribution D that satisfies the realizability assumption with respect to
Hn , with probability of at least 6/7 over S âˆ¼ Dn we have that LD (A(S)) â‰¤ 1/8.
Using the fundamental theorem of statistical learning, this implies that the VCdimension of Hn must be finite, and therefore Hn is agnostic PAC learnable.
The following example shows that nonuniform learnability is a strict relaxation of agnostic PAC learnability; namely, there are hypothesis classes that are
nonuniform learnable but are not agnostic PAC learnable.
Example 7.1 Consider a binary classification problem with the instance domain
being X = R. For every n âˆˆ N let Hn be the class of polynomial classifiers of
degree n; namely, Hn is the set of all classifiers of the form h(x) = sign(p(x))
S
where p : R â†’ R is a polynomial of degree n. Let H = nâˆˆN Hn . Therefore, H is
the class of all polynomial classifiers over R. It is easy to verify that VCdim(H) =
âˆž while VCdim(Hn ) = n + 1 (see Exercise 12). Hence, H is not PAC learnable,
while on the basis of Theorem 7.3, H is nonuniformly learnable.

7.2

Structural Risk Minimization
So far, we have encoded our prior knowledge by specifying a hypothesis class
H, which we believe includes a good predictor for the learning task at hand.
Yet another way to express our prior knowledge is by specifying preferences over
hypotheses within H. In the Structural Risk Minimization (SRM) paradigm,
S
we do so by first assuming that H can be written as H = nâˆˆN Hn and then
specifying a weight function, w : N â†’ [0, 1], which assigns a weight to each
hypothesis class, Hn , such that a higher weight reflects a stronger preference
for the hypothesis class. In this section we discuss how to learn with such prior
knowledge. In the next section we describe a couple of important weighting
schemes, including Minimum Description Length.

86

Nonuniform Learnability

S
Concretely, let H be a hypothesis class that can be written as H = nâˆˆN Hn .
For example, H may be the class of all polynomial classifiers where each Hn is
the class of polynomial classifiers of degree n (see Example 7.1). Assume that for
each n, the class Hn enjoys the uniform convergence property (see Definition 4.3
in Chapter 4) with a sample complexity function mUC
Hn (, Î´). Let us also define
the function n : N Ã— (0, 1) â†’ (0, 1) by
n (m, Î´) = min{ âˆˆ (0, 1) : mUC
Hn (, Î´) â‰¤ m}.

(7.1)

In words, we have a fixed sample size m, and we are interested in the lowest
possible upper bound on the gap between empirical and true risks achievable by
using a sample of m examples.
From the definitions of uniform convergence and n , it follows that for every
m and Î´, with probability of at least 1 âˆ’ Î´ over the choice of S âˆ¼ Dm we have
that
âˆ€h âˆˆ Hn , |LD (h) âˆ’ LS (h)| â‰¤ n (m, Î´).

(7.2)

Pâˆž
Let w : N â†’ [0, 1] be a function such that n=1 w(n) â‰¤ 1. We refer to w as
a weight function over the hypothesis classes H1 , H2 , . . .. Such a weight function
can reflect the importance that the learner attributes to each hypothesis class,
or some measure of the complexity of different hypothesis classes. If H is a finite
union of N hypothesis classes, one can simply assign the same weight of 1/N to
all hypothesis classes. This equal weighting corresponds to no a priori preference
to any hypothesis class. Of course, if one believes (as prior knowledge) that a
certain hypothesis class is more likely to contain the correct target function,
then it should be assigned a larger weight, reflecting this prior knowledge. When
H is a (countable) infinite union of hypothesis classes, a uniform weighting is
not possible but many other weighting schemes may work. For example, one can
choose w(n) = Ï€26n2 or w(n) = 2âˆ’n . Later in this chapter we will provide another
convenient way to define weighting functions using description languages.
The SRM rule follows a â€œbound minimizationâ€ approach. This means that
the goal of the paradigm is to find a hypothesis that minimizes a certain upper
bound on the true risk. The bound that the SRM rule wishes to minimize is
given in the following theorem.
Pâˆž
theorem 7.4 Let w : N â†’ [0, 1] be a function such that n=1 w(n) â‰¤ 1. Let
S
H be a hypothesis class that can be written as H = nâˆˆN Hn , where for each n,
Hn satisfies the uniform convergence property with a sample complexity function
mUC
Hn . Let n be as defined in Equation (7.1). Then, for every Î´ âˆˆ (0, 1) and
distribution D, with probability of at least 1 âˆ’ Î´ over the choice of S âˆ¼ Dm , the
following bound holds (simultaneously) for every n âˆˆ N and h âˆˆ Hn .
|LD (h) âˆ’ LS (h)| â‰¤ n (m, w(n) Â· Î´).
Therefore, for every Î´ âˆˆ (0, 1) and distribution D, with probability of at least

7.2 Structural Risk Minimization

87

1 âˆ’ Î´ it holds that
âˆ€h âˆˆ H, LD (h) â‰¤ LS (h) + min n (m, w(n) Â· Î´).
n:hâˆˆHn

(7.3)

Proof For each n define Î´n = w(n)Î´. Applying the assumption that uniform
convergence holds for all n with the rate given in Equation (7.2), we obtain that
if we fix n in advance, then with probability of at least 1 âˆ’ Î´n over the choice of
S âˆ¼ Dm ,
âˆ€h âˆˆ Hn , |LD (h) âˆ’ LS (h)| â‰¤ n (m, Î´n ).
Applying the union bound over n = 1, 2, . . ., we obtain that with probability of
P
P
at least 1 âˆ’ n Î´n = 1 âˆ’ Î´ n w(n) â‰¥ 1 âˆ’ Î´, the preceding holds for all n, which
concludes our proof.
Denote
n(h) = min{n : h âˆˆ Hn },

(7.4)

and then Equation (7.3) implies that
LD (h) â‰¤ LS (h) + n(h) (m, w(n(h)) Â· Î´).
The SRM paradigm searches for h that minimizes this bound, as formalized
in the following pseudocode:
Structural Risk Minimization (SRM)
prior knowledge:
S
H = n Hn where Hn has uniform convergence with mUC
Hn
P
w : N â†’ [0, 1] where n w(n) â‰¤ 1
define: n as in Equation (7.1) ; n(h) as in Equation (7.4)
m
input: training set S âˆ¼ D
 , confidence Î´

output: h âˆˆ argminhâˆˆH LS (h) + n(h) (m, w(n(h)) Â· Î´)
Unlike the ERM paradigm discussed in previous chapters, we no longer just care
about the empirical risk, LS (h), but we are willing to trade some of our bias
toward low empirical risk with a bias toward classes for which n(h) (m, w(n(h))Â·Î´)
is smaller, for the sake of a smaller estimation error.
Next we show that the SRM paradigm can be used for nonuniform learning
of every class, which is a countable union of uniformly converging hypothesis
classes.
S
theorem 7.5 Let H be a hypothesis class such that H = nâˆˆN Hn , where
each Hn has the uniform convergence property with sample complexity mUC
Hn . Let
w : N â†’ [0, 1] be such that w(n) = n26Ï€2 . Then, H is nonuniformly learnable
using the SRM rule with rate


UC
6Î´
mNUL
H (, Î´, h) â‰¤ mHn(h) /2 , (Ï€n(h))2 .

88

Nonuniform Learnability

Proof Let A be the SRM algorithm with respect to the weighting function w.
For every h âˆˆ H, , and Î´, let m â‰¥ mUC
Hn(h) (, w(n(h))Î´). Using the fact that
P
w(n)
=
1,
we
can
apply
Theorem
7.4
to get that, with probability of at least
n
m
1 âˆ’ Î´ over the choice of S âˆ¼ D , we have that for every h0 âˆˆ H,
LD (h0 ) â‰¤ LS (h0 ) + n(h0 ) (m, w(n(h0 ))Î´).
The preceding holds in particular for the hypothesis A(S) returned by the SRM
rule. By the definition of SRM we obtain that


LS (h0 ) + n(h0 ) (m, w(n(h0 ))Î´) â‰¤ LS (h) + n(h) (m, w(n(h))Î´).
LD (A(S)) â‰¤ min
0
h

Finally, if m â‰¥ mUC
Hn(h) (/2, w(n(h))Î´) then clearly n(h) (m, w(n(h))Î´) â‰¤ /2. In
addition, from the uniform convergence property of each Hn we have that with
probability of more than 1 âˆ’ Î´,
LS (h) â‰¤ LD (h) + /2.
Combining all the preceding we obtain that LD (A(S)) â‰¤ LD (h) + , which concludes our proof.
Note that the previous theorem also proves Theorem 7.3.
Remark 7.2 (No-Free-Lunch for Nonuniform Learnability) We have shown that
any countable union of classes of finite VC-dimension is nonuniformly learnable.
It turns out that, for any infinite domain set, X , the class of all binary valued
functions over X is not a countable union of classes of finite VC-dimension. We
leave the proof of this claim as a (nontrivial) exercise (see Exercise 5). It follows
that, in some sense, the no free lunch theorem holds for nonuniform learning
as well: namely, whenever the domain is not finite, there exists no nonuniform
learner with respect to the class of all deterministic binary classifiers (although
for each such classifier there exists a trivial algorithm that learns it â€“ ERM with
respect to the hypothesis class that contains only this classifier).
It is interesting to compare the nonuniform learnability result given in Theorem 7.5 to the task of agnostic PAC learning any specific Hn separately. The
prior knowledge, or bias, of a nonuniform learner for H is weaker â€“ it is searching
for a model throughout the entire class H, rather than being focused on one specific Hn . The cost of this weakening of prior knowledge is the increase in sample
complexity needed to compete with any specific h âˆˆ Hn . For a concrete evaluation of this gap, consider the task of binary classification with the zero-one loss.
n+log(1/Î´)
(where
Assume that for all n, VCdim(Hn ) = n. Since mUC
Hn (, Î´) = C
2
C is the contant appearing in Theorem 6.8), a straightforward calculation shows
that
2 log(2n)
UC
mNUL
.
H (, Î´, h) âˆ’ mHn (/2, Î´) â‰¤ 4C
2
That is, the cost of relaxing the learnerâ€™s prior knowledge from a specific Hn
that contains the target h to a countable union of classes depends on the log of

7.3 Minimum Description Length and Occamâ€™s Razor

89

the index of the first class in which h resides. That cost increases with the index
of the class, which can be interpreted as reflecting the value of knowing a good
priority order on the hypotheses in H.

7.3

Minimum Description Length and Occamâ€™s Razor
Let H be a countable hypothesis class. Then, we can write H as a countable
S
union of singleton classes, namely, H = nâˆˆN {hn }. By Hoeffdingâ€™s inequality
(Lemma 4.5), each singleton class has the uniform convergence property with
rate mUC (, Î´) = log(2/Î´)
22 . Therefore, the function n given in Equation (7.1)
q
and the SRM rule becomes
becomes n (m, Î´) = log(2/Î´)
2m
"
#
r
âˆ’ log(w(n)) + log(2/Î´)
.
argmin LS (h) +
2m
hn âˆˆH
Equivalently, we can think of w as a function from H to [0, 1], and then the SRM
rule becomes
"
#
r
âˆ’ log(w(h)) + log(2/Î´)
argmin LS (h) +
.
2m
hâˆˆH
It follows that in this case, the prior knowledge is solely determined by the weight
we assign to each hypothesis. We assign higher weights to hypotheses that we
believe are more likely to be the correct one, and in the learning algorithm we
prefer hypotheses that have higher weights.
In this section we discuss a particular convenient way to define a weight function over H, which is derived from the length of descriptions given to hypotheses.
Having a hypothesis class, one can wonder about how we describe, or represent,
each hypothesis in the class. We naturally fix some description language. This
can be English, or a programming language, or some set of mathematical formulas. In any of these languages, a description consists of finite strings of symbols
(or characters) drawn from some fixed alphabet. We shall now formalize these
notions.
Let H be the hypothesis class we wish to describe. Fix some finite set Î£
of symbols (or â€œcharactersâ€), which we call the alphabet. For concreteness, we
let Î£ = {0, 1}. A string is a finite sequence of symbols from Î£; for example,
Ïƒ = (0, 1, 1, 1, 0) is a string of length 5. We denote by |Ïƒ| the length of a string.
The set of all finite length strings is denoted Î£âˆ— . A description language for H
is a function d : H â†’ Î£âˆ— , mapping each member h of H to a string d(h). d(h) is
called â€œthe description of h,â€ and its length is denoted by |h|.
We shall require that description languages be prefix-free; namely, for every
distinct h, h0 , d(h) is not a prefix of d(h0 ). That is, we do not allow that any
string d(h) is exactly the first |h| symbols of any longer string d(h0 ). Prefix-free
collections of strings enjoy the following combinatorial property:

90

Nonuniform Learnability

lemma 7.6 (Kraft Inequality)

If S âŠ† {0, 1}âˆ— is a prefix-free set of strings, then
X 1
â‰¤ 1.
2|Ïƒ|
ÏƒâˆˆS

Proof Define a probability distribution over the members of S as follows: Repeatedly toss an unbiased coin, with faces labeled 0 and 1, until the sequence
of outcomes is a member of S; at that point, stop. For each Ïƒ âˆˆ S, let P (Ïƒ)
be the probability that this process generates the string Ïƒ. Note that since S is
prefix-free, for every Ïƒ âˆˆ S, if the coin toss outcomes follow the bits of Ïƒ then
we will stop only once the sequence of outcomes equals Ïƒ. We therefore get that,
1
for every Ïƒ âˆˆ S, P (Ïƒ) = 2|Ïƒ|
. Since probabilities add up to at most 1, our proof
is concluded.
In light of Kraftâ€™s inequality, any prefix-free description language of a hypothesis class, H, gives rise to a weighting function w over that hypothesis class â€“ we
1
. This observation immediately yields the following:
will simply set w(h) = 2|h|
theorem 7.7 Let H be a hypothesis class and let d : H â†’ {0, 1}âˆ— be a prefixfree description language for H. Then, for every sample size, m, every confidence
parameter, Î´ > 0, and every probability distribution, D, with probability greater
than 1 âˆ’ Î´ over the choice of S âˆ¼ Dm we have that,
r
|h| + ln(2/Î´)
,
âˆ€h âˆˆ H, LD (h) â‰¤ LS (h) +
2m
where |h| is the length of d(h).
Proof

Choose w(h) = 1/2|h| , apply Theorem 7.4 with n (m, Î´) =

q

ln(2/Î´)
2m ,

and

|h|

note that ln(2 ) = |h| ln(2) < |h|.
As was the case with Theorem 7.4, this result suggests a learning paradigm
for H â€“ given a training
q set, S, search for a hypothesis h âˆˆ H that minimizes

. In particular, it suggests trading off empirical
the bound, LS (h) + |h|+ln(2/Î´)
2m
risk for saving description length. This yields the Minimum Description Length
learning paradigm.
Minimum Description Length (MDL)
prior knowledge:
H is a countable hypothesis class
H is described by a prefix-free language over {0, 1}
For every h âˆˆ H, |h| is the length of the representation of h
m
Î´ 
input: A training set S âˆ¼
 D , confidence
q
output: h âˆˆ argminhâˆˆH LS (h) + |h|+ln(2/Î´)
2m
Example 7.3 Let H be the class of all predictors that can be implemented using
some programming language, say, C++. Let us represent each program using the

7.3 Minimum Description Length and Occamâ€™s Razor

91

binary string obtained by running the gzip command on the program (this yields
a prefix-free description language over the alphabet {0, 1}). Then, |h| is simply
the length (in bits) of the output of gzip when running on the C++ program
corresponding to h.

7.3.1

Occamâ€™s Razor
Theorem 7.7 suggests that, having two hypotheses sharing the same empirical
risk, the true risk of the one that has shorter description can be bounded by a
lower value. Thus, this result can be viewed as conveying a philosophical message:
A short explanation (that is, a hypothesis that has a short length) tends to be more valid
than a long explanation.

This is a well known principle, called Occamâ€™s razor, after William of Ockham,
a 14th-century English logician, who is believed to have been the first to phrase
it explicitly. Here, we provide one possible justification to this principle. The
inequality of Theorem 7.7 shows that the more complex a hypothesis h is (in the
sense of having a longer description), the larger the sample size it has to fit to
guarantee that it has a small true risk, LD (h).
At a second glance, our Occam razor claim might seem somewhat problematic.
In the context in which the Occam razor principle is usually invoked in science,
the language according to which complexity is measured is a natural language,
whereas here we may consider any arbitrary abstract description language. Assume that we have two hypotheses such that |h0 | is much smaller than |h|. By
the preceding result, if both have the same error on a given training set, S, then
the true error of h may be much higher than the true error of h0 , so one should
prefer h0 over h. However, we could have chosen a different description language,
say, one that assigns a string of length 3 to h and a string of length 100000 to h0 .
Suddenly it looks as if one should prefer h over h0 . But these are the same h and
h0 for which we argued two sentences ago that h0 should be preferable. Where is
the catch here?
Indeed, there is no inherent generalizability difference between hypotheses.
The crucial aspect here is the dependency order between the initial choice of
language (or, preference over hypotheses) and the training set. As we know from
the basic Hoeffdingâ€™s bound (Equation (4.2)), if we commit to any hypothesis before seeing the data,
qthen we are guaranteed a rather small estimation error term

LD (h) â‰¤ LS (h) + ln(2/Î´)
2m . Choosing a description language (or, equivalently,
some weighting of hypotheses) is a weak form of committing to a hypothesis.
Rather than committing to a single hypothesis, we spread out our commitment
among many. As long as it is done independently of the training sample, our generalization bound holds. Just as the choice of a single hypothesis to be evaluated
by a sample can be arbitrary, so is the choice of description language.

92

Nonuniform Learnability

7.4

Other Notions of Learnability â€“ Consistency
The notion of learnability can be further relaxed by allowing the needed sample
sizes to depend not only on , Î´, and h but also on the underlying data-generating
probability distribution D (that is used to generate the training sample and to
determine the risk). This type of performance guarantee is captured by the notion
of consistency 1 of a learning rule.
definition 7.8 (Consistency) Let Z be a domain set, let P be a set of
probability distributions over Z, and let H be a hypothesis class. A learning rule A is consistent with respect to H and P if there exists a function
mCON
: (0, 1)2 Ã— H Ã— P â†’ N such that, for every , Î´ âˆˆ (0, 1), every h âˆˆ H, and
H
every D âˆˆ P, if m â‰¥ mNUL
H (, Î´, h, D) then with probability of at least 1 âˆ’ Î´ over
m
the choice of S âˆ¼ D it holds that
LD (A(S)) â‰¤ LD (h) + .
If P is the set of all distributions,2 we say that A is universally consistent with
respect to H.
The notion of consistency is, of course, a relaxation of our previous notion
of nonuniform learnability. Clearly if an algorithm nonuniformly learns a class
H it is also universally consistent for that class. The relaxation is strict in the
sense that there are consistent learning rules that are not successful nonuniform
learners. For example, the algorithm Memorize defined in Example 7.4 later is
universally consistent for the class of all binary classifiers over N. However, as
we have argued before, this class is not nonuniformly learnable.
Example 7.4 Consider the classification prediction algorithm Memorize defined
as follows. The algorithm memorizes the training examples, and, given a test
point x, it predicts the majority label among all labeled instances of x that exist
in the training sample (and some fixed default label if no instance of x appears
in the training set). It is possible to show (see Exercise 6) that the Memorize
algorithm is universally consistent for every countable domain X and a finite
label set Y (w.r.t. the zero-one loss).
Intuitively, it is not obvious that the Memorize algorithm should be viewed as a
learner, since it lacks the aspect of generalization, namely, of using observed data
to predict the labels of unseen examples. The fact that Memorize is a consistent
algorithm for the class of all functions over any countable domain set therefore
raises doubt about the usefulness of consistency guarantees. Furthermore, the
sharp-eyed reader may notice that the â€œbad learnerâ€ we introduced in Chapter 2,
1

2

In the literature, consistency is often defined using the notion of either convergence in
probability (corresponding to weak consistency) or almost sure convergence (corresponding
to strong consistency).
Formally, we assume that Z is endowed with some sigma algebra of subsets â„¦, and by â€œall
distributionsâ€ we mean all probability distributions that have â„¦ contained in their
associated family of measurable subsets.

7.5 Discussing the Different Notions of Learnability

93

which led to overfitting, is in fact the Memorize algorithm. In the next section
we discuss the significance of the different notions of learnability and revisit the
No-Free-Lunch theorem in light of the different definitions of learnability.

7.5

Discussing the Different Notions of Learnability
We have given three definitions of learnability and we now discuss their usefulness. As is usually the case, the usefulness of a mathematical definition depends
on what we need it for. We therefore list several possible goals that we aim to
achieve by defining learnability and discuss the usefulness of the different definitions in light of these goals.

What Is the Risk of the Learned Hypothesis?
The first possible goal of deriving performance guarantees on a learning algorithm is bounding the risk of the output predictor. Here, both PAC learning
and nonuniform learning give us an upper bound on the true risk of the learned
hypothesis based on its empirical risk. Consistency guarantees do not provide
such a bound. However, it is always possible to estimate the risk of the output
predictor using a validation set (as will be described in Chapter 11).

How Many Examples Are Required to Be as Good as the Best Hypothesis
in H?
When approaching a learning problem, a natural question is how many examples we need to collect in order to learn it. Here, PAC learning gives a crisp
answer. However, for both nonuniform learning and consistency, we do not know
in advance how many examples are required to learn H. In nonuniform learning
this number depends on the best hypothesis in H, and in consistency it also
depends on the underlying distribution. In this sense, PAC learning is the only
useful definition of learnability. On the flip side, one should keep in mind that
even if the estimation error of the predictor we learn is small, its risk may still
be large if H has a large approximation error. So, for the question â€œHow many
examples are required to be as good as the Bayes optimal predictor?â€ even PAC
guarantees do not provide us with a crisp answer. This reflects the fact that the
usefulness of PAC learning relies on the quality of our prior knowledge.
PAC guarantees also help us to understand what we should do next if our
learning algorithm returns a hypothesis with a large risk, since we can bound
the part of the error that stems from estimation error and therefore know how
much of the error is attributed to approximation error. If the approximation error
is large, we know that we should use a different hypothesis class. Similarly, if a
nonuniform algorithm fails, we can consider a different weighting function over
(subsets of) hypotheses. However, when a consistent algorithm fails, we have
no idea whether this is because of the estimation error or the approximation
error. Furthermore, even if we are sure we have a problem with the estimation

94

Nonuniform Learnability

error term, we do not know how many more examples are needed to make the
estimation error small.

How to Learn? How to Express Prior Knowledge?
Maybe the most useful aspect of the theory of learning is in providing an answer
to the question of â€œhow to learn.â€ The definition of PAC learning yields the
limitation of learning (via the No-Free-Lunch theorem) and the necessity of prior
knowledge. It gives us a crisp way to encode prior knowledge by choosing a
hypothesis class, and once this choice is made, we have a generic learning rule â€“
ERM. The definition of nonuniform learnability also yields a crisp way to encode
prior knowledge by specifying weights over (subsets of) hypotheses of H. Once
this choice is made, we again have a generic learning rule â€“ SRM. The SRM rule
is also advantageous in model selection tasks, where prior knowledge is partial.
We elaborate on model selection in Chapter 11 and here we give a brief example.
Consider the problem of fitting a one dimensional polynomial to data; namely,
our goal is to learn a function, h : R â†’ R, and as prior knowledge we consider
the hypothesis class of polynomials. However, we might be uncertain regarding
which degree d would give the best results for our data set: A small degree might
not fit the data well (i.e., it will have a large approximation error), whereas a
high degree might lead to overfitting (i.e., it will have a large estimation error).
In the following we depict the result of fitting a polynomial of degrees 2, 3, and
10 to the same training set.

degree 2

degree 3

degree 10

It is easy to see that the empirical risk decreases as we enlarge the degree.
Therefore, if we choose H to be the class of all polynomials up to degree 10 then
the ERM rule with respect to this class would output a 10 degree polynomial
and would overfit. On the other hand, if we choose too small a hypothesis class,
say, polynomials up to degree 2, then the ERM would suffer from underfitting
(i.e., a large approximation error). In contrast, we can use the SRM rule on the
set of all polynomials, while ordering subsets of H according to their degree, and
this will yield a 3rd degree polynomial since the combination of its empirical
risk and the bound on its estimation error is the smallest. In other words, the
SRM rule enables us to select the right model on the basis of the data itself. The
price we pay for this flexibility (besides a slight increase of the estimation error
relative to PAC learning w.r.t. the optimal degree) is that we do not know in

7.5 Discussing the Different Notions of Learnability

95

advance how many examples are needed to compete with the best hypothesis in
H.
Unlike the notions of PAC learnability and nonuniform learnability, the definition of consistency does not yield a natural learning paradigm or a way to encode
prior knowledge. In fact, in many cases there is no need for prior knowledge at
all. For example, we saw that even the Memorize algorithm, which intuitively
should not be called a learning algorithm, is a consistent algorithm for any class
defined over a countable domain and a finite label set. This hints that consistency
is a very weak requirement.

Which Learning Algorithm Should We Prefer?
One may argue that even though consistency is a weak requirement, it is desirable
that a learning algorithm will be consistent with respect to the set of all functions
from X to Y, which gives us a guarantee that for enough training examples, we
will always be as good as the Bayes optimal predictor. Therefore, if we have
two algorithms, where one is consistent and the other one is not consistent, we
should prefer the consistent algorithm. However, this argument is problematic for
two reasons. First, maybe it is the case that for most â€œnaturalâ€ distributions we
will observe in practice that the sample complexity of the consistent algorithm
will be so large so that in every practical situation we will not obtain enough
examples to enjoy this guarantee. Second, it is not very hard to make any PAC
or nonuniform learner consistent with respect to the class of all functions from
X to Y. Concretely, consider a countable domain, X , a finite label set Y, and
a hypothesis class, H, of functions from X to Y. We can make any nonuniform
learner for H be consistent with respect to the class of all classifiers from X to Y
using the following simple trick: Upon receiving a training set, we will first run
the nonuniform learner over the training set, and then we will obtain a bound
on the true risk of the learned predictor. If this bound is small enough we are
done. Otherwise, we revert to the Memorize algorithm. This simple modification
makes the algorithm consistent with respect to all functions from X to Y. Since
it is easy to make any algorithm consistent, it may not be wise to prefer one
algorithm over the other just because of consistency considerations.

7.5.1

The No-Free-Lunch Theorem Revisited
Recall that the No-Free-Lunch theorem (Theorem 5.1 from Chapter 5) implies
that no algorithm can learn the class of all classifiers over an infinite domain.
In contrast, in this chapter we saw that the Memorize algorithm is consistent
with respect to the class of all classifiers over a countable infinite domain. To
understand why these two statements do not contradict each other, let us first
recall the formal statement of the No-Free-Lunch theorem.
Let X be a countable infinite domain and let Y = {Â±1}. The No-Free-Lunch
theorem implies the following: For any algorithm, A, and a training set size, m,
there exist a distribution over X and a function h? : X â†’ Y, such that if A

96

Nonuniform Learnability

will get a sample of m i.i.d. training examples, labeled by h? , then A is likely to
return a classifier with a larger error.
The consistency of Memorize implies the following: For every distribution over
X and a labeling function h? : X â†’ Y, there exists a training set size m (that
depends on the distribution and on h? ) such that if Memorize receives at least
m examples it is likely to return a classifier with a small error.
We see that in the No-Free-Lunch theorem, we first fix the training set size,
and then find a distribution and a labeling function that are bad for this training
set size. In contrast, in consistency guarantees, we first fix the distribution and
the labeling function, and only then do we find a training set size that suffices
for learning this particular distribution and labeling function.

7.6

Summary
We introduced nonuniform learnability as a relaxation of PAC learnability and
consistency as a relaxation of nonuniform learnability. This means that even
classes of infinite VC-dimension can be learnable, in some weaker sense of learnability. We discussed the usefulness of the different definitions of learnability.
For hypothesis classes that are countable, we can apply the Minimum Description Length scheme, where hypotheses with shorter descriptions are preferred,
following the principle of Occamâ€™s razor. An interesting example is the hypothesis class of all predictors we can implement in C++ (or any other programming
language), which we can learn (nonuniformly) using the MDL scheme.
Arguably, the class of all predictors we can implement in C++ is a powerful
class of functions and probably contains all that we can hope to learn in practice. The ability to learn this class is impressive, and, seemingly, this chapter
should have been the last chapter of this book. This is not the case, because of
the computational aspect of learning: that is, the runtime needed to apply the
learning rule. For example, to implement the MDL paradigm with respect to
all C++ programs, we need to perform an exhaustive search over all C++ programs, which will take forever. Even the implementation of the ERM paradigm
with respect to all C++ programs of description length at most 1000 bits requires an exhaustive search over 21000 hypotheses. While the sample complexity
, the runtime is â‰¥ 21000 . This is a huge
of learning this class is just 1000+log(2/Î´)
2
number â€“ much larger than the number of atoms in the visible universe. In the
next chapter we formally define the computational complexity of learning. In the
second part of this book we will study hypothesis classes for which the ERM or
SRM schemes can be implemented efficiently.

7.7 Bibliographic Remarks

7.7

97

Bibliographic Remarks
Our definition of nonuniform learnability is related to the definition of an Occamalgorithm in Blumer, Ehrenfeucht, Haussler & Warmuth (1987). The concept of
SRM is due to (Vapnik & Chervonenkis 1974, Vapnik 1995). The concept of MDL
is due to (Rissanen 1978, Rissanen 1983). The relation between SRM and MDL
is discussed in Vapnik (1995). These notions are also closely related to the notion
of regularization (e.g. Tikhonov (1943)). We will elaborate on regularization in
the second part of this book.
The notion of consistency of estimators dates back to Fisher (1922). Our presentation of consistency follows Steinwart & Christmann (2008), who also derived
several no-free-lunch theorems.

7.8

Exercises
1. Prove that for any finite class H, and any description language d : H â†’
{0, 1}âˆ— , the VC-dimension of H is at most 2 sup{|d(h)| : h âˆˆ H} â€“ the maximum description length of a predictor in H. Furthermore, if d is a prefix-free
description then VCdim(H) â‰¤ sup{|d(h)| : h âˆˆ H}.
2. Let H = {hn : n âˆˆ N} be an infinite countable hypothesis class for binary
classification. Show that it is impossible to assign weights to the hypotheses
in H such that
â€¢ H could be learnt nonuniformly using these weights. That is, the weighting
P
function w : H â†’ [0, 1] should satisfy the condition hâˆˆH w(h) â‰¤ 1.
â€¢ The weights would be monotonically nondecreasing. That is, if i < j, then
w(hi ) â‰¤ w(hj ).
Sâˆž
3. â€¢ Consider a hypothesis class H = n=1 Hn , where for every n âˆˆ N, Hn is
P
finite. Find a weighting function w : H â†’ [0, 1] such that hâˆˆH w(h) â‰¤
1 and so that for all h âˆˆ H, w(h) is determined by n(h) = min{n : h âˆˆ
Hn } and by |Hn(h) |.
â€¢ (*) Define such a function w when for all n Hn is countable (possibly
infinite).
4. Let H be some hypothesis class. For any h âˆˆ H, let |h| denote the description
length of h, according to some fixed description language. Consider the MDL
learning paradigm in which the algorithm returns:
#
"
r
|h| + ln(2/Î´)
,
hS âˆˆ arg min LS (h) +
hâˆˆH
2m
where S is a sample of size m. For any B > 0, let HB = {h âˆˆ H : |h| â‰¤ B},
and define
hâˆ—B = arg min LD (h).
hâˆˆHB

98

Nonuniform Learnability

Prove a bound on LD (hS )âˆ’LD (hâˆ—B ) in terms of B, the confidence parameter
Î´, and the size of the training set m.
â€¢ Note: Such bounds are known as oracle inequalities in the literature: We
wish to estimate how good we are compared to a reference classifier (or
â€œoracleâ€) hâˆ—B .
5. In this question we wish to show a No-Free-Lunch result for nonuniform learnability: namely, that, over any infinite domain, the class of all functions is not
learnable even under the relaxed nonuniform variation of learning.
Recall that an algorithm, A, nonuniformly learns a hypothesis class H if
2
there exists a function mNUL
H : (0, 1) Ã— H â†’ N such that, for every , Î´ âˆˆ (0, 1)
and for every h âˆˆ H, if m â‰¥ mNUL
H (, Î´, h) then for every distribution D, with
probability of at least 1 âˆ’ Î´ over the choice of S âˆ¼ Dm , it holds that
LD (A(S)) â‰¤ LD (h) + .
If such an algorithm exists then we say that H is nonuniformly learnable.
1. Let A be a nonuniform learner for a class H. For each n âˆˆ N define HnA =
{h âˆˆ H : mNUL (0.1, 0.1, h) â‰¤ n}. Prove that each such class Hn has a finite
VC-dimension.
2. Prove that if a class H is nonuniformly learnable then there are classes Hn
S
so that H = nâˆˆN Hn and, for every n âˆˆ N, VCdim(Hn ) is finite.
3. Let H be a class that shatters an infinite set. Then, for every sequence
S
of classes (Hn : n âˆˆ N) such that H = nâˆˆN Hn , there exists some n for
which VCdim(Hn ) = âˆž.
Hint: Given a class H that shatters some infinite set K, and a sequence of
classes (Hn : n âˆˆ N), each having a finite VC-dimension, start by defining
subsets Kn âŠ† K such that, for all n, |Kn | > VCdim(Hn ) and for any
n 6= m, Kn âˆ© Km = âˆ…. Now, pick for each such Kn a function fn : Kn â†’
{0, 1} so that no h âˆˆ Hn agrees with fn on the domain Kn . Finally, define

S
f : X â†’ {0, 1} by combining these fn â€™s and prove that f âˆˆ H \ nâˆˆN Hn .
4. Construct a class H1 of functions from the unit interval [0, 1] to {0, 1} that
is nonuniformly learnable but not PAC learnable.
5. Construct a class H2 of functions from the unit interval [0, 1] to {0, 1} that
is not nonuniformly learnable.
6. In this question we wish to show that the algorithm Memorize is a consistent
learner for every class of (binary-valued) functions over any countable domain.
Let X be a countable domain and let D be a probability distribution over X .
1. Let {xi : i âˆˆ N} be an enumeration of the elements of X so that for all
i â‰¤ j, D({xi }) â‰¤ D({xj }). Prove that
X
lim
D({xi }) = 0.
nâ†’âˆž

iâ‰¥n

2. Given any  > 0 prove that there exists D > 0 such that
D({x âˆˆ X : D({x}) < D }) < .

7.8 Exercises

99

3. Prove that for every Î· > 0, if n is such that D({xi }) < Î· for all i > n, then
for every m âˆˆ N,
P

Sâˆ¼D m

[âˆƒxi : (D({xi }) > Î· and xi âˆˆ
/ S)] â‰¤ neâˆ’Î·m .

4. Conclude that if X is countable then for every probability distribution D
over X there exists a function mD : (0, 1) Ã— (0, 1) â†’ N such that for every
, Î´ > 0 if m > mD (, Î´) then
P

Sâˆ¼D m

[D({x : x âˆˆ
/ S}) > ] < Î´.

5. Prove that Memorize is a consistent learner for every class of (binaryvalued) functions over any countable domain.

8

The Runtime of Learning

So far in the book we have studied the statistical perspective of learning, namely,
how many samples are needed for learning. In other words, we focused on the
amount of information learning requires. However, when considering automated
learning, computational resources also play a major role in determining the complexity of a task: that is, how much computation is involved in carrying out a
learning task. Once a sufficient training sample is available to the learner, there
is some computation to be done to extract a hypothesis or figure out the label of
a given test instance. These computational resources are crucial in any practical
application of machine learning. We refer to these two types of resources as the
sample complexity and the computational complexity. In this chapter, we turn
our attention to the computational complexity of learning.
The computational complexity of learning should be viewed in the wider context of the computational complexity of general algorithmic tasks. This area has
been extensively investigated; see, for example, (Sipser 2006). The introductory
comments that follow summarize the basic ideas of that general theory that are
most relevant to our discussion.
The actual runtime (in seconds) of an algorithm depends on the specific machine the algorithm is being implemented on (e.g., what the clock rate of the
machineâ€™s CPU is). To avoid dependence on the specific machine, it is common
to analyze the runtime of algorithms in an asymptotic sense. For example, we
say that the computational complexity of the merge-sort algorithm, which sorts
a list of n items, is O(n log(n)). This implies that we can implement the algorithm on any machine that satisfies the requirements of some accepted abstract
model of computation, and the actual runtime in seconds will satisfy the following: there exist constants c and n0 , which can depend on the actual machine,
such that, for any value of n > n0 , the runtime in seconds of sorting any n items
will be at most c n log(n). It is common to use the term feasible or efficiently
computable for tasks that can be performed by an algorithm whose running time
is O(p(n)) for some polynomial function p. One should note that this type of
analysis depends on defining what is the input size n of any instance to which
the algorithm is expected to be applied. For â€œpurely algorithmicâ€ tasks, as discussed in the common computational complexity literature, this input size is
clearly defined; the algorithm gets an input instance, say, a list to be sorted, or
an arithmetic operation to be calculated, which has a well defined size (say, the
c 2014 by Shai Shalev-Shwartz and Shai Ben-David
Understanding Machine Learning, 
Published 2014 by Cambridge University Press.
Personal use only. Not for distribution. Do not post.
Please link to http://www.cs.huji.ac.il/~shais/UnderstandingMachineLearning

8.1 Computational Complexity of Learning

101

number of bits in its representation). For machine learning tasks, the notion of
an input size is not so clear. An algorithm aims to detect some pattern in a data
set and can only access random samples of that data.
We start the chapter by discussing this issue and define the computational
complexity of learning. For advanced students, we also provide a detailed formal
definition. We then move on to consider the computational complexity of implementing the ERM rule. We first give several examples of hypothesis classes
where the ERM rule can be efficiently implemented, and then consider some
cases where, although the class is indeed efficiently learnable, ERM implementation is computationally hard. It follows that hardness of implementing ERM
does not imply hardness of learning. Finally, we briefly discuss how one can show
hardness of a given learning task, namely, that no learning algorithm can solve
it efficiently.

8.1

Computational Complexity of Learning
Recall that a learning algorithm has access to a domain of examples, Z, a hypothesis class, H, a loss function, `, and a training set of examples from Z that
are sampled i.i.d. according to an unknown distribution D. Given parameters
, Î´, the algorithm should output a hypothesis h such that with probability of
at least 1 âˆ’ Î´,
LD (h) â‰¤ min
LD (h0 ) + .
0
h âˆˆH

As mentioned before, the actual runtime of an algorithm in seconds depends on
the specific machine. To allow machine independent analysis, we use the standard
approach in computational complexity theory. First, we rely on a notion of an
abstract machine, such as a Turing machine (or a Turing machine over the reals
(Blum, Shub & Smale 1989)). Second, we analyze the runtime in an asymptotic
sense, while ignoring constant factors, thus the specific machine is not important
as long as it implements the abstract machine. Usually, the asymptote is with
respect to the size of the input to the algorithm. For example, for the merge-sort
algorithm mentioned before, we analyze the runtime as a function of the number
of items that need to be sorted.
In the context of learning algorithms, there is no clear notion of â€œinput size.â€
One might define the input size to be the size of the training set the algorithm
receives, but that would be rather pointless. If we give the algorithm a very
large number of examples, much larger than the sample complexity of the learning problem, the algorithm can simply ignore the extra examples. Therefore, a
larger training set does not make the learning problem more difficult, and, consequently, the runtime available for a learning algorithm should not increase as
we increase the size of the training set. Just the same, we can still analyze the
runtime as a function of natural parameters of the problem such as the target
accuracy, the confidence of achieving that accuracy, the dimensionality of the

102

The Runtime of Learning

domain set, or some measures of the complexity of the hypothesis class with
which the algorithmâ€™s output is compared.
To illustrate this, consider a learning algorithm for the task of learning axis
aligned rectangles. A specific problem of learning axis aligned rectangles is derived by specifying , Î´, and the dimension of the instance space. We can define a
sequence of problems of the type â€œrectangles learningâ€ by fixing , Î´ and varying
the dimension to be d = 2, 3, 4, . . .. We can also define another sequence of â€œrectangles learningâ€ problems by fixing d, Î´ and varying the target accuracy to be
 = 21 , 13 , . . .. One can of course choose other sequences of such problems. Once
a sequence of the problems is fixed, one can analyze the asymptotic runtime as
a function of variables of that sequence.
Before we introduce the formal definition, there is one more subtlety we need
to tackle. On the basis of the preceding, a learning algorithm can â€œcheat,â€ by
transferring the computational burden to the output hypothesis. For example,
the algorithm can simply define the output hypothesis to be the function that
stores the training set in its memory, and whenever it gets a test example x
it calculates the ERM hypothesis on the training set and applies it on x. Note
that in this case, our algorithm has a fixed output (namely, the function that
we have just described) and can run in constant time. However, learning is still
hard â€“ the hardness is now in implementing the output classifier to obtain a
label prediction. To prevent this â€œcheating,â€ we shall require that the output of
a learning algorithm must be applied to predict the label of a new example in
time that does not exceed the runtime of training (that is, computing the output
classifier from the input training sample). In the next subsection the advanced
reader may find a formal definition of the computational complexity of learning.

8.1.1

Formal Definition*
The definition that follows relies on a notion of an underlying abstract machine,
which is usually either a Turing machine or a Turing machine over the reals. We
will measure the computational complexity of an algorithm using the number of
â€œoperationsâ€ it needs to perform, where we assume that for any machine that
implements the underlying abstract machine there exists a constant c such that
any such â€œoperationâ€ can be performed on the machine using c seconds.
definition 8.1 (The Computational Complexity of a Learning Algorithm)
We define the complexity of learning in two steps. First we consider the computational complexity of a fixed learning problem (determined by a triplet (Z, H, `)
â€“ a domain set, a benchmark hypothesis class, and a loss function). Then, in the
second step we consider the rate of change of that complexity along a sequence
of such tasks.
1. Given a function f : (0, 1)2 â†’ N, a learning task (Z, H, `), and a learning
algorithm, A, we say that A solves the learning task in time O(f ) if there
exists some constant number c, such that for every probability distribution D

8.2 Implementing the ERM Rule

103

over Z, and input , Î´ âˆˆ (0, 1), when A has access to samples generated i.i.d.
by D,
â€¢ A terminates after performing at most cf (, Î´) operations
â€¢ The output of A, denoted hA , can be applied to predict the label of a new
example while performing at most cf (, Î´) operations
â€¢ The output of A is probably approximately correct; namely, with probability of at least 1 âˆ’ Î´ (over the random samples A receives), LD (hA ) â‰¤
minh0 âˆˆH LD (h0 ) + 
2. Consider a sequence of learning problems, (Zn , Hn , `n )âˆž
n=1 , where problem n
is defined by a domain Zn , a hypothesis class Hn , and a loss function `n .
Let A be a learning algorithm designed for solving learning problems of
this form. Given a function g : N Ã— (0, 1)2 â†’ N, we say that the runtime of
A with respect to the preceding sequence is O(g), if for all n, A solves the
problem (Zn , Hn , `n ) in time O(fn ), where fn : (0, 1)2 â†’ N is defined by
fn (, Î´) = g(n, , Î´).
We say that A is an efficient algorithm with respect to a sequence (Zn , Hn , `n )
if its runtime is O(p(n, 1/, 1/Î´)) for some polynomial p.
From this definition we see that the question whether a general learning problem can be solved efficiently depends on how it can be broken into a sequence
of specific learning problems. For example, consider the problem of learning a
finite hypothesis class. As we showed in previous chapters, the ERM rule over
H is guaranteed to (, Î´)-learn H if the number of training examples is order of
mH (, Î´) = log(|H|/Î´)/2 . Assuming that the evaluation of a hypothesis on an
example takes a constant time, it is possible to implement the ERM rule in time
O(|H| mH (, Î´)) by performing an exhaustive search over H with a training set
of size mH (, Î´). For any fixed finite H, the exhaustive search algorithm runs
in polynomial time. Furthermore, if we define a sequence of problems in which
|Hn | = n, then the exhaustive search is still considered to be efficient. However, if
we define a sequence of problems for which |Hn | = 2n , then the sample complexity is still polynomial in n but the computational complexity of the exhaustive
search algorithm grows exponentially with n (thus, rendered inefficient).

8.2

Implementing the ERM Rule
Given a hypothesis class H, the ERMH rule is maybe the most natural learning
paradigm. Furthermore, for binary classification problems we saw that if learning
is at all possible, it is possible with the ERM rule. In this section we discuss the
computational complexity of implementing the ERM rule for several hypothesis
classes.
Given a hypothesis class, H, a domain set Z, and a loss function `, the corresponding ERMH rule can be defined as follows:

104

The Runtime of Learning

m
On a finite input
P sample S âˆˆ Z output some h âˆˆ H that minimizes the empirical loss,
1
LS (h) = |S| zâˆˆS `(h, z).

This section studies the runtime of implementing the ERM rule for several
examples of learning tasks.

8.2.1

Finite Classes
Limiting the hypothesis class to be a finite class may be considered as a reasonably mild restriction. For example, H can be the set of all predictors that can be
implemented by a C++ program written in at most 10000 bits of code. Other examples of useful finite classes are any hypothesis class that can be parameterized
by a finite number of parameters, where we are satisfied with a representation
of each of the parameters using a finite number of bits, for example, the class of
axis aligned rectangles in the Euclidean space, Rd , when the parameters defining
any given rectangle are specified up to some limited precision.
As we have shown in previous chapters, the sample complexity of learning a
finite class is upper bounded by mH (, Î´) = c log(c|H|/Î´)/c , where c = 1 in
the realizable case and c = 2 in the nonrealizable case. Therefore, the sample
complexity has a mild dependence on the size of H. In the example of C++
programs mentioned before, the number of hypotheses is 210,000 but the sample
complexity is only c(10, 000 + log(c/Î´))/c .
A straightforward approach for implementing the ERM rule over a finite hypothesis class is to perform an exhaustive search. That is, for each h âˆˆ H we
calculate the empirical risk, LS (h), and return a hypothesis that minimizes
the empirical risk. Assuming that the evaluation of `(h, z) on a single example takes a constant amount of time, k, the runtime of this exhaustive search
becomes k|H|m, where m is the size of the training set. If we let m to be the
upper bound on the sample complexity mentioned, then the runtime becomes
k|H|c log(c|H|/Î´)/c .
The linear dependence of the runtime on the size of H makes this approach
inefficient (and unrealistic) for large classes. Formally, if we define a sequence of
problems (Zn , Hn , `n )âˆž
n=1 such that log(|Hn |) = n, then the exhaustive search
approach yields an exponential runtime. In the example of C++ programs, if Hn
is the set of functions that can be implemented by a C++ program written in
at most n bits of code, then the runtime grows exponentially with n, implying
that the exhaustive search approach is unrealistic for practical use. In fact, this
problem is one of the reasons we are dealing with other hypothesis classes, like
classes of linear predictors, which we will encounter in the next chapter, and not
just focusing on finite classes.
It is important to realize that the inefficiency of one algorithmic approach
(such as the exhaustive search) does not yet imply that no efficient ERM implementation exists. Indeed, we will show examples in which the ERM rule can be
implemented efficiently.

8.2 Implementing the ERM Rule

8.2.2

105

Axis Aligned Rectangles
Let Hn be the class of axis aligned rectangles in Rn , namely,
Hn = {h(a1 ,...,an ,b1 ,...,bn ) : âˆ€i, ai â‰¤ bi }
where
h(a1 ,...,an ,b1 ,...,bn ) (x, y) =

(
1
0

if âˆ€i, xi âˆˆ [ai , bi ]
otherwise

(8.1)

Efficiently Learnable in the Realizable Case
Consider implementing the ERM rule in the realizable case. That is, we are given
a training set S = (x1 , y1 ), . . . , (xm , ym ) of examples, such that there exists an
axis aligned rectangle, h âˆˆ Hn , for which h(xi ) = yi for all i. Our goal is to find
such an axis aligned rectangle with a zero training error, namely, a rectangle
that is consistent with all the labels in S.
We show later that this can be done in time O(nm). Indeed, for each i âˆˆ [n],
set ai = min{xi : (x, 1) âˆˆ S} and bi = max{xi : (x, 1) âˆˆ S}. In words, we take
ai to be the minimal value of the iâ€™th coordinate of a positive example in S and
bi to be the maximal value of the iâ€™th coordinate of a positive example in S.
It is easy to verify that the resulting rectangle has zero training error and that
the runtime of finding each ai and bi is O(m). Hence, the total runtime of this
procedure is O(nm).

Not Efficiently Learnable in the Agnostic Case
In the agnostic case, we do not assume that some hypothesis h perfectly predicts
the labels of all the examples in the training set. Our goal is therefore to find
h that minimizes the number of examples for which yi 6= h(xi ). It turns out
that for many common hypothesis classes, including the classes of axis aligned
rectangles we consider here, solving the ERM problem in the agnostic setting is
NP-hard (and, in most cases, it is even NP-hard to find some h âˆˆ H whose error
is no more than some constant c > 1 times that of the empirical risk minimizer
in H). That is, unless P = NP, there is no algorithm whose running time is
polynomial in m and n that is guaranteed to find an ERM hypothesis for these
problems (Ben-David, Eiron & Long 2003).
On the other hand, it is worthwhile noticing that, if we fix one specific hypothesis class, say, axis aligned rectangles in some fixed dimension, n, then there exist
efficient learning algorithms for this class. In other words, there are successful
agnostic PAC learners that run in time polynomial in 1/ and 1/Î´ (but their
dependence on the dimension n is not polynomial).
To see this, recall the implementation of the ERM rule we presented for the
realizable case, from which it follows that an axis aligned rectangle is determined
by at most 2n examples. Therefore, given a training set of size m, we can perform an exhaustive search over all subsets of the training set of size at most 2n
examples and construct a rectangle from each such subset. Then, we can pick

106

The Runtime of Learning

the rectangle with the minimal training error. This procedure is guaranteed to
find an ERM hypothesis, and the runtime of the procedure is mO(n) . It follows
that if n is fixed, the runtime is polynomial in the sample size. This does not
contradict the aforementioned hardness result, since there we argued that unless
P=NP one cannot have an algorithm whose dependence on the dimension n is
polynomial as well.

8.2.3

Boolean Conjunctions
A Boolean conjunction is a mapping from X = {0, 1}n to Y = {0, 1} that can be
expressed as a proposition formula of the form xi1 âˆ§ . . . âˆ§ xik âˆ§ Â¬xj1 âˆ§ . . . âˆ§ Â¬xjr ,
for some indices i1 , . . . , ik , j1 , . . . , jr âˆˆ [n]. The function that such a proposition
formula defines is
h(x) =

(
1
0

if xi1 = Â· Â· Â· = xik = 1 and xj1 = Â· Â· Â· = xjr = 0
otherwise

n
n
Let HC
be the class of all Boolean conjunctions over {0, 1}n . The size of HC
is
n
at most 3 + 1 (since in a conjunction formula, each element of x either appears,
or appears with a negation sign, or does not appear at all, and we also have the
n
using the
all negative formula). Hence, the sample complexity of learning HC
ERM rule is at most n log(3/Î´)/.

Efficiently Learnable in the Realizable Case
n
Next, we show that it is possible to solve the ERM problem for HC
in time
polynomial in n and m. The idea is to define an ERM conjunction by including
in the hypothesis conjunction all the literals that do not contradict any positively
labeled example. Let v1 , . . . , vm+ be all the positively labeled instances in the
input sample S. We define, by induction on i â‰¤ m+ , a sequence of hypotheses
(or conjunctions). Let h0 be the conjunction of all possible literals. That is,
h0 = x1 âˆ§ Â¬x1 âˆ§ x2 âˆ§ . . . âˆ§ xn âˆ§ Â¬xn . Note that h0 assigns the label 0 to all the
elements of X . We obtain hi+1 by deleting from the conjunction hi all the literals
that are not satisfied by vi+1 . The algorithm outputs the hypothesis hm+ . Note
that hm+ labels positively all the positively labeled examples in S. Furthermore,
for every i â‰¤ m+ , hi is the most restrictive conjunction that labels v1 , . . . , vi
positively. Now, since we consider learning in the realizable setup, there exists
n
a conjunction hypothesis, f âˆˆ HC
, that is consistent with all the examples in
S. Since hm+ is the most restrictive conjunction that labels positively all the
positively labeled members of S, any instance labeled 0 by f is also labeled 0 by
hm+ . It follows that hm+ has zero training error (w.r.t. S), and is therefore a
legal ERM hypothesis. Note that the running time of this algorithm is O(mn).

8.3 Efficiently Learnable, but Not by a Proper ERM

107

Not Efficiently Learnable in the Agnostic Case
As in the case of axis aligned rectangles, unless P = NP, there is no algorithm
whose running time is polynomial in m and n that guaranteed to find an ERM
hypothesis for the class of Boolean conjunctions in the unrealizable case.

8.2.4

Learning 3-Term DNF
We next show that a slight generalization of the class of Boolean conjunctions
leads to intractability of solving the ERM problem even in the realizable case.
Consider the class of 3-term disjunctive normal form formulae (3-term DNF).
The instance space is X = {0, 1}n and each hypothesis is represented by the
Boolean formula of the form h(x) = A1 (x) âˆ¨ A2 (x) âˆ¨ A3 (x), where each Ai (x) is
a Boolean conjunction (as defined in the previous section). The output of h(x) is
1 if either A1 (x) or A2 (x) or A3 (x) outputs the label 1. If all three conjunctions
output the label 0 then h(x) = 0.
n
Let H3DNF
be the hypothesis class of all such 3-term DNF formulae. The size
n
n
of H3DNF is at most 33n . Hence, the sample complexity of learning H3DNF
using
the ERM rule is at most 3n log(3/Î´)/.
However, from the computational perspective, this learning problem is hard.
It has been shown (see (Pitt & Valiant 1988, Kearns et al. 1994)) that unless
RP = NP, there is no polynomial time algorithm that properly learns a sequence
of 3-term DNF learning problems in which the dimension of the nâ€™th problem is
n. By â€œproperlyâ€ we mean that the algorithm should output a hypothesis that is
a 3-term DNF formula. In particular, since ERMHn3DN F outputs a 3-term DNF
formula it is a proper learner and therefore it is hard to implement it. The proof
uses a reduction of the graph 3-coloring problem to the problem of PAC learning
3-term DNF. The detailed technique is given in Exercise 3. See also (Kearns &
Vazirani 1994, Section 1.4).

8.3

Efficiently Learnable, but Not by a Proper ERM
In the previous section we saw that it is impossible to implement the ERM rule
n
efficiently for the class H3DNF
of 3-DNF formulae. In this section we show that it
is possible to learn this class efficiently, but using ERM with respect to a larger
class.

Representation Independent Learning Is Not Hard
Next we show that it is possible to learn 3-term DNF formulae efficiently. There
is no contradiction to the hardness result mentioned in the previous section as we
now allow â€œrepresentation independentâ€ learning. That is, we allow the learning
algorithm to output a hypothesis that is not a 3-term DNF formula. The basic idea is to replace the original hypothesis class of 3-term DNF formula with
a larger hypothesis class so that the new class is easily learnable. The learning

108

The Runtime of Learning

algorithm might return a hypothesis that does not belong to the original hypothesis class; hence the name â€œrepresentation independentâ€ learning. We emphasize
that in most situations, returning a hypothesis with good predictive ability is
what we are really interested in doing.
We start by noting that because âˆ¨ distributes over âˆ§, each 3-term DNF formula
can be rewritten as
^
A1 âˆ¨ A2 âˆ¨ A3 =
(u âˆ¨ v âˆ¨ w)
uâˆˆA1 ,vâˆˆA2 ,wâˆˆA3
3

Next, let us define: Ïˆ : {0, 1}n â†’ {0, 1}(2n) such that for each triplet of literals
u, v, w there is a variable in the range of Ïˆ indicating if u âˆ¨ v âˆ¨ w is true or false.
3
So, for each 3-DNF formula over {0, 1}n there is a conjunction over {0, 1}(2n) ,
with the same truth table. Since we assume that the data is realizable, we can
3
solve the ERM problem with respect to the class of conjunctions over {0, 1}(2n) .
Furthermore, the sample complexity of learning the class of conjunctions in the
higher dimensional space is at most n3 log(1/Î´)/. Thus, the overall runtime of
this approach is polynomial in n.
Intuitively, the idea is as follows. We started with a hypothesis class for which
learning is hard. We switched to another representation where the hypothesis
class is larger than the original class but has more structure, which allows for a
more efficient ERM search. In the new representation, solving the ERM problem
is easy.
3

(2 n )

0, 1}
ver {
o
s
n
nctio
conju

3-term-DNF formulae over {0, 1}n

8.4

Hardness of Learning*
We have just demonstrated that the computational hardness of implementing
ERMH does not imply that such a class H is not learnable. How can we prove
that a learning problem is computationally hard?
One approach is to rely on cryptographic assumptions. In some sense, cryptography is the opposite of learning. In learning we try to uncover some rule
underlying the examples we see, whereas in cryptography, the goal is to make
sure that nobody will be able to discover some secret, in spite of having access

8.4 Hardness of Learning*

109

to some partial information about it. On that high level intuitive sense, results
about the cryptographic security of some system translate into results about
the unlearnability of some corresponding task. Regrettably, currently one has no
way of proving that a cryptographic protocol is not breakable. Even the common
assumption of P 6= NP does not suffice for that (although it can be shown to
be necessary for most common cryptographic scenarios). The common approach
for proving that cryptographic protocols are secure is to start with some cryptographic assumptions. The more these are used as a basis for cryptography, the
stronger is our belief that they really hold (or, at least, that algorithms that will
refute them are hard to come by).
We now briefly describe the basic idea of how to deduce hardness of learnability from cryptographic assumptions. Many cryptographic systems rely on the
assumption that there exists a one way function. Roughly speaking, a one way
function is a function f : {0, 1}n â†’ {0, 1}n (more formally, it is a sequence of
functions, one for each dimension n) that is easy to compute but is hard to invert. More formally, f can be computed in time poly(n) but for any randomized
polynomial time algorithm A, and for every polynomial p(Â·),
P[f (A(f (x))) = f (x)] <

1
p(n) ,

where the probability is taken over a random choice of x according to the uniform
distribution over {0, 1}n and the randomness of A.
A one way function, f , is called trapdoor one way function if, for some polynomial function p, for every n there exists a bit-string sn (called a secret key) of
length â‰¤ p(n), such that there is a polynomial time algorithm that, for every n
and every x âˆˆ {0, 1}n , on input (f (x), sn ) outputs x. In other words, although
f is hard to invert, once one has access to its secret key, inverting f becomes
feasible. Such functions are parameterized by their secret key.
Now, let Fn be a family of trapdoor functions over {0, 1}n that can be calculated by some polynomial time algorithm. That is, we fix an algorithm that given
a secret key (representing one function in Fn ) and an input vector, it calculates
the value of the function corresponding to the secret key on the input vector in
polynomial time. Consider the task of learning the class of the corresponding
inverses, HFn = {f âˆ’1 : f âˆˆ Fn }. Since each function in this class can be inverted
by some secret key sn of size polynomial in n, the class HFn can be parameterized by these keys and its size is at most 2p(n) . Its sample complexity is therefore
polynomial in n. We claim that there can be no efficient learner for this class. If
there were such a learner, L, then by sampling uniformly at random a polynomial
number of strings in {0, 1}n , and computing f over them, we could generate a
labeled training sample of pairs (f (x), x), which should suffice for our learner to
figure out an (, Î´) approximation of f âˆ’1 (w.r.t. the uniform distribution over
the range of f ), which would violate the one way property of f .
A more detailed treatment, as well as a concrete example, can be found in
(Kearns & Vazirani 1994, Chapter 6). Using reductions, they also show that

110

The Runtime of Learning

the class of functions that can be calculated by small Boolean circuits is not
efficiently learnable, even in the realizable case.

8.5

Summary
The runtime of learning algorithms is asymptotically analyzed as a function of
different parameters of the learning problem, such as the size of the hypothesis class, our measure of accuracy, our measure of confidence, or the size of the
domain set. We have demonstrated cases in which the ERM rule can be implemented efficiently. For example, we derived efficient algorithms for solving the
ERM problem for the class of Boolean conjunctions and the class of axis aligned
rectangles, under the realizability assumption. However, implementing ERM for
these classes in the agnostic case is NP-hard. Recall that from the statistical
perspective, there is no difference between the realizable and agnostic cases (i.e.,
a class is learnable in both cases if and only if it has a finite VC-dimension).
In contrast, as we saw, from the computational perspective the difference is immense. We have also shown another example, the class of 3-term DNF, where
implementing ERM is hard even in the realizable case, yet the class is efficiently
learnable by another algorithm.
Hardness of implementing the ERM rule for several natural hypothesis classes
has motivated the development of alternative learning methods, which we will
discuss in the next part of this book.

8.6

Bibliographic Remarks
Valiant (1984) introduced the efficient PAC learning model in which the runtime
of the algorithm is required to be polynomial in 1/, 1/Î´, and the representation
size of hypotheses in the class. A detailed discussion and thorough bibliographic
notes are given in Kearns & Vazirani (1994).

8.7

Exercises
1. Let H be the class of intervals on the line (formally equivalent to axis aligned
rectangles in dimension n = 1). Propose an implementation of the ERMH
learning rule (in the agnostic case) that given a training set of size m, runs
in time O(m2 ).
Hint: Use dynamic programming.
2. Let H1 , H2 , . . . be a sequence of hypothesis classes for binary classification.
Assume that there is a learning algorithm that implements the ERM rule in
the realizable case such that the output hypothesis of the algorithm for each
class Hn only depends on O(n) examples out of the training set. Furthermore,

8.7 Exercises

111

assume that such a hypothesis can be calculated given these O(n) examples
in time O(n), and that the empirical risk of each such hypothesis can be
evaluated in time O(mn). For example, if Hn is the class of axis aligned
rectangles in Rn , we saw that it is possible to find an ERM hypothesis in the
realizable case that is defined by at most 2n examples. Prove that in such
cases, it is possible to find an ERM hypothesis for Hn in the unrealizable case
in time O(mn mO(n) ).
3. In this exercise, we present several classes for which finding an ERM classifier is computationally hard. First, we introduce the class of n-dimensional
halfspaces, HSn , for a domain X = Rn . This is the class of all functions of
the form hw,b (x) = sign(hw, xi + b) where w, x âˆˆ Rn , hw, xi is their inner
product, and b âˆˆ R. See a detailed description in Chapter 9.
1. Show that ERMH over the class H = HSn of linear predictors is computationally hard. More precisely, we consider the sequence of problems in
which the dimension n grows linearly and the number of examples m is set
to be some constant times n.
Hint: You can prove the hardness by a reduction from the following problem:
Max FS: Given a system of linear inequalities, Ax > b with A âˆˆ RmÃ—n and b âˆˆ
Rm (that is, a system of m linear inequalities in n variables, x = (x1 , . . . , xn )),
find a subsystem containing as many inequalities as possible that has a solution
(such a subsystem is called feasible).

It has been shown (Sankaran 1993) that the problem Max FS is NP-hard.
Show that any algorithm that finds an ERMHSn hypothesis for any training
sample S âˆˆ (Rn Ã— {+1, âˆ’1})m can be used to solve the Max FS problem of
size m, n. Hint: Define a mapping that transforms linear inequalities in n
variables into labeled points in Rn , and a mapping that transforms vectors
in Rn to halfspaces, such that a vector w satisfies an inequality q if and
only if the labeled point that corresponds to q is classified correctly by the
halfspace corresponding to w. Conclude that the problem of empirical risk
minimization for halfspaces in also NP-hard (that is, if it can be solved in
time polynomial in the sample size, m, and the Euclidean dimension, n,
then every problem in the class NP can be solved in polynomial time).
2. Let X = Rn and let Hkn be the class of all intersections of k-many linear
halfspaces in Rn . In this exercise, we wish to show that ERMHnk is computationally hard for every k â‰¥ 3. Precisely, we consider a sequence of
problems where k â‰¥ 3 is a constant and n grows linearly. The training set
size, m, also grows linearly with n.
Towards this goal, consider the k-coloring problem for graphs, defined as
follows:
Given a graph G = (V, E), and a number k, determine whether there exists a
function f : V â†’ {1 . . . k} so that for every (u, v) âˆˆ E, f (u) 6= f (v).

The k-coloring problem is known to be NP-hard for every k â‰¥ 3 (Karp
1972).

112

The Runtime of Learning

We wish to reduce the k-coloring problem to ERMHnk : that is, to prove
that if there is an algorithm that solves the ERMHnk problem in time
polynomial in k, n, and the sample size m, then there is a polynomial time
algorithm for the graph k-coloring problem.
Given a graph G = (V, E), let {v1 . . . vn } be the vertices in V . Construct
a sample S(G) âˆˆ (Rn Ã— {Â±1})m , where m = |V | + |E|, as follows:
â€¢ For every vi âˆˆ V , construct an instance ei with a negative label.
â€¢ For every edge (vi , vj ) âˆˆ E, construct an instance (ei + ej )/2 with a
positive label.
1. Prove that if there exists some h âˆˆ Hkn that has zero error over S(G)
then G is k-colorable.
Tk
Hint: Let h = j=1 hj be an ERM classifier in Hkn over S. Define a
coloring of V by setting f (vi ) to be the minimal j such that hj (ei ) = âˆ’1.
Use the fact that halfspaces are convex sets to show that it cannot be
true that two vertices that are connected by an edge have the same
color.
2. Prove that if G is k-colorable then there exists some h âˆˆ Hkn that has
zero error over S(G).
Hint: Given a coloring f of the vertices of G, we should come up with k
hyperplanes, h1 . . . hk whose intersection is a perfect classifier for S(G).
Let b = 0.6 for all of these hyperplanes and, for t â‰¤ k let the iâ€™th weight
of the tâ€™th hyperplane, wt,i , be âˆ’1 if f (vi ) = t and 0 otherwise.
3. Based on the above, prove that for any k â‰¥ 3, the ERMHnk problem is
NP-hard.
4. In this exercise we show that hardness of solving the ERM problem is equivalent to hardness of proper PAC learning. Recall that by â€œpropernessâ€ of the
algorithm we mean that it must output a hypothesis from the hypothesis
class. To formalize this statement, we first need the following definition.
definition 8.2 The complexity class Randomized Polynomial (RP) time
is the class of all decision problems (that is, problems in which on any instance
one has to find out whether the answer is YES or NO) for which there exists a
probabilistic algorithm (namely, the algorithm is allowed to flip random coins
while it is running) with these properties:
â€¢ On any input instance the algorithm runs in polynomial time in the input
size.
â€¢ If the correct answer is NO, the algorithm must return NO.
â€¢ If the correct answer is YES, the algorithm returns YES with probability
a â‰¥ 1/2 and returns NO with probability 1 âˆ’ a.1
Clearly the class RP contains the class P. It is also known that RP is
contained in the class NP. It is not known whether any equality holds among
these three complexity classes, but it is widely believed that NP is strictly
1

The constant 1/2 in the definition can be replaced by any constant in (0, 1).

8.7 Exercises

113

larger than RP. In particular, it is believed that NP-hard problems cannot be
solved by a randomized polynomial time algorithm.
â€¢ Show that if a class H is properly PAC learnable by a polynomial time
algorithm, then the ERMH problem is in the class RP. In particular, this
implies that whenever the ERMH problem is NP-hard (for example, the
class of intersections of halfspaces discussed in the previous exercise),
then, unless NP = RP, there exists no polynomial time proper PAC
learning algorithm for H.
Hint: Assume you have an algorithm A that properly PAC learns a
class H in time polynomial in some class parameter n as well as in 1/
and 1/Î´. Your goal is to use that algorithm as a subroutine to contract
an algorithm B for solving the ERMH problem in random polynomial
time. Given a training set, S âˆˆ (X Ã— {Â±1}m ), and some h âˆˆ H whose
error on S is zero, apply the PAC learning algorithm to the uniform
distribution over S and run it so that with probability â‰¥ 0.3 it finds a
function h âˆˆ H that has error less than  = 1/|S| (with respect to that
uniform distribution). Show that the algorithm just described satisfies
the requirements for being a RP solver for ERMH .

Part II
From Theory to Algorithms

9

Linear Predictors

In this chapter we will study the family of linear predictors, one of the most
useful families of hypothesis classes. Many learning algorithms that are being
widely used in practice rely on linear predictors, first and foremost because of
the ability to learn them efficiently in many cases. In addition, linear predictors
are intuitive, are easy to interpret, and fit the data reasonably well in many
natural learning problems.
We will introduce several hypothesis classes belonging to this family â€“ halfspaces,
linear regression predictors, and logistic regression predictors â€“ and present relevant learning algorithms: linear programming and the Perceptron algorithm for
the class of halfspaces and the Least Squares algorithm for linear regression.
This chapter is focused on learning linear predictors using the ERM approach;
however, in later chapters we will see alternative paradigms for learning these
hypothesis classes.
First, we define the class of affine functions as
Ld = {hw,b : w âˆˆ Rd , b âˆˆ R},
where
hw,b (x) = hw, xi + b =

d
X

!
wi xi

+ b.

i=1

It will be convenient also to use the notation
Ld = {x 7â†’ hw, xi + b : w âˆˆ Rd , b âˆˆ R},
which reads as follows: Ld is a set of functions, where each function is parameterized by w âˆˆ Rd and b âˆˆ R, and each such function takes as input a vector x
and returns as output the scalar hw, xi + b.
The different hypothesis classes of linear predictors are compositions of a function Ï† : R â†’ Y on Ld . For example, in binary classification, we can choose Ï† to
be the sign function, and for regression problems, where Y = R, Ï† is simply the
identity function.
It may be more convenient to incorporate b, called the bias, into w as an
extra coordinate and add an extra coordinate with a value of 1 to all x âˆˆ X ;
namely, let w0 = (b, w1 , w2 , . . . wd ) âˆˆ Rd+1 and let x0 = (1, x1 , x2 , . . . , xd ) âˆˆ
c 2014 by Shai Shalev-Shwartz and Shai Ben-David
Understanding Machine Learning, 
Published 2014 by Cambridge University Press.
Personal use only. Not for distribution. Do not post.
Please link to http://www.cs.huji.ac.il/~shais/UnderstandingMachineLearning

118

Linear Predictors

Rd+1 . Therefore,
hw,b (x) = hw, xi + b = hw0 , x0 i.
It follows that each affine function in Rd can be rewritten as a homogenous linear
function in Rd+1 applied over the transformation that appends the constant 1
to each input vector. Therefore, whenever it simplifies the presentation, we will
omit the bias term and refer to Ld as the class of homogenous linear functions
of the form hw (x) = hw, xi.
Throughout the book we often use the general term â€œlinear functionsâ€ for both
affine functions and (homogenous) linear functions.

9.1

Halfspaces
The first hypothesis class we consider is the class of halfspaces, designed for
binary classification problems, namely, X = Rd and Y = {âˆ’1, +1}. The class of
halfspaces is defined as follows:
HSd = sign â—¦ Ld = {x 7â†’ sign(hw,b (x)) : hw,b âˆˆ Ld }.
In other words, each halfspace hypothesis in HSd is parameterized by w âˆˆ
Rd and b âˆˆ R and upon receiving a vector x the hypothesis returns the label
sign(hw, xi + b).
To illustrate this hypothesis class geometrically, it is instructive to consider
the case d = 2. Each hypothesis forms a hyperplane that is perpendicular to the
vector w and intersects the vertical axis at the point (0, âˆ’b/w2 ). The instances
that are â€œaboveâ€ the hyperplane, that is, share an acute angle with w, are labeled
positively. Instances that are â€œbelowâ€ the hyperplane, that is, share an obtuse
angle with w, are labeled negatively.
w

+
âˆ’
+
âˆ’

In Section 9.1.3 we will show that VCdim(HSd ) = d + 1. It follows that we
can
using the ERM paradigm, as long as the sample size is
 learn halfspaces

d+log(1/Î´)
â„¦
. Therefore, we now discuss how to implement an ERM procedure

for halfspaces.
We introduce below two solutions to finding an ERM halfspace in the realizable case. In the context of halfspaces, the realizable case is often referred to as
the â€œseparableâ€ case, since it is possible to separate with a hyperplane all the
positive examples from all the negative examples. Implementing the ERM rule

9.1 Halfspaces

119

in the nonseparable case (i.e., the agnostic case) is known to be computationally
hard (Ben-David & Simon 2001). There are several approaches to learning nonseparable data. The most popular one is to use surrogate loss functions, namely,
to learn a halfspace that does not necessarily minimize the empirical risk with
the 0 âˆ’ 1 loss, but rather with respect to a diffferent loss function. For example,
in Section 9.3 we will describe the logistic regression approach, which can be
implemented efficiently even in the nonseparable case. We will study surrogate
loss functions in more detail later on in Chapter 12.

9.1.1

Linear Programming for the Class of Halfspaces
Linear programs (LP) are problems that can be expressed as maximizing a linear
function subject to linear inequalities. That is,
max

wâˆˆRd

hu, wi

subject to

Aw â‰¥ v

where w âˆˆ Rd is the vector of variables we wish to determine, A is an m Ã—
d matrix, and v âˆˆ Rm , u âˆˆ Rd are vectors. Linear programs can be solved
efficiently,1 and furthermore, there are publicly available implementations of LP
solvers.
We will show that the ERM problem for halfspaces in the realizable case can
be expressed as a linear program. For simplicity, we assume the homogenous
case. Let S = {(xi , yi )}m
i=1 be a training set of size m. Since we assume the
realizable case, an ERM predictor should have zero errors on the training set.
That is, we are looking for some vector w âˆˆ Rd for which
sign(hw, xi i) = yi ,

âˆ€i = 1, . . . , m.

Equivalently, we are looking for some vector w for which
yi hw, xi i > 0,

âˆ€i = 1, . . . , m.

Let wâˆ— be a vector that satisfies this condition (it must exist since we assume
âˆ—
realizability). Define Î³ = mini (yi hwâˆ— , xi i) and let wÌ„ = wÎ³ . Therefore, for all i
we have
1
yi hwÌ„, xi i = yi hwâˆ— , xi i â‰¥ 1.
Î³
We have thus shown that there exists a vector that satisfies
yi hw, xi i â‰¥ 1,

âˆ€i = 1, . . . , m.

(9.1)

And clearly, such a vector is an ERM predictor.
To find a vector that satisfies Equation (9.1) we can rely on an LP solver as
follows. Set A to be the m Ã— d matrix whose rows are the instances multiplied
1

Namely, in time polynomial in m, d, and in the representation size of real numbers.

120

Linear Predictors

by yi . That is, Ai,j = yi xi,j , where xi,j is the jâ€™th element of the vector xi . Let
v be the vector (1, . . . , 1) âˆˆ Rm . Then, Equation (9.1) can be rewritten as
Aw â‰¥ v.
The LP form requires a maximization objective, yet all the w that satisfy the
constraints are equal candidates as output hypotheses. Thus, we set a â€œdummyâ€
objective, u = (0, . . . , 0) âˆˆ Rd .

9.1.2

Perceptron for Halfspaces
A different implementation of the ERM rule is the Perceptron algorithm of
Rosenblatt (Rosenblatt 1958). The Perceptron is an iterative algorithm that
constructs a sequence of vectors w(1) , w(2) , . . .. Initially, w(1) is set to be the
all-zeros vector. At iteration t, the Perceptron finds an example i that is mislabeled by w(t) , namely, an example for which sign(hw(t) , xi i) 6= yi . Then, the
Perceptron updates w(t) by adding to it the instance xi scaled by the label yi .
That is, w(t+1) = w(t) + yi xi . Recall that our goal is to have yi hw, xi i > 0 for
all i and note that
yi hw(t+1) , xi i = yi hw(t) + yi xi , xi i = yi hw(t) , xi i + kxi k2 .
Hence, the update of the Perceptron guides the solution to be â€œmore correctâ€ on
the iâ€™th example.
Batch Perceptron
input: A training set (x1 , y1 ), . . . , (xm , ym )
initialize: w(1) = (0, . . . , 0)
for t = 1, 2, . . .
if (âˆƒ i s.t. yi hw(t) , xi i â‰¤ 0) then
w(t+1) = w(t) + yi xi
else
output w(t)
The following theorem guarantees that in the realizable case, the algorithm
stops with all sample points correctly classified.
theorem 9.1 Assume that (x1 , y1 ), . . . , (xm , ym ) is separable, let B = min{kwk :
âˆ€i âˆˆ [m], yi hw, xi i â‰¥ 1}, and let R = maxi kxi k. Then, the Perceptron algorithm stops after at most (RB)2 iterations, and when it stops it holds that
âˆ€i âˆˆ [m], yi hw(t) , xi i > 0.
Proof By the definition of the stopping condition, if the Perceptron stops it
must have separated all the examples. We will show that if the Perceptron runs
for T iterations, then we must have T â‰¤ (RB)2 , which implies the Perceptron
must stop after at most (RB)2 iterations.
Let w? be a vector that achieves the minimum in the definition of B. That is,

9.1 Halfspaces

121

yi hw? , xi i â‰¥ 1 for all i, and among all vectors that satisfy these constraints, w?
is of minimal norm.
The idea of the proof is to show that after performing
T iterations, the cosine
âˆš
T
?
(T +1)
of the angle between w and w
is at least RB . That is, we will show that
âˆš
hw? , w(T +1) i
T
â‰¥
.
(9.2)
RB
kw? k kw(T +1) k
By the Cauchy-Schwartz inequality, the left-hand side of Equation (9.2) is at
most 1. Therefore, Equation (9.2) would imply that
âˆš
T
â‡’ T â‰¤ (RB)2 ,
1â‰¥
RB
which will conclude our proof.
To show that Equation (9.2) holds, we first show that hw? , w(T +1) i â‰¥ T .
Indeed, at the first iteration, w(1) = (0, . . . , 0) and therefore hw? , w(1) i = 0,
while on iteration t, if we update using example (xi , yi ) we have that
hw? , w(t+1) i âˆ’ hw? , w(t) i = hw? , w(t+1) âˆ’ w(t) i
= hw? , yi xi i = yi hw? , xi i
â‰¥ 1.
Therefore, after performing T iterations, we get:
hw? , w(T +1) i =

T 
X


hw? , w(t+1) i âˆ’ hw? , w(t) i â‰¥ T,

(9.3)

t=1

as required.
Next, we upper bound kw(T +1) k. For each iteration t we have that
kw(t+1) k2 = kw(t) + yi xi k2
= kw(t) k2 + 2yi hw(t) , xi i + yi2 kxi k2
â‰¤ kw(t) k2 + R2

(9.4)

where the last inequality is due to the fact that example i is necessarily such
that yi hw(t) , xi i â‰¤ 0, and the norm of xi is at most R. Now, since kw(1) k2 = 0,
if we use Equation (9.4) recursively for T iterations, we obtain that
âˆš
kw(T +1) k2 â‰¤ TR 2 â‡’ kw(T +1) k â‰¤ T R.
(9.5)
Combining Equation (9.3) with Equation (9.5), and using the fact that kw? k =
B, we obtain that
âˆš
hw(T +1) , w? i
T
T
â‰¥ âˆš
=
.
?
(T
+1)
BR
kw k kw
k
B TR
We have thus shown that Equation (9.2) holds, and this concludes our proof.

122

Linear Predictors

Remark 9.1 The Perceptron is simple to implement and is guaranteed to converge. However, the convergence rate depends on the parameter B, which in
some situations might be exponentially large in d. In such cases, it would be
better to implement the ERM problem by solving a linear program, as described
in the previous section. Nevertheless, for many natural data sets, the size of B
is not too large, and the Perceptron converges quite fast.

9.1.3

The VC Dimension of Halfspaces
To compute the VC dimension of halfspaces, we start with the homogenous case.
theorem 9.2
is d.

The VC dimension of the class of homogenous halfspaces in Rd

Proof First, consider the set of vectors e1 , . . . , ed , where for every i the vector
ei is the all zeros vector except 1 in the iâ€™th coordinate. This set is shattered
by the class of homogenous halfspaces. Indeed, for every labeling y1 , . . . , yd , set
w = (y1 , . . . , yd ), and then hw, ei i = yi for all i.
Next, let x1 , . . . , xd+1 be a set of d + 1 vectors in Rd . Then, there must exist
Pd+1
real numbers a1 , . . . , ad+1 , not all of them are zero, such that i=1 ai xi = 0.
Let I = {i : ai > 0} and J = {j : aj < 0}. Either I or J is nonempty. Let us
first assume that both of them are nonempty. Then,
X
X
ai xi =
|aj |xj .
iâˆˆI

jâˆˆJ

Now, suppose that x1 , . . . , xd+1 are shattered by the class of homogenous classes.
Then, there must exist a vector w such that hw, xi i > 0 for all i âˆˆ I while
hw, xj i < 0 for every j âˆˆ J. It follows that
*
+ *
+
X
X
X
X
0<
ai hxi , wi =
ai xi , w =
|aj |xj , w =
|aj |hxj , wi < 0,
iâˆˆI

iâˆˆI

jâˆˆJ

jâˆˆJ

which leads to a contradiction. Finally, if J (respectively, I) is empty then the
right-most (respectively, left-most) inequality should be replaced by an equality,
which still leads to a contradiction.
theorem 9.3
Rd is d + 1.

The VC dimension of the class of nonhomogenous halfspaces in

Proof First, as in the proof of Theorem 9.2, it is easy to verify that the set
of vectors 0, e1 , . . . , ed is shattered by the class of nonhomogenous halfspaces.
Second, suppose that the vectors x1 , . . . , xd+2 are shattered by the class of nonhomogenous halfspaces. But, using the reduction we have shown in the beginning
of this chapter, it follows that there are d + 2 vectors in Rd+1 that are shattered
by the class of homogenous halfspaces. But this contradicts Theorem 9.2.

9.2 Linear Regression

r
r
r
r
r r

r

r

r

r

123

r

Figure 9.1 Linear regression for d = 1. For instance, the x-axis may denote the age of

the baby, and the y-axis her weight.

9.2

Linear Regression
Linear regression is a common statistical tool for modeling the relationship between some â€œexplanatoryâ€ variables and some real valued outcome. Cast as a
learning problem, the domain set X is a subset of Rd , for some d, and the label set Y is the set of real numbers. We would like to learn a linear function
h : Rd â†’ R that best approximates the relationship between our variables (say,
for example, predicting the weight of a baby as a function of her age and weight
at birth). Figure 9.1 shows an example of a linear regression predictor for d = 1.
The hypothesis class of linear regression predictors is simply the set of linear
functions,
Hreg = Ld = {x 7â†’ hw, xi + b : w âˆˆ Rd , b âˆˆ R}.
Next we need to define a loss function for regression. While in classification the
definition of the loss is straightforward, as `(h, (x, y)) simply indicates whether
h(x) correctly predicts y or not, in regression, if the babyâ€™s weight is 3 kg, both
the predictions 3.00001 kg and 4 kg are â€œwrong,â€ but we would clearly prefer
the former over the latter. We therefore need to define how much we shall be
â€œpenalizedâ€ for the discrepancy between h(x) and y. One common way is to use
the squared-loss function, namely,
`(h, (x, y)) = (h(x) âˆ’ y)2 .
For this loss function, the empirical risk function is called the Mean Squared
Error, namely,
m
1 X
(h(xi ) âˆ’ yi )2 .
LS (h) =
m i=1

124

Linear Predictors

In the next subsection, we will see how to implement the ERM rule for linear
regression with respect to the squared loss. Of course, there are a variety of other
loss functions that one can use, for example, the absolute value loss function,
`(h, (x, y)) = |h(x) âˆ’ y|. The ERM rule for the absolute value loss function can
be implemented using linear programming (see Exercise 1.)
Note that since linear regression is not a binary prediction task, we cannot analyze its sample complexity using the VC-dimension. One possible analysis of the
sample complexity of linear regression is by relying on the â€œdiscretization trickâ€
(see Remark 4.1 in Chapter 4); namely, if we are happy with a representation of
each element of the vector w and the bias b using a finite number of bits (say
a 64 bits floating point representation), then the hypothesis class becomes finite
and its size is at most 264(d+1) . We can now rely on sample complexity bounds
for finite hypothesis classes as described in Chapter 4. Note, however, that to
apply the sample complexity bounds from Chapter 4 we also need that the loss
function will be bounded. Later in the book we will describe more rigorous means
to analyze the sample complexity of regression problems.

9.2.1

Least Squares
Least squares is the algorithm that solves the ERM problem for the hypothesis class of linear regression predictors with respect to the squared loss. The
ERM problem with respect to this class, given a training set S, and using the
homogenous version of Ld , is to find
m

argmin LS (hw ) = argmin
w

w

1 X
(hw, xi i âˆ’ yi )2 .
m i=1

To solve the problem we calculate the gradient of the objective function and
compare it to zero. That is, we need to solve
m

2 X
(hw, xi i âˆ’ yi )xi = 0.
m i=1
We can rewrite the problem as the problem Aw = b where

A=

m
X
i=1

!
xi x>
i

and

b=

m
X
i=1

yi xi .

(9.6)

9.2 Linear Regression

125

Or, in matrix form:
..
ï£¬ .
A=ï£¬
ï£­ x1
..
.
ï£«
..
ï£¬ .
b=ï£¬
ï£­ x1
..
.
ï£«

...

...

ï£¶ï£«
.
..
. ï£· ï£¬ ..
ï£¬
xm ï£·
ï£¸ ï£­ x1
..
..
.
.
ï£¶ï£«
..
y1
. ï£·
ï£¬ ..
ï£·
xm ï£¸ ï£­ .
..
ym
.

...

ï£¶>
..
. ï£·
xm ï£·
ï£¸ ,
..
.

(9.7)

ï£¶
ï£·
ï£¸ .

(9.8)

If A is invertible then the solution to the ERM problem is
w = Aâˆ’1 b.
The case in which A is not invertible requires a few standard tools from linear
algebra, which are available in Appendix C. It can be easily shown that if the
training instances do not span the entire space of Rd then A is not invertible.
Nevertheless, we can always find a solution to the system Aw = b because b
is in the range of A. Indeed, since A is symmetric we can write it using its
eigenvalue decomposition as A = V DV >, where D is a diagonal matrix and V
is an orthonormal matrix (that is, V > V is the identity d Ã— d matrix). Define
+
D+ to be the diagonal matrix such that Di,i
= 0 if Di,i = 0 and otherwise
+
Di,i = 1/Di,i . Now, define
A+ = V D + V >

and

wÌ‚ = A+ b.

Let vi denote the iâ€™th column of V . Then, we have
AwÌ‚ = AA+ b = V DV > V D+ V > b = V DD+ V > b =

X

vi vi> b.

i:Di,i 6=0

That is, AwÌ‚ is the projection of b onto the span of those vectors vi for which
Di,i 6= 0. Since the linear span of x1 , . . . , xm is the same as the linear span of
those vi , and b is in the linear span of the xi , we obtain that AwÌ‚ = b, which
concludes our argument.

9.2.2

Linear Regression for Polynomial Regression Tasks
Some learning tasks call for nonlinear predictors, such as polynomial predictors.
Take, for instance, a one dimensional polynomial function of degree n, that is,
p(x) = a0 + a1 x + a2 x2 + Â· Â· Â· + an xn
where (a0 , . . . , an ) is a vector of coefficients of size n + 1. In the following we
depict a training set that is better fitted using a 3rd degree polynomial predictor
than using a linear predictor.

126

Linear Predictors

We will focus here on the class of one dimensional, n-degree, polynomial regression predictors, namely,
n
Hpoly
= {x 7â†’ p(x)},

where p is a one dimensional polynomial of degree n, parameterized by a vector
of coefficients (a0 , . . . , an ). Note that X = R, since this is a one dimensional
polynomial, and Y = R, as this is a regression problem.
One way to learn this class is by reduction to the problem of linear regression,
which we have already shown how to solve. To translate a polynomial regression
problem to a linear regression problem, we define the mapping Ïˆ : R â†’ Rn+1
such that Ïˆ(x) = (1, x, x2 , . . . , xn ). Then we have that
p(Ïˆ(x)) = a0 + a1 x + a2 x2 + Â· Â· Â· + an xn = ha, Ïˆ(x)i
and we can find the optimal vector of coefficients a by using the Least Squares
algorithm as shown earlier.

9.3

Logistic Regression
In logistic regression we learn a family of functions h from Rd to the interval [0, 1].
However, logistic regression is used for classification tasks: We can interpret h(x)
as the probability that the label of x is 1. The hypothesis class associated with
logistic regression is the composition of a sigmoid function Ï†sig : R â†’ [0, 1] over
the class of linear functions Ld . In particular, the sigmoid function used in logistic
regression is the logistic function, defined as
Ï†sig (z) =

1
.
1 + exp(âˆ’z)

(9.9)

The name â€œsigmoidâ€ means â€œS-shaped,â€ referring to the plot of this function,
shown in the figure:

9.3 Logistic Regression

127

The hypothesis class is therefore (where for simplicity we are using homogenous
linear functions):
Hsig = Ï†sig â—¦ Ld = {x 7â†’ Ï†sig (hw, xi) : w âˆˆ Rd }.
Note that when hw, xi is very large then Ï†sig (hw, xi) is close to 1, whereas if
hw, xi is very small then Ï†sig (hw, xi) is close to 0. Recall that the prediction of the
halfspace corresponding to a vector w is sign(hw, xi). Therefore, the predictions
of the halfspace hypothesis and the logistic hypothesis are very similar whenever
|hw, xi| is large. However, when |hw, xi| is close to 0 we have that Ï†sig (hw, xi) â‰ˆ
1
2 . Intuitively, the logistic hypothesis is not sure about the value of the label so it
guesses that the label is sign(hw, xi) with probability slightly larger than 50%.
In contrast, the halfspace hypothesis always outputs a deterministic prediction
of either 1 or âˆ’1, even if |hw, xi| is very close to 0.
Next, we need to specify a loss function. That is, we should define how bad it
is to predict some hw (x) âˆˆ [0, 1] given that the true label is y âˆˆ {Â±1}. Clearly,
we would like that hw (x) would be large if y = 1 and that 1 âˆ’ hw (x) (i.e., the
probability of predicting âˆ’1) would be large if y = âˆ’1. Note that
1 âˆ’ hw (x) = 1 âˆ’

1
exp(âˆ’hw, xi)
1
=
=
.
1 + exp(âˆ’hw, xi)
1 + exp(âˆ’hw, xi)
1 + exp(hw, xi)

1
Therefore, any reasonable loss function would increase monotonically with 1+exp(yhw,xi)
,
or equivalently, would increase monotonically with 1 + exp(âˆ’yhw, xi). The logistic loss function used in logistic regression penalizes hw based on the log of
1 + exp(âˆ’yhw, xi) (recall that log is a monotonic function). That is,

`(hw , (x, y)) = log (1 + exp(âˆ’yhw, xi)) .
Therefore, given a training set S = (x1 , y1 ), . . . , (xm , ym ), the ERM problem
associated with logistic regression is
m

argmin
wâˆˆRd

1 X
log (1 + exp(âˆ’yi hw, xi i)) .
m i=1

(9.10)

The advantage of the logistic loss function is that it is a convex function with
respect to w; hence the ERM problem can be solved efficiently using standard
methods. We will study how to learn with convex functions, and in particular
specify a simple algorithm for minimizing convex functions, in later chapters.
The ERM problem associated with logistic regression (Equation (9.10)) is identical to the problem of finding a Maximum Likelihood Estimator, a well-known
statistical approach for finding the parameters that maximize the joint probability of a given data set assuming a specific parametric probability function. We
will study the Maximum Likelihood approach in Chapter 24.

128

Linear Predictors

9.4

Summary
The family of linear predictors is one of the most useful families of hypothesis
classes, and many learning algorithms that are being widely used in practice
rely on linear predictors. We have shown efficient algorithms for learning linear
predictors with respect to the zero-one loss in the separable case and with respect
to the squared and logistic losses in the unrealizable case. In later chapters we
will present the properties of the loss function that enable efficient learning.
Naturally, linear predictors are effective whenever we assume, as prior knowledge, that some linear predictor attains low risk with respect to the underlying
distribution. In the next chapter we show how to construct nonlinear predictors
by composing linear predictors on top of simple classes. This will enable us to
employ linear predictors for a variety of prior knowledge assumptions.

9.5

Bibliographic Remarks
The Perceptron algorithm dates back to Rosenblatt (1958). The proof of its
convergence rate is due to (Agmon 1954, Novikoff 1962). Least Squares regression
goes back to Gauss (1795), Legendre (1805), and Adrain (1808).

9.6

Exercises
1. Show how to cast the ERM problem of linear regression with respect to the
absolute value loss function, `(h, (x, y)) = |h(x) âˆ’ y|, as a linear program;
namely, show how to write the problem
min
w

m
X

|hw, xi i âˆ’ yi |

i=1

as a linear program.
Hint: Start with proving that for any c âˆˆ R,
|c| = min a s.t. c â‰¤ a and c â‰¥ âˆ’a.
aâ‰¥0

2. Show that the matrix A defined in Equation (9.6) is invertible if and only if
x1 , . . . , xm span Rd .
3. Show that Theorem 9.1 is tight in the following sense: For any positive integer
m, there exist a vector wâˆ— âˆˆ Rd (for some appropriate d) and a sequence of
examples {(x1 , y1 ), . . . , (xm , ym )} such that the following hold:
â€¢ R = maxi kxi k â‰¤ 1.
â€¢ kwâˆ— k2 = m, and for all i â‰¤ m, yi hxi , wâˆ— i â‰¥ 1. Note that, using the notation
in Theorem 9.1, we therefore get
âˆš
B = min{kwk : âˆ€i âˆˆ [m], yi hw, xi i â‰¥ 1} â‰¤ m.

9.6 Exercises

129

Thus, (BR)2 â‰¤ m.
â€¢ When running the Perceptron on this sequence of examples it makes m
updates before converging.
Hint: Choose d = m and for every i choose xi = ei .
4. (*) Given any number m, find an example of a sequence of labeled examples
((x1 , y1 ), . . . , (xm , ym )) âˆˆ (R3 Ã— {âˆ’1, +1})m on which the upper bound of
Theorem 9.1 equals m and the perceptron algorithm is bound to make m
mistakes.
Hint: Set each xi to be a third dimensional vector of the form (a, b, yi ), where
a2 + b2 = R2 âˆ’ 1. Let wâˆ— be the vector (0, 0, 1). Now, go over the proof of
the Perceptronâ€™s upper bound (Theorem 9.1), see where we used inequalities
(â‰¤) rather than equalities (=), and figure out scenarios where the inequality
actually holds with equality.
5. Suppose we modify the Perceptron algorithm as follows: In the update step,
instead of performing w(t+1) = w(t) + yi xi whenever we make a mistake, we
perform w(t+1) = w(t) + Î·yi xi for some Î· > 0. Prove that the modified Perceptron will perform the same number of iterations as the vanilla Perceptron
and will converge to a vector that points to the same direction as the output
of the vanilla Perceptron.
6. In this problem, we will get bounds on the VC-dimension of the class of
(closed) balls in Rd , that is,
Bd = {Bv,r : v âˆˆ Rd , r > 0},
where

Bv,r (x) =

1
0

if kx âˆ’ vk â‰¤ r
.
otherwise

1. Consider the mapping Ï† : Rd â†’ Rd+1 defined by Ï†(x) = (x, kxk2 ). Show
that if x1 , . . . , xm are shattered by Bd then Ï†(x1 ), . . . , Ï†(xm ) are shattered
by the class of halfspaces in Rd+1 (in this question we assume that sign(0) =
1). What does this tell us about VCdim(Bd )?
2. (*) Find a set of d + 1 points in Rd that is shattered by Bd . Conclude that
d + 1 â‰¤ VCdim(Bd ) â‰¤ d + 2.

10 Boosting

Boosting is an algorithmic paradigm that grew out of a theoretical question and
became a very practical machine learning tool. The boosting approach uses a
generalization of linear predictors to address two major issues that have been
raised earlier in the book. The first is the bias-complexity tradeoff. We have
seen (in Chapter 5) that the error of an ERM learner can be decomposed into
a sum of approximation error and estimation error. The more expressive the
hypothesis class the learner is searching over, the smaller the approximation
error is, but the larger the estimation error becomes. A learner is thus faced with
the problem of picking a good tradeoff between these two considerations. The
boosting paradigm allows the learner to have smooth control over this tradeoff.
The learning starts with a basic class (that might have a large approximation
error), and as it progresses the class that the predictor may belong to grows
richer.
The second issue that boosting addresses is the computational complexity of
learning. As seen in Chapter 8, for many interesting concept classes the task
of finding an ERM hypothesis may be computationally infeasible. A boosting
algorithm amplifies the accuracy of weak learners. Intuitively, one can think of
a weak learner as an algorithm that uses a simple â€œrule of thumbâ€ to output a
hypothesis that comes from an easy-to-learn hypothesis class and performs just
slightly better than a random guess. When a weak learner can be implemented
efficiently, boosting provides a tool for aggregating such weak hypotheses to
approximate gradually good predictors for larger, and harder to learn, classes.
In this chapter we will describe and analyze a practically useful boosting algorithm, AdaBoost (a shorthand for Adaptive Boosting). The AdaBoost algorithm
outputs a hypothesis that is a linear combination of simple hypotheses. In other
words, AdaBoost relies on the family of hypothesis classes obtained by composing
a linear predictor on top of simple classes. We will show that AdaBoost enables
us to control the tradeoff between the approximation and estimation errors by
varying a single parameter.
AdaBoost demonstrates a general theme, that will recur later in the book, of
expanding the expressiveness of linear predictors by composing them on top of
other functions. This will be elaborated in Section 10.3.
AdaBoost stemmed from the theoretical question of whether an efficient weak
learner can be â€œboostedâ€ into an efficient strong learner. This question was raised
c 2014 by Shai Shalev-Shwartz and Shai Ben-David
Understanding Machine Learning, 
Published 2014 by Cambridge University Press.
Personal use only. Not for distribution. Do not post.
Please link to http://www.cs.huji.ac.il/~shais/UnderstandingMachineLearning

10.1 Weak Learnability

131

by Kearns and Valiant in 1988 and solved in 1990 by Robert Schapire, then
a graduate student at MIT. However, the proposed mechanism was not very
practical. In 1995, Robert Schapire and Yoav Freund proposed the AdaBoost
algorithm, which was the first truly practical implementation of boosting. This
simple and elegant algorithm became hugely popular, and Freund and Schapireâ€™s
work has been recognized by numerous awards.
Furthermore, boosting is a great example for the practical impact of learning
theory. While boosting originated as a purely theoretical problem, it has led to
popular and widely used algorithms. Indeed, as we shall demonstrate later in
this chapter, AdaBoost has been successfully used for learning to detect faces in
images.

10.1

Weak Learnability
Recall the definition of PAC learning given in Chapter 3: A hypothesis class,
H, is PAC learnable if there exist mH : (0, 1)2 â†’ N and a learning algorithm
with the following property: For every , Î´ âˆˆ (0, 1), for every distribution D over
X , and for every labeling function f : X â†’ {Â±1}, if the realizable assumption
holds with respect to H, D, f , then when running the learning algorithm on
m â‰¥ mH (, Î´) i.i.d. examples generated by D and labeled by f , the algorithm
returns a hypothesis h such that, with probability of at least 1âˆ’Î´, L(D,f ) (h) â‰¤ .
Furthermore, the fundamental theorem of learning theory (Theorem 6.8 in
Chapter 6) characterizes the family of learnable classes and states that every PAC
learnable class can be learned using any ERM algorithm. However, the definition
of PAC learning and the fundamental theorem of learning theory ignores the
computational aspect of learning. Indeed, as we have shown in Chapter 8, there
are cases in which implementing the ERM rule is computationally hard (even in
the realizable case).
However, perhaps we can trade computational hardness with the requirement
for accuracy. Given a distribution D and a target labeling function f , maybe there
exists an efficiently computable learning algorithm whose error is just slightly
better than a random guess? This motivates the following definition.
definition 10.1 (Î³-Weak-Learnability)
â€¢ A learning algorithm, A, is a Î³-weak-learner for a class H if there exists a function mH : (0, 1) â†’ N such that for every Î´ âˆˆ (0, 1), for every distribution
D over X , and for every labeling function f : X â†’ {Â±1}, if the realizable
assumption holds with respect to H, D, f , then when running the learning
algorithm on m â‰¥ mH (Î´) i.i.d. examples generated by D and labeled by f ,
the algorithm returns a hypothesis h such that, with probability of at least
1 âˆ’ Î´, L(D,f ) (h) â‰¤ 1/2 âˆ’ Î³.
â€¢ A hypothesis class H is Î³-weak-learnable if there exists a Î³-weak-learner for
that class.

132

Boosting

This definition is almost identical to the definition of PAC learning, which
here we will call strong learning, with one crucial difference: Strong learnability
implies the ability to find an arbitrarily good classifier (with error rate at most
 for an arbitrarily small  > 0). In weak learnability, however, we only need to
output a hypothesis whose error rate is at most 1/2 âˆ’ Î³, namely, whose error
rate is slightly better than what a random labeling would give us. The hope is
that it may be easier to come up with efficient weak learners than with efficient
(full) PAC learners.
The fundamental theorem of learning (Theorem 6.8) states that if a hypothesis
class H has a VC dimension d, then the sample complexity of PAC learning H
satisfies mH (, Î´) â‰¥ C1 d+log(1/Î´)
, where C1 is a constant. Applying this with

 = 1/2âˆ’Î³ we immediately obtain that if d = âˆž then H is not Î³-weak-learnable.
This implies that from the statistical perspective (i.e., if we ignore computational
complexity), weak learnability is also characterized by the VC dimension of H
and therefore is just as hard as PAC (strong) learning. However, when we do
consider computational complexity, the potential advantage of weak learning is
that maybe there is an algorithm that satisfies the requirements of weak learning
and can be implemented efficiently.
One possible approach is to take a â€œsimpleâ€ hypothesis class, denoted B, and
to apply ERM with respect to B as the weak learning algorithm. For this to
work, we need that B will satisfy two requirements:
â€¢ ERMB is efficiently implementable.
â€¢ For every sample that is labeled by some hypothesis from H, any ERMB
hypothesis will have an error of at most 1/2 âˆ’ Î³.
Then, the immediate question is whether we can boost an efficient weak learner
into an efficient strong learner. In the next section we will show that this is
indeed possible, but before that, let us show an example in which efficient weak
learnability of a class H is possible using a base hypothesis class B.
Example 10.1 (Weak Learning of 3-Piece Classifiers Using Decision Stumps)
Let X = R and let H be the class of 3-piece classifiers, namely, H = {hÎ¸1 ,Î¸2 ,b :
Î¸1 , Î¸2 âˆˆ R, Î¸1 < Î¸2 , b âˆˆ {Â±1}}, where for every x,
(
+b if x < Î¸1 or x > Î¸2
hÎ¸1 ,Î¸2 ,b (x) =
âˆ’b if Î¸1 â‰¤ x â‰¤ Î¸2
An example hypothesis (for b = 1) is illustrated as follows:
âˆ’

+
Î¸1

+
Î¸2

Let B be the class of Decision Stumps, that is, B = {x 7â†’ sign(x âˆ’ Î¸) Â· b : Î¸ âˆˆ
R, b âˆˆ {Â±1}}. In the following we show that ERMB is a Î³-weak learner for H,
for Î³ = 1/12.

10.1 Weak Learnability

133

To see that, we first show that for every distribution that is consistent with
H, there exists a decision stump with LD (h) â‰¤ 1/3. Indeed, just note that
every classifier in H consists of three regions (two unbounded rays and a center
interval) with alternate labels. For any pair of such regions, there exists a decision
stump that agrees with the labeling of these two components. Note that for every
distribution D over R and every partitioning of the line into three such regions,
one of these regions must have D-weight of at most 1/3. Let h âˆˆ H be a zero
error hypothesis. A decision stump that disagrees with h only on such a region
has an error of at most 1/3.
Finally, since the VC-dimension of decision stumps is 2, if the sample size is
greater than â„¦(log(1/Î´)/2 ), then with probability of at least 1 âˆ’ Î´, the ERMB
rule returns a hypothesis with an error of at most 1/3 + . Setting  = 1/12 we
obtain that the error of ERMB is at most 1/3 + 1/12 = 1/2 âˆ’ 1/12.
We see that ERMB is a Î³-weak learner for H. We next show how to implement
the ERM rule efficiently for decision stumps.

10.1.1

Efficient Implementation of ERM for Decision Stumps
Let X = Rd and consider the base hypothesis class of decision stumps over Rd ,
namely,
HDS = {x 7â†’ sign(Î¸ âˆ’ xi ) Â· b : Î¸ âˆˆ R, i âˆˆ [d], b âˆˆ {Â±1}}.
For simplicity, assume that b = 1; that is, we focus on all the hypotheses in
HDS of the form sign(Î¸ âˆ’ xi ). Let S = ((x1 , y1 ), . . . , (xm , ym )) be a training set.
We will show how to implement an ERM rule, namely, how to find a decision
stump that minimizes LS (h). Furthermore, since in the next section we will
show that AdaBoost requires finding a hypothesis with a small risk relative to
some distribution over S, we will show here how to minimize such risk functions.
Concretely, let D be a probability vector in Rm (that is, all elements of D are
P
nonnegative and i Di = 1). The weak learner we describe later receives D and
S and outputs a decision stump h : X â†’ Y that minimizes the risk w.r.t. D,
LD (h) =

m
X

Di 1[h(xi )6=yi ] .

i=1

Note that if D = (1/m, . . . , 1/m) then LD (h) = LS (h).
Recall that each decision stump is parameterized by an index j âˆˆ [d] and a
threshold Î¸. Therefore, minimizing LD (h) amounts to solving the problem
ï£«
ï£¶
X
X
min min ï£­
Di 1[xi,j >Î¸] +
Di 1[xi,j â‰¤Î¸] ï£¸ .
(10.1)
jâˆˆ[d]

Î¸âˆˆR

i:yi =1

i:yi =âˆ’1

Fix j âˆˆ [d] and let us sort the examples so that x1,j â‰¤ x2,j â‰¤ . . . â‰¤ xm,j . Define
x +x
Î˜j = { i,j 2 i+1,j : i âˆˆ [m âˆ’ 1]} âˆª {(x1,j âˆ’ 1), (xm,j + 1)}. Note that for any Î¸ âˆˆ R
there exists Î¸0 âˆˆ Î˜j that yields the same predictions for the sample S as the

134

Boosting

threshold Î¸. Therefore, instead of minimizing over Î¸ âˆˆ R we can minimize over
Î¸ âˆˆ Î˜j .
This already gives us an efficient procedure: Choose j âˆˆ [d] and Î¸ âˆˆ Î˜j that
minimize the objective value of Equation (10.1). For every j and Î¸ âˆˆ Î˜j we
have to calculate a sum over m examples; therefore the runtime of this approach
would be O(dm2 ). We next show a simple trick that enables us to minimize the
objective in time O(dm).
The observation is as follows. Suppose we have calculated the objective for
Î¸ âˆˆ (xiâˆ’1,j , xi,j ). Let F (Î¸) be the value of the objective. Then, when we consider
Î¸0 âˆˆ (xi,j , xi+1,j ) we have that
F (Î¸0 ) = F (Î¸) âˆ’ Di 1[yi =1] + Di 1[yi =âˆ’1] = F (Î¸) âˆ’ yi Di .
Therefore, we can calculate the objective at Î¸0 in a constant time, given the
objective at the previous threshold, Î¸. It follows that after a preprocessing step
in which we sort the examples with respect to each coordinate, the minimization
problem can be performed in time O(dm). This yields the following pseudocode.
ERM for Decision Stumps
input:
training set S = (x1 , y1 ), . . . , (xm , ym )
distribution vector D
goal: Find j ? , Î¸? that solve Equation (10.1)
initialize: F ? = âˆž
for j = 1, . . . , d
sort S using the jâ€™th coordinate, and denote
def

x1,j â‰¤ x2,j â‰¤ Â· Â· Â· â‰¤ xm,j â‰¤ xm+1,j = xm,j + 1
P
F = i:yi =1 Di
if F < F ?
F ? = F , Î¸? = x1,j âˆ’ 1, j ? = j
for i = 1, . . . , m
F = F âˆ’ yi Di
if F < F ? and xi,j 6= xi+1,j
F ? = F , Î¸? = 21 (xi,j + xi+1,j ), j ? = j
output j ? , Î¸?

10.2

AdaBoost
AdaBoost (short for Adaptive Boosting) is an algorithm that has access to a
weak learner and finds a hypothesis with a low empirical risk. The AdaBoost
algorithm receives as input a training set of examples S = (x1 , y1 ), . . . , (xm , ym ),
where for each i, yi = f (xi ) for some labeling function f . The boosting process
proceeds in a sequence of consecutive rounds. At round t, the booster first defines

10.2 AdaBoost

135

a distribution over the examples in S, denoted D(t) . That is, D(t) âˆˆ Rm
+ and
Pm
(t)
(t)
and the sample S
i=1 Di = 1. Then, the booster passes the distribution D
to the weak learner. (That way, the weak learner can construct i.i.d. examples
according to D(t) and f .) The weak learner is assumed to return a â€œweakâ€
hypothesis, ht , whose error,
def

def

t = LD(t) (ht ) =

m
X

(t)

Di 1[ht (xi )6=yi ] ,

i=1

is at most 12 âˆ’Î³ (of course, there is a probability of at most Î´ that the weak
 learner


fails). Then, AdaBoost assigns a weight for ht as follows: wt = 12 log 1t âˆ’ 1 .
That is, the weight of ht is inversely proportional to the error of ht . At the end
of the round, AdaBoost updates the distribution so that examples on which ht
errs will get a higher probability mass while examples on which ht is correct will
get a lower probability mass. Intuitively, this will force the weak learner to focus
on the problematic examples in the next round. The output of the AdaBoost
algorithm is a â€œstrongâ€ classifier that is based on a weighted sum of all the weak
hypotheses. The pseudocode of AdaBoost is presented in the following.
AdaBoost
input:
training set S = (x1 , y1 ), . . . , (xm , ym )
weak learner WL
number of rounds T
1
1
,..., m
).
initialize D(1) = ( m
for t = 1, . . . , T :
invoke weak learner ht = WL(D(t) , S)
Pm
(t)
compute t =  i=1 Di 1[yi 6=ht (xi )]
let wt =

1
2

log

(t+1)

update Di

1
t

âˆ’1

(t)

=

D
Pm i

output the hypothesis

exp(âˆ’wt yi ht (xi ))
(t)

exp(âˆ’wt yj ht (xj ))
P
T
hs (x) = sign
t=1

j=1

Dj

for all i = 1, . . . , m

wt ht (x) .

The following theorem shows that the training error of the output hypothesis
decreases exponentially fast with the number of boosting rounds.
theorem 10.2 Let S be a training set and assume that at each iteration of
AdaBoost, the weak learner returns a hypothesis for which t â‰¤ 1/2 âˆ’ Î³. Then,
the training error of the output hypothesis of AdaBoost is at most
m

LS (hs ) =
Proof

1 X
1[h (x )6=y ] â‰¤ exp(âˆ’2 Î³ 2 T ) .
m i=1 s i i

For each t, denote ft =

P

pâ‰¤t

wp hp . Therefore, the output of AdaBoost

136

Boosting

is fT . In addition, denote
m

Zt =

1 X âˆ’yi ft (xi )
e
.
m i=1

Note that for any hypothesis we have that 1[h(x)6=y] â‰¤ eâˆ’yh(x) . Therefore, LS (fT ) â‰¤
2
ZT , so it suffices to show that ZT â‰¤ eâˆ’2Î³ T . To upper bound ZT we rewrite it
as
ZT
ZT
ZT âˆ’1
Z2 Z1
ZT =
=
Â·
Â·Â·Â·
Â·
,
(10.2)
Z0
ZT âˆ’1 ZT âˆ’2
Z1 Z0
where we used the fact that Z0 = 1 because f0 â‰¡ 0. Therefore, it suffices to show
that for every round t,
2
Zt+1
â‰¤ eâˆ’2Î³ .
(10.3)
Zt
To do so, we first note that using a simple inductive argument, for all t and i,
(t+1)

Di

eâˆ’yi ft (xi )
= Pm âˆ’y f (x ) .
j t
j
j=1 e

Hence,
Zt+1
=
Zt

=

Pm

i=1
m
P

eâˆ’yi ft+1 (xi )
eâˆ’yj ft (xj )

j=1
Pm âˆ’yi ft (xi ) âˆ’yi wt+1 ht+1 (xi )
e
i=1 e
m
P
eâˆ’yj ft (xj )
j=1

=

m
X

(t+1) âˆ’yi wt+1 ht+1 (xi )

Di

e

i=1

= eâˆ’wt+1

X

(t+1)

Di

i:yi ht+1 (xi )=1
âˆ’wt+1

+ ewt+1

X

(t+1)

Di

i:yi ht+1 (xi )=âˆ’1
wt+1

(1 âˆ’ t+1 ) + e
t+1
p
1
=p
(1 âˆ’ t+1 ) + 1/t+1 âˆ’ 1 t+1
1/t+1 âˆ’ 1
s
r
t+1
1 âˆ’ t+1
=
(1 âˆ’ t+1 ) +
t+1
1 âˆ’ t+1
t+1
p
= 2 t+1 (1 âˆ’ t+1 ).
=e

By our assumption, t+1 â‰¤ 21 âˆ’ Î³. Since the function g(a) = a(1 âˆ’ a) is monotonically increasing in [0, 1/2], we obtain that
s

 p
p
1
1
2 t+1 (1 âˆ’ t+1 ) â‰¤ 2
âˆ’Î³
+ Î³ = 1 âˆ’ 4Î³ 2 .
2
2

10.3 Linear Combinations of Base Hypotheses

137

p
2
Finally, using the inequality 1 âˆ’ a â‰¤ eâˆ’a we have that 1 âˆ’ 4Î³ 2 â‰¤ eâˆ’4Î³ /2 =
2
eâˆ’2Î³ . This shows that Equation (10.3) holds and thus concludes our proof.
Each iteration of AdaBoost involves O(m) operations as well as a single call to
the weak learner. Therefore, if the weak learner can be implemented efficiently
(as happens in the case of ERM with respect to decision stumps) then the total
training process will be efficient.
Remark 10.2 Theorem 10.2 assumes that at each iteration of AdaBoost, the
weak learner returns a hypothesis with weighted sample error of at most 1/2 âˆ’ Î³.
According to the definition of a weak learner, it can fail with probability Î´. Using
the union bound, the probability that the weak learner will not fail at all of the
iterations is at least 1 âˆ’ Î´T . As we show in Exercise 1, the dependence of the
sample complexity on Î´ can always be logarithmic in 1/Î´, and therefore invoking
the weak learner with a very small Î´ is not problematic. We can therefore assume
that Î´T is also small. Furthermore, since the weak learner is only applied with
distributions over the training set, in many cases we can implement the weak
learner so that it will have a zero probability of failure (i.e., Î´ = 0). This is the
case, for example, in the weak learner that finds the minimum value of LD (h)
for decision stumps, as described in the previous section.
Theorem 10.2 tells us that the empirical risk of the hypothesis constructed by
AdaBoost goes to zero as T grows. However, what we really care about is the
true risk of the output hypothesis. To argue about the true risk, we note that the
output of AdaBoost is in fact a composition of a halfspace over the predictions
of the T weak hypotheses constructed by the weak learner. In the next section
we show that if the weak hypotheses come from a base hypothesis class of low
VC-dimension, then the estimation error of AdaBoost will be small; namely, the
true risk of the output of AdaBoost would not be very far from its empirical risk.

10.3

Linear Combinations of Base Hypotheses
As mentioned previously, a popular approach for constructing a weak learner
is to apply the ERM rule with respect to a base hypothesis class (e.g., ERM
over decision stumps). We have also seen that boosting outputs a composition
of a halfspace over the predictions of the weak hypotheses. Therefore, given a
base hypothesis class B (e.g., decision stumps), the output of AdaBoost will be
a member of the following class:
(
!
)
T
X
T
L(B, T ) = x 7â†’ sign
wt ht (x) : w âˆˆ R , âˆ€t, ht âˆˆ B .
(10.4)
t=1

That is, each h âˆˆ L(B, T ) is parameterized by T base hypotheses from B and
by a vector w âˆˆ RT . The prediction of such an h on an instance x is obtained by first applying the T base hypotheses to construct the vector Ïˆ(x) =

138

Boosting

(h1 (x), . . . , hT (x)) âˆˆ RT , and then applying the (homogenous) halfspace defined
by w on Ïˆ(x).
In this section we analyze the estimation error of L(B, T ) by bounding the
VC-dimension of L(B, T ) in terms of the VC-dimension of B and T . We will
show that, up to logarithmic factors, the VC-dimension of L(B, T ) is bounded
by T times the VC-dimension of B. It follows that the estimation error of AdaBoost grows linearly with T . On the other hand, the empirical risk of AdaBoost
decreases with T . In fact, as we demonstrate later, T can be used to decrease
the approximation error of L(B, T ). Therefore, the parameter T of AdaBoost
enables us to control the bias-complexity tradeoff.
To demonstrate how the expressive power of L(B, T ) increases with T , consider
the simple example, in which X = R and the base class is Decision Stumps,
HDS1 = {x 7â†’ sign(x âˆ’ Î¸) Â· b : Î¸ âˆˆ R, b âˆˆ {Â±1}}.
Note that in this one dimensional case, HDS1 is in fact equivalent to (nonhomogenous) halfspaces on R.
Now, let H be the rather complex class (compared to halfspaces on the line)
of piece-wise constant functions. Let gr be a piece-wise constant function with at
most r pieces; that is, there exist thresholds âˆ’âˆž = Î¸0 < Î¸1 < Î¸2 < Â· Â· Â· < Î¸r = âˆž
such that
r
X
gr (x) =
Î±i 1[xâˆˆ(Î¸iâˆ’1 ,Î¸i ]] âˆ€i, Î±i âˆˆ {Â±1}.
i=1

Denote by Gr the class of all such piece-wise constant classifiers with at most r
pieces.
In the following we show that GT âŠ† L(HDS1 , T ); namely, the class of halfspaces
over T decision stumps yields all the piece-wise constant classifiers with at most
T pieces.
Indeed, without loss of generality consider any g âˆˆ GT with Î±t = (âˆ’1)t . This
implies that if x is in the interval (Î¸tâˆ’1 , Î¸t ], then g(x) = (âˆ’1)t . For example:

Now, the function
h(x) = sign

T
X

!
wt sign(x âˆ’ Î¸tâˆ’1 ) ,

(10.5)

t=1

where w1 = 0.5 and for t > 1, wt = (âˆ’1)t , is in L(HDS1 , T ) and is equal to g
(see Exercise 2).

10.3 Linear Combinations of Base Hypotheses

139

From this example we obtain that L(HDS1 , T ) can shatter any set of T + 1
instances in R; hence the VC-dimension of L(HDS1 , T ) is at least T +1. Therefore,
T is a parameter that can control the bias-complexity tradeoff: Enlarging T
yields a more expressive hypothesis class but on the other hand might increase
the estimation error. In the next subsection we formally upper bound the VCdimension of L(B, T ) for any base class B.

10.3.1

The VC-Dimension of L(B, T )
The following lemma tells us that the VC-dimension of L(B, T ) is upper bounded
by OÌƒ(VCdim(B) T ) (the OÌƒ notation ignores constants and logarithmic factors).
lemma 10.3 Let B be a base class and let L(B, T ) be as defined in Equation (10.4). Assume that both T and VCdim(B) are at least 3. Then,
VCdim(L(B, T )) â‰¤ T (VCdim(B) + 1) (3 log(T (VCdim(B) + 1)) + 2).
Proof Denote d = VCdim(B). Let C = {x1 , . . . , xm } be a set that is shattered by L(B, T ). Each labeling of C by h âˆˆ L(B, T ) is obtained by first choosing h1 , . . . , hT âˆˆ B and then applying a halfspace hypothesis over the vector
(h1 (x), . . . , hT (x)). By Sauerâ€™s lemma, there are at most (em/d)d different dichotomies (i.e., labelings) induced by B over C. Therefore, we need to choose
T hypotheses, out of at most (em/d)d different hypotheses. There are at most
(em/d)dT ways to do it. Next, for each such choice, we apply a linear predictor,
which yields at most (em/T )T dichotomies. Therefore, the overall number of
dichotomies we can construct is upper bounded by
(em/d)dT (em/T )T â‰¤ m(d+1)T ,
where we used the assumption that both d and T are at least 3. Since we assume
that C is shattered, we must have that the preceding is at least 2m , which yields
2m â‰¤ m(d+1)T .
Therefore,
m â‰¤ log(m)

(d + 1)T
.
log(2)

Lemma A.1 in Chapter A tells us that a necessary condition for the above to
hold is that
mâ‰¤2

(d + 1)T
(d + 1)T
log
â‰¤ (d + 1)T (3 log((d + 1)T ) + 2),
log(2)
log(2)

which concludes our proof.
In Exercise 4 we show that for some base classes, B, it also holds that VCdim(L(B, T )) â‰¥
â„¦(VCdim(B) T ).

140

Boosting

A

B

C

D

Figure 10.1 The four types of functions, g, used by the base hypotheses for face
recognition. The value of g for type A or B is the difference between the sum of the
pixels within two rectangular regions. These regions have the same size and shape and
are horizontally or vertically adjacent. For type C, the value of g is the sum within
two outside rectangles subtracted from the sum in a center rectangle. For type D, we
compute the difference between diagonal pairs of rectangles.

10.4

AdaBoost for Face Recognition
We now turn to a base hypothesis that has been proposed by Viola and Jones for
the task of face recognition. In this task, the instance space is images, represented
as matrices of gray level values of pixels. To be concrete, let us take images of
size 24 Ã— 24 pixels, and therefore our instance space is the set of real valued
matrices of size 24 Ã— 24. The goal is to learn a classifier, h : X â†’ {Â±1}, that
given an image as input, should output whether the image is of a human face or
not.
Each hypothesis in the base class is of the form h(x) = f (g(x)), where f is a
decision stump hypothesis and g : R24,24 â†’ R is a function that maps an image
to a scalar. Each function g is parameterized by
â€¢ An axis aligned rectangle R. Since each image is of size 24 Ã— 24, there are at
most 244 axis aligned rectangles.
â€¢ A type, t âˆˆ {A, B, C, D}. Each type corresponds to a mask, as depicted in
Figure 10.1.
To calculate g we stretch the mask t to fit the rectangle R and then calculate
the sum of the pixels (that is, sum of their gray level values) that lie within the
red rectangles and subtract it from the sum of pixels in the blue rectangles.
Since the number of such functions g is at most 244 Â· 4, we can implement a
weak learner for the base hypothesis class by first calculating all the possible
outputs of g on each image, and then apply the weak learner of decision stumps
described in the previous subsection. It is possible to perform the first step very

10.5 Summary

141

Figure 5: The first and second features selected by AdaBoost. The two features are shown in the top row

Figureand
10.2
firstonand
second
as implemented
then The
overlayed
a typical
trainingfeatures
face in the selected
bottom row.by
TheAdaBoost,
first feature measures
the difference inby

Viola intensity
and Jones.
twooffeatures
are
shown
inthe
the
topcheeks.
row The
andfeature
thencapitalizes
overlaid
on a
betweenThe
the region
the eyes and
a region
across
upper
on the
observation
thatface
the eye
is often darker
thanThe
the cheeks.
The secondmeasures
feature compares
the intensities in
typical
training
inregion
the bottom
row.
first feature
the difference
in thebetween
eye regions the
to theregion
intensity of
across
bridgeand
of thea nose.
intensity
thetheeyes
region across the upper cheeks. The
feature capitalizes on the observation that the eye region is often darker than the
directly increases computation time.
cheeks.
The second feature compares the intensities in the eye regions to the intensity
across the bridge of the nose.
4 The Attentional Cascade
This section
an algorithm for step
constructing
a cascadewe
of classifiers
which the
achieves
increased image
detecefficiently
by describes
a preprocessing
in which
calculate
integral
of
performance while radically reducing computation time. The key insight is that smaller, and therefore
each tion
image
in the training set. See Exercise 5 for details.
more efficient, boosted classifiers can be constructed which reject many of the negative sub-windows while
In Figure 10.2 we depict the first two features selected by AdaBoost when
detecting almost all positive instances. Simpler classifiers are used to reject the majority of sub-windows
running
it with the base features proposed by Viola and Jones.
before more complex classifiers are called upon to achieve low false positive rates.
Stages in the cascade are constructed by training classifiers using AdaBoost. Starting with a two-feature
strong classifier, an effective face filter can be obtained by adjusting the strong classifier threshold to min-

10.5

imize false negatives. The initial AdaBoost threshold,
Summary

, is designed to yield a low error rate on

the training data. A lower threshold yields higher detection rates and higher false positive rates. Based on
performance measured using a validation training set, the two-feature classifier can be adjusted to detect

Boosting is a method for amplifying the accuracy of weak learners. In this chapter
100% of the faces with a false positive rate of 40%. See Figure 5 for a description of the two features used
we described
the AdaBoost algorithm. We have shown that after T iterations of
in this classifier.
AdaBoost,
it
returns
a hypothesis
fromclassifier
the class
T ), obtained
by detection
composing
The detection performance
of the two-feature
is farL(B,
from acceptable
as an object
a linear
classifier
ontheTclassifier
hypotheses
fromreduce
a base
classsub-windows
B. We have
demonstrated
system.
Nevertheless
can significantly
the number
that need
further prohow the
parameter
controls the tradeoff between approximation and estimation
cessing
with very fewToperations:
errors. In
the next chapter we will study how to tune parameters such as T , based
1. Evaluate the rectangle features (requires between 6 and 9 array references per feature).
on the data.
2. Compute the weak classifier for each feature (requires one threshold operation per feature).
11

10.6

Bibliographic Remarks
As mentioned before, boosting stemmed from the theoretical question of whether
an efficient weak learner can be â€œboostedâ€ into an efficient strong learner (Kearns
& Valiant 1988) and solved by Schapire (1990). The AdaBoost algorithm has
been proposed in Freund & Schapire (1995).
Boosting can be viewed from many perspectives. In the purely theoretical
context, AdaBoost can be interpreted as a negative result: If strong learning of
a hypothesis class is computationally hard, so is weak learning of this class. This
negative result can be useful for showing hardness of agnostic PAC learning of
a class B based on hardness of PAC learning of some other class H, as long as

142

Boosting

H is weakly learnable using B. For example, Klivans & Sherstov (2006) have
shown that PAC learning of the class of intersection of halfspaces is hard (even
in the realizable case). This hardness result can be used to show that agnostic
PAC learning of a single halfspace is also computationally hard (Shalev-Shwartz,
Shamir & Sridharan 2010). The idea is to show that an agnostic PAC learner
for a single halfspace can yield a weak learner for the class of intersection of
halfspaces, and since such a weak learner can be boosted, we will obtain a strong
learner for the class of intersection of halfspaces.
AdaBoost also shows an equivalence between the existence of a weak learner
and separability of the data using a linear classifier over the predictions of base
hypotheses. This result is closely related to von Neumannâ€™s minimax theorem
(von Neumann 1928), a fundamental result in game theory.
AdaBoost is also related to the concept of margin, which we will study later on
in Chapter 15. It can also be viewed as a forward greedy selection algorithm, a
topic that will be presented in Chapter 25. A recent book by Schapire & Freund
(2012) covers boosting from all points of view, and gives easy access to the wealth
of research that this field has produced.

10.7

Exercises
1. Boosting the Confidence: Let A be an algorithm that guarantees the following: There exist some constant Î´0 âˆˆ (0, 1) and a function mH : (0, 1) â†’ N
such that for every  âˆˆ (0, 1), if m â‰¥ mH () then for every distribution D it
holds that with probability of at least 1 âˆ’ Î´0 , LD (A(S)) â‰¤ minhâˆˆH LD (h) + .
Suggest a procedure that relies on A and learns H in the usual agnostic
PAC learning model and has a sample complexity of


2 log(4k/Î´)
,
mH (, Î´) â‰¤ k mH () +
2
where
k = dlog(Î´)/ log(Î´0 )e.
Hint: Divide the data into k + 1 chunks, where each of the first k chunks
is of size mH () examples. Train the first k chunks using A. Argue that the
probability that for all of these chunks we have LD (A(S)) > minhâˆˆH LD (h)+
is at most Î´0k â‰¤ Î´/2. Finally, use the last chunk to choose from the k hypotheses
that A generated from the k chunks (by relying on Corollary 4.6).
2. Prove that the function h given in Equation (10.5) equals the piece-wise constant function defined according to the same thresholds as h.
3. We have informally argued that the AdaBoost algorithm uses the weighting
mechanism to â€œforceâ€ the weak learner to focus on the problematic examples
in the next iteration. In this question we will find some rigorous justification
for this argument.

10.7 Exercises

143

Show that the error of ht w.r.t. the distribution D(t+1) is exactly 1/2. That
is, show that for every t âˆˆ [T ]
m
X

(t+1)

Di

1[yi 6=ht (xi )] = 1/2.

i=1

4. In this exercise we discuss the VC-dimension of classes of the form L(B, T ).
We proved an upper bound of O(dT log(dT )), where d = VCdim(B). Here we
wish to prove an almost matching lower bound. However, that will not be the
case for all classes B.
1. Note that for every class B and every number T â‰¥ 1, VCdim(B) â‰¤
VCdim(L(B, T )). Find a class B for which VCdim(B) = VCdim(L(B, T ))
for every T â‰¥ 1.
Hint: Take X to be a finite set.
2. Let Bd be the class of decision stumps over Rd . Prove that log(d) â‰¤
VCdim(Bd ) â‰¤ 5 + 2 log(d).
Hints:
â€¢ For the upper bound, rely on Exercise 11.
â€¢ For the lower bound, assume d = 2k . Let A be a k Ã— d matrix whose
columns are all the d binary vectors in {Â±1}k . The rows of A form
a set of k vectors in Rd . Show that this set is shattered by decision
stumps over Rd .
3. Let T â‰¥ 1 be any integer. Prove that VCdim(L(Bd , T )) â‰¥ 0.5 T log(d).
Hint: Construct a set of T2 k instances by taking the rows of the matrix A
from the previous question, and the rows of the matrices 2A, 3A, 4A, . . . , T2 A.
Show that the resulting set is shattered by L(Bd , T ).
5. Efficiently Calculating the Viola and Jones Features Using an Integral Image: Let A be a 24 Ã— 24 matrix representing an image. The integral
P
image of A, denoted by I(A), is the matrix B such that Bi,j = i0 â‰¤i,j 0 â‰¤j Ai,j .
â€¢ Show that I(A) can be calculated from A in time linear in the size of A.
â€¢ Show how every Viola and Jones feature can be calculated from I(A) in a
constant amount of time (that is, the runtime does not depend on the
size of the rectangle defining the feature).

11 Model Selection and Validation

In the previous chapter we have described the AdaBoost algorithm and have
shown how the parameter T of AdaBoost controls the bias-complexity tradeoff. But, how do we set T in practice? More generally, when approaching some
practical problem, we usually can think of several algorithms that may yield a
good solution, each of which might have several parameters. How can we choose
the best algorithm for the particular problem at hand? And how do we set the
algorithmâ€™s parameters? This task is often called model selection.
To illustrate the model selection task, consider the problem of learning a one
dimensional regression function, h : R â†’ R. Suppose that we obtain a training
set as depicted in the figure.

We can consider fitting a polynomial to the data, as described in Chapter 9.
However, we might be uncertain regarding which degree d would give the best
results for our data set: A small degree may not fit the data well (i.e., it will
have a large approximation error), whereas a high degree may lead to overfitting
(i.e., it will have a large estimation error). In the following we depict the result
of fitting a polynomial of degrees 2, 3, and 10. It is easy to see that the empirical
risk decreases as we enlarge the degree. However, looking at the graphs, our
intuition tells us that setting the degree to 3 may be better than setting it to 10.
It follows that the empirical risk alone is not enough for model selection.
degree 2

degree 3

degree 10

c 2014 by Shai Shalev-Shwartz and Shai Ben-David
Understanding Machine Learning, 
Published 2014 by Cambridge University Press.
Personal use only. Not for distribution. Do not post.
Please link to http://www.cs.huji.ac.il/~shais/UnderstandingMachineLearning

11.1 Model Selection Using SRM

145

In this chapter we will present two approaches for model selection. The first
approach is based on the Structural Risk Minimization (SRM) paradigm we
have described and analyzed in Chapter 7.2. SRM is particularly useful when
a learning algorithm depends on a parameter that controls the bias-complexity
tradeoff (such as the degree of the fitted polynomial in the preceding example
or the parameter T in AdaBoost). The second approach relies on the concept
of validation. The basic idea is to partition the training set into two sets. One
is used for training each of the candidate models, and the second is used for
deciding which of them yields the best results.
In model selection tasks, we try to find the right balance between approximation and estimation errors. More generally, if our learning algorithm fails to
find a predictor with a small risk, it is important to understand whether we
suffer from overfitting or underfitting. In Section 11.3 we discuss how this can
be achieved.

11.1

Model Selection Using SRM
The SRM paradigm has been described and analyzed in Section 7.2. Here we
show how SRM can be used for tuning the tradeoff between bias and complexity
without deciding on a specific hypothesis class in advance. Consider a countable
sequence of hypothesis classes H1 , H2 , H3 , . . .. For example, in the problem of
polynomial regression mentioned, we can take Hd to be the set of polynomials
of degree at most d. Another example is taking Hd to be the class L(B, d) used
by AdaBoost, as described in the previous chapter.
We assume that for every d, the class Hd enjoys the uniform convergence
property (see Definition 4.3 in Chapter 4) with a sample complexity function of
the form
g(d) log(1/Î´)
,
(11.1)
mUC
Hd (, Î´) â‰¤
2
where g : N â†’ R is some monotonically increasing function. For example, in the
case of binary classification problems, we can take g(d) to be the VC-dimension
of the class Hd multiplied by a universal constant (the one appearing in the
fundamental theorem of learning; see Theorem 6.8). For the classes L(B, d) used
by AdaBoost, the function g will simply grow with d.
Recall that the SRM rule follows a â€œbound minimizationâ€ approach, where in
our case the bound is as follows: With probability of at least 1 âˆ’ Î´, for every
d âˆˆ N and h âˆˆ Hd ,
r
g(d)(log(1/Î´) + 2 log(d) + log(Ï€ 2 /6))
LD (h) â‰¤ LS (h) +
.
(11.2)
m
This bound, which follows directly from Theorem 7.4, shows that for every d and
every h âˆˆ Hd , the true risk is bounded by two terms â€“ the empirical risk, LS (h),

146

Model Selection and Validation

and a complexity term that depends on d. The SRM rule will search for d and
h âˆˆ Hd that minimize the right-hand side of Equation (11.2).
Getting back to the example of polynomial regression described earlier, even
though the empirical risk of the 10th degree polynomial is smaller than that of
the 3rd degree polynomial, we would still prefer the 3rd degree polynomial since
its complexity (as reflected by the value of the function g(d)) is much smaller.
While the SRM approach can be useful in some situations, in many practical
cases the upper bound given in Equation (11.2) is pessimistic. In the next section
we present a more practical approach.

11.2

Validation
We would often like to get a better estimation of the true risk of the output predictor of a learning algorithm. So far we have derived bounds on the estimation
error of a hypothesis class, which tell us that for all hypotheses in the class, the
true risk is not very far from the empirical risk. However, these bounds might be
loose and pessimistic, as they hold for all hypotheses and all possible data distributions. A more accurate estimation of the true risk can be obtained by using
some of the training data as a validation set, over which one can evalutate the
success of the algorithmâ€™s output predictor. This procedure is called validation.
Naturally, a better estimation of the true risk is useful for model selection, as
we will describe in Section 11.2.2.

11.2.1

Hold Out Set
The simplest way to estimate the true error of a predictor h is by sampling an additional set of examples, independent of the training set, and using the empirical
error on this validation set as our estimator. Formally, let V = (x1 , y1 ), . . . , (xmv , ymv )
be a set of fresh mv examples that are sampled according to D (independently of
the m examples of the training set S). Using Hoeffdingâ€™s inequality ( Lemma 4.5)
we have the following:
theorem 11.1 Let h be some predictor and assume that the loss function is in
[0, 1]. Then, for every Î´ âˆˆ (0, 1), with probability of at least 1 âˆ’ Î´ over the choice
of a validation set V of size mv we have
s
log(2/Î´)
.
|LV (h) âˆ’ LD (h)| â‰¤
2 mv
The bound in Theorem 11.1 does not depend on the algorithm or the training
set used to construct h and is tighter than the usual bounds that we have seen so
far. The reason for the tightness of this bound is that it is in terms of an estimate
on a fresh validation set that is independent of the way h was generated. To
illustrate this point, suppose that h was obtained by applying an ERM predictor

11.2 Validation

147

with respect to a hypothesis class of VC-dimension d, over a training set of m
examples. Then, from the fundamental theorem of learning (Theorem 6.8) we
obtain the bound
r
d + log(1/Î´)
LD (h) â‰¤ LS (h) + C
,
m
where C is the constant appearing in Theorem 6.8. In contrast, from Theorem 11.1 we obtain the bound
s
log(2/Î´)
LD (h) â‰¤ LV (h) +
.
2mv
Therefore, taking mv to be order of m, we obtain an estimate that is more
accurate by a factor that depends on the VC-dimension. On the other hand, the
price we pay for using such an estimate is that it requires an additional sample
on top of the sample used for training the learner.
Sampling a training set and then sampling an independent validation set is
equivalent to randomly partitioning our random set of examples into two parts,
using one part for training and the other one for validation. For this reason, the
validation set is often referred to as a hold out set.

11.2.2

Validation for Model Selection
Validation can be naturally used for model selection as follows. We first train
different algorithms (or the same algorithm with different parameters) on the
given training set. Let H = {h1 , . . . , hr } be the set of all output predictors of the
different algorithms. For example, in the case of training polynomial regressors,
we would have each hr be the output of polynomial regression of degree r. Now,
to choose a single predictor from H we sample a fresh validation set and choose
the predictor that minimizes the error over the validation set. In other words,
we apply ERMH over the validation set.
This process is very similar to learning a finite hypothesis class. The only
difference is that H is not fixed ahead of time but rather depends on the training set. However, since the validation set is independent of the training set we
get that it is also independent of H and therefore the same technique we used
to derive bounds for finite hypothesis classes holds here as well. In particular,
combining Theorem 11.1 with the union bound we obtain:
theorem 11.2 Let H = {h1 , . . . , hr } be an arbitrary set of predictors and
assume that the loss function is in [0, 1]. Assume that a validation set V of size
mv is sampled independent of H. Then, with probability of at least 1 âˆ’ Î´ over the
choice of V we have
s
log(2|H|/Î´)
.
âˆ€h âˆˆ H, |LD (h) âˆ’ LV (h)| â‰¤
2 mv

148

Model Selection and Validation

This theorem tells us that the error on the validation set approximates the
true error as long as H is not too large. However, if we try too many methods
(resulting in |H| that is large relative to the size of the validation set) then weâ€™re
in danger of overfitting.
To illustrate how validation is useful for model selection, consider again the
example of fitting a one dimensional polynomial as described in the beginning
of this chapter. In the following we depict the same training set, with ERM
polynomials of degree 2, 3, and 10, but this time we also depict an additional
validation set (marked as red, unfilled circles). The polynomial of degree 10 has
minimal training error, yet the polynomial of degree 3 has the minimal validation
error, and hence it will be chosen as the best model.

11.2.3

The Model-Selection Curve
The model selection curve shows the training error and validation error as a function of the complexity of the model considered. For example, for the polynomial
fitting problem mentioned previously, the curve will look like:

11.2 Validation

0.4

149

train
validation

error

0.3

0.2

0.1

0
2

4

6

8

10

d
As can be shown, the training error is monotonically decreasing as we increase
the polynomial degree (which is the complexity of the model in our case). On
the other hand, the validation error first decreases but then starts to increase,
which indicates that we are starting to suffer from overfitting.
Plotting such curves can help us understand whether we are searching the
correct regime of our parameter space. Often, there may be more than a single
parameter to tune, and the possible number of values each parameter can take
might be quite large. For example, in Chapter 13 we describe the concept of
regularization, in which the parameter of the learning algorithm is a real number.
In such cases, we start with a rough grid of values for the parameter(s) and plot
the corresponding model-selection curve. On the basis of the curve we will zoom
in to the correct regime and employ a finer grid to search over. It is important to
verify that we are in the relevant regime. For example, in the polynomial fitting
problem described, if we start searching degrees from the set of values {1, 10, 20}
and do not employ a finer grid based on the resulting curve, we will end up with
a rather poor model.

11.2.4

k-Fold Cross Validation
The validation procedure described so far assumes that data is plentiful and that
we have the ability to sample a fresh validation set. But in some applications,
data is scarce and we do not want to â€œwasteâ€ data on validation. The k-fold
cross validation technique is designed to give an accurate estimate of the true
error without wasting too much data.
In k-fold cross validation the original training set is partitioned into k subsets
(folds) of size m/k (for simplicity, assume that m/k is an integer). For each fold,
the algorithm is trained on the union of the other folds and then the error of its
output is estimated using the fold. Finally, the average of all these errors is the

150

Model Selection and Validation

estimate of the true error. The special case k = m, where m is the number of
examples, is called leave-one-out (LOO).
k-Fold cross validation is often used for model selection (or parameter tuning),
and once the best parameter is chosen, the algorithm is retrained using this
parameter on the entire training set. A pseudocode of k-fold cross validation
for model selection is given in the following. The procedure receives as input a
training set, S, a set of possible parameter values, Î˜, an integer, k, representing
the number of folds, and a learning algorithm, A, which receives as input a
training set as well as a parameter Î¸ âˆˆ Î˜. It outputs the best parameter as well
as the hypothesis trained by this parameter on the entire training set.
k-Fold Cross Validation for Model Selection
input:
training set S = (x1 , y1 ), . . . , (xm , ym )
set of parameter values Î˜
learning algorithm A
integer k
partition S into S1 , S2 , . . . , Sk
foreach Î¸ âˆˆ Î˜
for i = 1 . . . k
hi,Î¸ = A(S \ Si ; Î¸)
Pk
error(Î¸) = k1 i=1 LSi (hi,Î¸ )
output
Î¸? = argminÎ¸ [error(Î¸)]
hÎ¸? = A(S; Î¸? )
The cross validation method often works very well in practice. However, it
might sometime fail, as the artificial example given in Exercise 1 shows. Rigorously understanding the exact behavior of cross validation is still an open
problem. Rogers and Wagner (Rogers & Wagner 1978) have shown that for k
local rules (e.g., k Nearest Neighbor; see Chapter 19) the cross validation procedure gives a very good estimate of the true error. Other papers show that cross
validation works for stable algorithms (we will study stability and its relation to
learnability in Chapter 13).

11.2.5

Train-Validation-Test Split
In most practical applications, we split the available examples into three sets.
The first set is used for training our algorithm and the second is used as a
validation set for model selection. After we select the best model, we test the
performance of the output predictor on the third set, which is often called the
â€œtest set.â€ The number obtained is used as an estimator of the true error of the
learned predictor.

11.3 What to Do If Learning Fails

11.3

151

What to Do If Learning Fails
Consider the following scenario: You were given a learning task and have approached it with a choice of a hypothesis class, a learning algorithm, and parameters. You used a validation set to tune the parameters and tested the learned
predictor on a test set. The test results, unfortunately, turn out to be unsatisfactory. What went wrong then, and what should you do next?
There are many elements that can be â€œfixed.â€ The main approaches are listed
in the following:
â€¢ Get a larger sample
â€¢ Change the hypothesis class by:
â€“ Enlarging it
â€“ Reducing it
â€“ Completely changing it
â€“ Changing the parameters you consider
â€¢ Change the feature representation of the data
â€¢ Change the optimization algorithm used to apply your learning rule
In order to find the best remedy, it is essential first to understand the cause
of the bad performance. Recall that in Chapter 5 we decomposed the true error of the learned predictor into approximation error and estimation error. The
approximation error is defined to be LD (h? ) for some h? âˆˆ argminhâˆˆH LD (h),
while the estimation error is defined to be LD (hS ) âˆ’ LD (h? ), where hS is the
learned predictor (which is based on the training set S).
The approximation error of the class does not depend on the sample size or
on the algorithm being used. It only depends on the distribution D and on the
hypothesis class H. Therefore, if the approximation error is large, it will not help
us to enlarge the training set size, and it also does not make sense to reduce the
hypothesis class. What can be beneficial in this case is to enlarge the hypothesis
class or completely change it (if we have some alternative prior knowledge in
the form of a different hypothesis class). We can also consider applying the
same hypothesis class but on a different feature representation of the data (see
Chapter 25).
The estimation error of the class does depend on the sample size. Therefore, if
we have a large estimation error we can make an effort to obtain more training
examples. We can also consider reducing the hypothesis class. However, it doesnâ€™t
make sense to enlarge the hypothesis class in that case.

Error Decomposition Using Validation
We see that understanding whether our problem is due to approximation error
or estimation error is very useful for finding the best remedy. In the previous
section we saw how to estimate LD (hS ) using the empirical risk on a validation
set. However, it is more difficult to estimate the approximation error of the class.

152

Model Selection and Validation

Instead, we give a different error decomposition, one that can be estimated from
the train and validation sets.
LD (hS ) = (LD (hS ) âˆ’ LV (hS )) + (LV (hS ) âˆ’ LS (hS )) + LS (hS ).
The first term, (LD (hS ) âˆ’ LV (hS )), can be bounded quite tightly using Theorem 11.1. Intuitively, when the second term, (LV (hS ) âˆ’ LS (hS )), is large we say
that our algorithm suffers from â€œoverfittingâ€ while when the empirical risk term,
LS (hS ), is large we say that our algorithm suffers from â€œunderfitting.â€ Note that
these two terms are not necessarily good estimates of the estimation and approximation errors. To illustrate this, consider the case in which H is a class of
VC-dimension d, and D is a distribution such that the approximation error of H
with respect to D is 1/4. As long as the size of our training set is smaller than
d we will have LS (hS ) = 0 for every ERM hypothesis. Therefore, the training
risk, LS (hS ), and the approximation error, LD (h? ), can be significantly different.
Nevertheless, as we show later, the values of LS (hS ) and (LV (hS ) âˆ’ LS (hS )) still
provide us useful information.
Consider first the case in which LS (hS ) is large. We can write
LS (hS ) = (LS (hS ) âˆ’ LS (h? )) + (LS (h? ) âˆ’ LD (h? )) + LD (h? ).
When hS is an ERMH hypothesis we have that LS (hS )âˆ’LS (h? ) â‰¤ 0. In addition,
since h? does not depend on S, the term (LS (h? )âˆ’LD (h? )) can be bounded quite
tightly (as in Theorem 11.1). The last term is the approximation error. It follows
that if LS (hS ) is large then so is the approximation error, and the remedy to the
failure of our algorithm should be tailored accordingly (as discussed previously).
Remark 11.1 It is possible that the approximation error of our class is small,
yet the value of LS (hS ) is large. For example, maybe we had a bug in our ERM
implementation, and the algorithm returns a hypothesis hS that is not an ERM.
It may also be the case that finding an ERM hypothesis is computationally hard,
and our algorithm applies some heuristic trying to find an approximate ERM. In
some cases, it is hard to know how good hS is relative to an ERM hypothesis. But,
sometimes it is possible at least to know whether there are better hypotheses.
For example, in the next chapter we will study convex learning problems in
which there are optimality conditions that can be checked to verify whether
our optimization algorithm converged to an ERM solution. In other cases, the
solution may depend on randomness in initializing the algorithm, so we can try
different randomly selected initial points to see whether better solutions pop out.
Next consider the case in which LS (hS ) is small. As we argued before, this
does not necessarily imply that the approximation error is small. Indeed, consider
two scenarios, in both of which we are trying to learn a hypothesis class of
VC-dimension d using the ERM learning rule. In the first scenario, we have a
training set of m < d examples and the approximation error of the class is high.
In the second scenario, we have a training set of m > 2d examples and the

11.3 What to Do If Learning Fails

error

153

error
validation error

vali
da

tion

erro

r

train error

train error
m

m

Figure 11.1 Examples of learning curves. Left: This learning curve corresponds to the

scenario in which the number of examples is always smaller than the VC dimension of
the class. Right: This learning curve corresponds to the scenario in which the
approximation error is zero and the number of examples is larger than the VC
dimension of the class.

approximation error of the class is zero. In both cases LS (hS ) = 0. How can we
distinguish between the two cases?

Learning Curves
One possible way to distinguish between the two cases is by plotting learning
curves. To produce a learning curve we train the algorithm on prefixes of the
data of increasing sizes. For example, we can first train the algorithm on the
first 10% of the examples, then on 20% of them, and so on. For each prefix we
calculate the training error (on the prefix the algorithm is being trained on)
and the validation error (on a predefined validation set). Such learning curves
can help us distinguish between the two aforementioned scenarios. In the first
scenario we expect the validation error to be approximately 1/2 for all prefixes,
as we didnâ€™t really learn anything. In the second scenario the validation error
will start as a constant but then should start decreasing (it must start decreasing
once the training set size is larger than the VC-dimension). An illustration of
the two cases is given in Figure 11.1.
In general, as long as the approximation error is greater than zero we expect
the training error to grow with the sample size, as a larger amount of data points
makes it harder to provide an explanation for all of them. On the other hand,
the validation error tends to decrease with the increase in sample size. If the
VC-dimension is finite, when the sample size goes to infinity, the validation and
train errors converge to the approximation error. Therefore, by extrapolating
the training and validation curves we can try to guess the value of the approximation error, or at least to get a rough estimate on an interval in which the
approximation error resides.
Getting back to the problem of finding the best remedy for the failure of
our algorithm, if we observe that LS (hS ) is small while the validation error is
large, then in any case we know that the size of our training set is not sufficient
for learning the class H. We can then plot a learning curve. If we see that the

154

Model Selection and Validation

validation error is starting to decrease then the best solution is to increase the
number of examples (if we can afford to enlarge the data). Another reasonable
solution is to decrease the complexity of the hypothesis class. On the other hand,
if we see that the validation error is kept around 1/2 then we have no evidence
that the approximation error of H is good. It may be the case that increasing
the training set size will not help us at all. Obtaining more data can still help
us, as at some point we can see whether the validation error starts to decrease
or whether the training error starts to increase. But, if more data is expensive,
it may be better first to try to reduce the complexity of the hypothesis class.
To summarize the discussion, the following steps should be applied:
1. If learning involves parameter tuning, plot the model-selection curve to make
sure that you tuned the parameters appropriately (see Section 11.2.3).
2. If the training error is excessively large consider enlarging the hypothesis class,
completely change it, or change the feature representation of the data.
3. If the training error is small, plot learning curves and try to deduce from them
whether the problem is estimation error or approximation error.
4. If the approximation error seems to be small enough, try to obtain more data.
If this is not possible, consider reducing the complexity of the hypothesis class.
5. If the approximation error seems to be large as well, try to change the hypothesis class or the feature representation of the data completely.

11.4

Summary
Model selection is the task of selecting an appropriate model for the learning
task based on the data itself. We have shown how this can be done using the
SRM learning paradigm or using the more practical approach of validation. If
our learning algorithm fails, a decomposition of the algorithmâ€™s error should be
performed using learning curves, so as to find the best remedy.

11.5

Exercises
1. Failure of k-fold cross validation Consider a case in that the label is
chosen at random according to P[y = 1] = P[y = 0] = 1/2. Consider a
learning algorithm that outputs the constant predictor h(x) = 1 if the parity
of the labels on the training set is 1 and otherwise the algorithm outputs the
constant predictor h(x) = 0. Prove that the difference between the leave-oneout estimate and the true error in such a case is always 1/2.
2. Let H1 , . . . , Hk be k hypothesis classes. Suppose you are given m i.i.d. training
examples and you would like to learn the class H = âˆªki=1 Hi . Consider two
alternative approaches:
â€¢ Learn H on the m examples using the ERM rule

11.5 Exercises

155

â€¢ Divide the m examples into a training set of size (1 âˆ’ Î±)m and a validation
set of size Î±m, for some Î± âˆˆ (0, 1). Then, apply the approach of model
selection using validation. That is, first train each class Hi on the (1 âˆ’
Î±)m training examples using the ERM rule with respect to Hi , and let
hÌ‚1 , . . . , hÌ‚k be the resulting hypotheses. Second, apply the ERM rule with
respect to the finite class {hÌ‚1 , . . . , hÌ‚k } on the Î±m validation examples.
Describe scenarios in which the first method is better than the second and
vice versa.

12 Convex Learning Problems

In this chapter we introduce convex learning problems. Convex learning comprises
an important family of learning problems, mainly because most of what we can
learn efficiently falls into it. We have already encountered linear regression with
the squared loss and logistic regression, which are convex problems, and indeed
they can be learned efficiently. We have also seen nonconvex problems, such as
halfspaces with the 0-1 loss, which is known to be computationally hard to learn
in the unrealizable case.
In general, a convex learning problem is a problem whose hypothesis class is a
convex set, and whose loss function is a convex function for each example. We begin the chapter with some required definitions of convexity. Besides convexity, we
will define Lipschitzness and smoothness, which are additional properties of the
loss function that facilitate successful learning. We next turn to defining convex
learning problems and demonstrate the necessity for further constraints such as
Boundedness and Lipschitzness or Smoothness. We define these more restricted
families of learning problems and claim that Convex-Smooth/Lipschitz-Bounded
problems are learnable. These claims will be proven in the next two chapters, in
which we will present two learning paradigms that successfully learn all problems
that are either convex-Lipschitz-bounded or convex-smooth-bounded.
Finally, in Section 12.3, we show how one can handle some nonconvex problems
by minimizing â€œsurrogateâ€ loss functions that are convex (instead of the original
nonconvex loss function). Surrogate convex loss functions give rise to efficient
solutions but might increase the risk of the learned predictor.

12.1

Convexity, Lipschitzness, and Smoothness

12.1.1

Convexity
definition 12.1 (Convex Set) A set C in a vector space is convex if for any
two vectors u, v in C, the line segment between u and v is contained in C. That
is, for any Î± âˆˆ [0, 1] we have that Î±u + (1 âˆ’ Î±)v âˆˆ C.
Examples of convex and nonconvex sets in R2 are given in the following. For
the nonconvex sets, we depict two points in the set such that the line between
the two points is not contained in the set.
c 2014 by Shai Shalev-Shwartz and Shai Ben-David
Understanding Machine Learning, 
Published 2014 by Cambridge University Press.
Personal use only. Not for distribution. Do not post.
Please link to http://www.cs.huji.ac.il/~shais/UnderstandingMachineLearning

12.1 Convexity, Lipschitzness, and Smoothness

non-convex

157

convex

Given Î± âˆˆ [0, 1], the combination, Î±u + (1 âˆ’ Î±)v of the points u, v is called a
convex combination.
definition 12.2 (Convex Function) Let C be a convex set. A function f :
C â†’ R is convex if for every u, v âˆˆ C and Î± âˆˆ [0, 1],
f (Î±u + (1 âˆ’ Î±)v) â‰¤ Î±f (u) + (1 âˆ’ Î±)f (v) .
In words, f is convex if for any u, v, the graph of f between u and v lies below
the line segment joining f (u) and f (v). An illustration of a convex function,
f : R â†’ R, is depicted in the following.

f (v)

Î±f (u) + (1 âˆ’ Î±)f (v)

f (u)

f (Î±u + (1 âˆ’ Î±)v)

u

v
Î±u + (1 âˆ’ Î±)v

The epigraph of a function f is the set
epigraph(f) = {(x, Î²) : f (x) â‰¤ Î²}.

(12.1)

It is easy to verify that a function f is convex if and only if its epigraph is a
convex set. An illustration of a nonconvex function f : R â†’ R, along with its
epigraph, is given in the following.

158

Convex Learning Problems

f (x)

x

An important property of convex functions is that every local minimum of the
function is also a global minimum. Formally, let B(u, r) = {v : kv âˆ’ uk â‰¤ r} be
a ball of radius r centered around u. We say that f (u) is a local minimum of f
at u if there exists some r > 0 such that for all v âˆˆ B(u, r) we have f (v) â‰¥ f (u).
It follows that for any v (not necessarily in B), there is a small enough Î± > 0
such that u + Î±(v âˆ’ u) âˆˆ B(u, r) and therefore

f (u) â‰¤ f (u + Î±(v âˆ’ u)) .

(12.2)

If f is convex, we also have that

f (u + Î±(v âˆ’ u)) = f (Î±v + (1 âˆ’ Î±)u) â‰¤ (1 âˆ’ Î±)f (u) + Î±f (v) .

(12.3)

Combining these two equations and rearranging terms, we conclude that f (u) â‰¤
f (v). Since this holds for every v, it follows that f (u) is also a global minimum
of f .
Another important property of convex functions is that for every w we can
construct a tangent to f at w that lies below f everywhere. If f is differentiable,
this tangent is the linear function l(u) = f (w) + hâˆ‡f (w), u âˆ’ wi, where âˆ‡f (w)
is the gradient of f at w, namely, the vector of partial derivatives of f , âˆ‡f (w) =

âˆ‚f (w)
âˆ‚f (w)
âˆ‚w1 , . . . , âˆ‚wd

. That is, for convex differentiable functions,

âˆ€u, f (u) â‰¥ f (w) + hâˆ‡f (w), u âˆ’ wi.

(12.4)

In Chapter 14 we will generalize this inequality to nondifferentiable functions.
An illustration of Equation (12.4) is given in the following.

159

,âˆ‡
f(

w

)i

12.1 Convexity, Lipschitzness, and Smoothness

f(

f (w)

w

)+

hu

âˆ’

w

f (u)

w

u

If f is a scalar differentiable function, there is an easy way to check if it is
convex.
lemma 12.3 Let f : R â†’ R be a scalar twice differential function, and let
f 0 , f 00 be its first and second derivatives, respectively. Then, the following are
equivalent:
1. f is convex
2. f 0 is monotonically nondecreasing
3. f 00 is nonnegative
Example 12.1
â€¢ The scalar function f (x) = x2 is convex. To see this, note that f 0 (x) = 2x
and f 00 (x) = 2 > 0.
â€¢ The scalar function f (x) = log(1 + exp(x)) is convex. To see this, observe that
exp(x)
1
f 0 (x) = 1+exp(x)
= exp(âˆ’x)+1
. This is a monotonically increasing function
since the exponent function is a monotonically increasing function.
The following claim shows that the composition of a convex scalar function
with a linear function yields a convex vector-valued function.
claim 12.4 Assume that f : Rd â†’ R can be written as f (w) = g(hw, xi + y),
for some x âˆˆ Rd , y âˆˆ R, and g : R â†’ R. Then, convexity of g implies the
convexity of f .
Proof

Let w1 , w2 âˆˆ Rd and Î± âˆˆ [0, 1]. We have
f (Î±w1 + (1 âˆ’ Î±)w2 ) = g(hÎ±w1 + (1 âˆ’ Î±)w2 , xi + y)
= g(Î±hw1 , xi + (1 âˆ’ Î±)hw2 , xi + y)
= g(Î±(hw1 , xi + y) + (1 âˆ’ Î±)(hw2 , xi + y))
â‰¤ Î±g(hw1 , xi + y) + (1 âˆ’ Î±)g(hw2 , xi + y),

where the last inequality follows from the convexity of g.
Example 12.2

160

Convex Learning Problems

â€¢ Given some x âˆˆ Rd and y âˆˆ R, let f : Rd â†’ R be defined as f (w) =
(hw, xi âˆ’ y)2 . Then, f is a composition of the function g(a) = a2 onto a
linear function, and hence f is a convex function.
â€¢ Given some x âˆˆ Rd and y âˆˆ {Â±1}, let f : Rd â†’ R be defined as f (w) =
log(1 + exp(âˆ’yhw, xi)). Then, f is a composition of the function g(a) =
log(1 + exp(a)) onto a linear function, and hence f is a convex function.
Finally, the following lemma shows that the maximum of convex functions is
convex and that a weighted sum of convex functions, with nonnegative weights,
is also convex.
claim 12.5 For i = 1, . . . , r, let fi : Rd â†’ R be a convex function. The
following functions from Rd to R are also convex.
â€¢ g(x) = maxiâˆˆ[r] fi (x)
Pr
â€¢ g(x) = i=1 wi fi (x), where for all i, wi â‰¥ 0.
Proof

The first claim follows by
g(Î±u + (1 âˆ’ Î±)v) = max fi (Î±u + (1 âˆ’ Î±)v)
i

â‰¤ max [Î±fi (u) + (1 âˆ’ Î±)fi (v)]
i

â‰¤ Î± max fi (u) + (1 âˆ’ Î±) max fi (v)
i

i

= Î±g(u) + (1 âˆ’ Î±)g(v).
For the second claim
g(Î±u + (1 âˆ’ Î±)v) =

X

wi fi (Î±u + (1 âˆ’ Î±)v)

i

â‰¤

X

wi [Î±fi (u) + (1 âˆ’ Î±)fi (v)]

i

=Î±

X

wi fi (u) + (1 âˆ’ Î±)

i

X

wi fi (v)

i

= Î±g(u) + (1 âˆ’ Î±)g(v).

Example 12.3 The function g(x) = |x| is convex. To see this, note that g(x) =
max{x, âˆ’x} and that both the function f1 (x) = x and f2 (x) = âˆ’x are convex.

12.1.2

Lipschitzness
The definition of Lipschitzness below is with respect to the Euclidean norm over
Rd . However, it is possible to define Lipschitzness with respect to any norm.
definition 12.6 (Lipschitzness) Let C âŠ‚ Rd . A function f : Rd â†’ Rk is
Ï-Lipschitz over C if for every w1 , w2 âˆˆ C we have that kf (w1 ) âˆ’ f (w2 )k â‰¤
Ï kw1 âˆ’ w2 k.

12.1 Convexity, Lipschitzness, and Smoothness

161

Intuitively, a Lipschitz function cannot change too fast. Note that if f : R â†’ R
is differentiable, then by the mean value theorem we have
f (w1 ) âˆ’ f (w2 ) = f 0 (u)(w1 âˆ’ w2 ) ,
where u is some point between w1 and w2 . It follows that if the derivative of f
is everywhere bounded (in absolute value) by Ï, then the function is Ï-Lipschitz.
Example 12.4
â€¢ The function f (x) = |x| is 1-Lipschitz over R. This follows from the triangle
inequality: For every x1 , x2 ,
|x1 | âˆ’ |x2 | = |x1 âˆ’ x2 + x2 | âˆ’ |x2 | â‰¤ |x1 âˆ’ x2 | + |x2 | âˆ’ |x2 | = |x1 âˆ’ x2 |.
Since this holds for both x1 , x2 and x2 , x1 , we obtain that ||x1 | âˆ’ |x2 || â‰¤
|x1 âˆ’ x2 |.
â€¢ The function f (x) = log(1 + exp(x)) is 1-Lipschitz over R. To see this, observe
that
 



 exp(x)  
1
0


 â‰¤ 1.

=
|f (x)| = 

1 + exp(x)
exp(âˆ’x) + 1 
â€¢ The function f (x) = x2 is not Ï-Lipschitz over R for any Ï. To see this, take
x1 = 0 and x2 = 1 + Ï, then
f (x2 ) âˆ’ f (x1 ) = (1 + Ï)2 > Ï(1 + Ï) = Ï|x2 âˆ’ x1 |.
However, this function is Ï-Lipschitz over the set C = {x : |x| â‰¤ Ï/2}.
Indeed, for any x1 , x2 âˆˆ C we have
|x21 âˆ’ x22 | = |x1 + x2 | |x1 âˆ’ x2 | â‰¤ 2(Ï/2) |x1 âˆ’ x2 | = Ï|x1 âˆ’ x2 |.
â€¢ The linear function f : Rd â†’ R defined by f (w) = hv, wi + b where v âˆˆ Rd
is kvk-Lipschitz. Indeed, using Cauchy-Schwartz inequality,
|f (w1 ) âˆ’ f (w2 )| = |hv, w1 âˆ’ w2 i| â‰¤ kvk kw1 âˆ’ w2 k.
The following claim shows that composition of Lipschitz functions preserves
Lipschitzness.
claim 12.7 Let f (x) = g1 (g2 (x)), where g1 is Ï1 -Lipschitz and g2 is Ï2 Lipschitz. Then, f is (Ï1 Ï2 )-Lipschitz. In particular, if g2 is the linear function,
g2 (x) = hv, xi + b, for some v âˆˆ Rd , b âˆˆ R, then f is (Ï1 kvk)-Lipschitz.
Proof
|f (w1 ) âˆ’ f (w2 )| = |g1 (g2 (w1 )) âˆ’ g1 (g2 (w2 ))|
â‰¤ Ï1 kg2 (w1 ) âˆ’ g2 (w2 )k
â‰¤ Ï1 Ï2 kw1 âˆ’ w2 k.

162

Convex Learning Problems

12.1.3

Smoothness
The definition of a smooth function relies on the notion of gradient. Recall that
the gradient of a differentiable function f : Rd â†’ R at
 w, denoted âˆ‡f (w),
 is the
vector of partial derivatives of f , namely, âˆ‡f (w) =

âˆ‚f (w)
âˆ‚f (w)
âˆ‚w1 , . . . , âˆ‚wd

.

definition 12.8 (Smoothness) A differentiable function f : Rd â†’ R is Î²smooth if its gradient is Î²-Lipschitz; namely, for all v, w we have kâˆ‡f (v) âˆ’
âˆ‡f (w)k â‰¤ Î²kv âˆ’ wk.
It is possible to show that smoothness implies that for all v, w we have
f (v) â‰¤ f (w) + hâˆ‡f (w), v âˆ’ wi +

Î²
kv âˆ’ wk2 .
2

(12.5)

Recall that convexity of f implies that f (v) â‰¥ f (w)+hâˆ‡f (w), vâˆ’wi. Therefore,
when a function is both convex and smooth, we have both upper and lower
bounds on the difference between the function and its first order approximation.
Setting v = w âˆ’ Î²1 âˆ‡f (w) in the right-hand side of Equation (12.5) and rearranging terms, we obtain
1
kâˆ‡f (w)k2 â‰¤ f (w) âˆ’ f (v).
2Î²
If we further assume that f (v) â‰¥ 0 for all v we conclude that smoothness implies
the following:
kâˆ‡f (w)k2 â‰¤ 2Î²f (w) .

(12.6)

A function that satisfies this property is also called a self-bounded function.
Example 12.5
â€¢ The function f (x) = x2 is 2-smooth. This follows directly from the fact that
f 0 (x) = 2x. Note that for this particular function Equation (12.5) and
Equation (12.6) hold with equality.
â€¢ The function f (x) = log(1 + exp(x)) is (1/4)-smooth. Indeed, since f 0 (x) =
1
1+exp(âˆ’x) we have that
|f 00 (x)| =

exp(âˆ’x)
1
=
â‰¤ 1/4.
(1 + exp(âˆ’x))2
(1 + exp(âˆ’x))(1 + exp(x))

Hence, f 0 is (1/4)-Lipschitz. Since this function is nonnegative, Equation (12.6) holds as well.
The following claim shows that a composition of a smooth scalar function over
a linear function preserves smoothness.
claim 12.9 Let f (w) = g(hw, xi + b), where g : R â†’ R is a Î²-smooth function,
x âˆˆ Rd , and b âˆˆ R. Then, f is (Î² kxk2 )-smooth.

12.2 Convex Learning Problems

163

Proof By the chain rule we have that âˆ‡f (w) = g 0 (hw, xi + b)x, where g 0 is the
derivative of g. Using the smoothness of g and the Cauchy-Schwartz inequality
we therefore obtain
f (v) = g(hv, xi + b)
Î²
(hv âˆ’ w, xi)2
2
Î²
2
â‰¤ g(hw, xi + b) + g 0 (hw, xi + b)hv âˆ’ w, xi + (kv âˆ’ wk kxk)
2
Î²kxk2
kv âˆ’ wk2 .
= f (w) + hâˆ‡f (w), v âˆ’ wi +
2
â‰¤ g(hw, xi + b) + g 0 (hw, xi + b)hv âˆ’ w, xi +

Example 12.6
â€¢ For any x âˆˆ Rd and y âˆˆ R, let f (w) = (hw, xi âˆ’ y)2 . Then, f is (2kxk2 )smooth.
â€¢ For any x âˆˆ Rd and y âˆˆ {Â±1}, let f (w) = log(1 + exp(âˆ’yhw, xi)). Then, f is
(kxk2 /4)-smooth.

12.2

Convex Learning Problems
Recall that in our general definition of learning (Definition 3.4 in Chapter 3), we
have a hypothesis class H, a set of examples Z, and a loss function ` : H Ã— Z â†’
R+ . So far in the book we have mainly thought of Z as being the product of an
instance space and a target space, Z = X Ã—Y, and H being a set of functions from
X to Y. However, H can be an arbitrary set. Indeed, throughout this chapter,
we consider hypothesis classes H that are subsets of the Euclidean space Rd .
That is, every hypothesis is some real-valued vector. We shall, therefore, denote
a hypothesis in H by w. Now we can finally define convex learning problems:
definition 12.10 (Convex Learning Problem) A learning problem, (H, Z, `),
is called convex if the hypothesis class H is a convex set and for all z âˆˆ Z, the
loss function, `(Â·, z), is a convex function (where, for any z, `(Â·, z) denotes the
function f : H â†’ R defined by f (w) = `(w, z)).
Example 12.7 (Linear Regression with the Squared Loss) Recall that linear
regression is a tool for modeling the relationship between some â€œexplanatoryâ€
variables and some real valued outcome (see Chapter 9). The domain set X
is a subset of Rd , for some d, and the label set Y is the set of real numbers.
We would like to learn a linear function h : Rd â†’ R that best approximates
the relationship between our variables. In Chapter 9 we defined the hypothesis
class as the set of homogenous linear functions, H = {x 7â†’ hw, xi : w âˆˆ Rd },
and used the squared loss function, `(h, (x, y)) = (h(x) âˆ’ y)2 . However, we can
equivalently model the learning problem as a convex learning problem as follows.

164

Convex Learning Problems

Each linear function is parameterized by a vector w âˆˆ Rd . Hence, we can define
H to be the set of all such parameters, namely, H = Rd . The set of examples is
Z = X Ã—Y = Rd Ã—R = Rd+1 , and the loss function is `(w, (x, y)) = (hw, xiâˆ’y)2 .
Clearly, the set H is a convex set. The loss function is also convex with respect
to its first argument (see Example 12.2).
lemma 12.11 If ` is a convex loss function and the class H is convex, then the
ERMH problem, of minimizing the empirical loss over H, is a convex optimization problem (that is, a problem of minimizing a convex function over a convex
set).
Proof

Recall that the ERMH problem is defined by
ERMH (S) = argmin LS (w).
wâˆˆH

Pm
1
Since, for a sample S = z1 , . . . , zm , for every w, LS (w) = m
i=1 `(w, zi ),
Claim 12.5 implies that LS (w) is a convex function. Therefore, the ERM rule
is a problem of minimizing a convex function subject to the constraint that the
solution should be in a convex set.
Under mild conditions, such problems can be solved efficiently using generic
optimization algorithms. In particular, in Chapter 14 we will present a very
simple algorithm for minimizing convex functions.

12.2.1

Learnability of Convex Learning Problems
We have argued that for many cases, implementing the ERM rule for convex
learning problems can be done efficiently. But is convexity a sufficient condition
for the learnability of a problem?
To make the quesion more specific: In VC theory, we saw that halfspaces in
d-dimension are learnable (perhaps inefficiently). We also argued in Chapter 9
using the â€œdiscretization trickâ€ that if the problem is of d parameters, it is
learnable with a sample complexity being a function of d. That is, for a constant
d, the problem should be learnable. So, maybe all convex learning problems over
Rd , are learnable?
Example 12.8 later shows that the answer is negative, even when d is low. Not
all convex learning problems over Rd are learnable. There is no contradiction
to VC theory since VC theory only deals with binary classification while here
we consider a wide family of problems. There is also no contradiction to the
â€œdiscretization trickâ€ as there we assumed that the loss function is bounded and
also assumed that a representation of each parameter using a finite number of
bits suffices. As we will show later, under some additional restricting conditions
that hold in many practical scenarios, convex problems are learnable.
Example 12.8 (Nonlearnability of Linear Regression Even If d = 1) Let H = R,
and the loss be the squared loss: `(w, (x, y)) = (wx âˆ’ y)2 (weâ€™re referring to the

12.2 Convex Learning Problems

165

homogenous case). Let A be any deterministic algorithm.1 Assume, by way of
contradiction, that A is a successful PAC learner for this problem. That is, there
exists a function m(Â·, Â·), such that for every distribution D and for every , Î´ if
A receives a training set of size m â‰¥ m(, Î´), it should output, with probability
of at least 1 âˆ’ Î´, a hypothesis wÌ‚ = A(S), such that LD (wÌ‚) âˆ’ minw LD (w) â‰¤ .
Choose  = 1/100, Î´ = 1/2, let m â‰¥ m(, Î´), and set Âµ = log(100/99)
. We will
2m
define two distributions, and will show that A is likely to fail on at least one
of them. The first distribution, D1 , is supported on two examples, z1 = (1, 0)
and z2 = (Âµ, âˆ’1), where the probability mass of the first example is Âµ while the
probability mass of the second example is 1 âˆ’ Âµ. The second distribution, D2 , is
supported entirely on z2 .
Observe that for both distributions, the probability that all examples of the
training set will be of the second type is at least 99%. This is trivially true for
D2 , whereas for D1 , the probability of this event is
(1 âˆ’ Âµ)m â‰¥ eâˆ’2Âµm = 0.99.
Since we assume that A is a deterministic algorithm, upon receiving a training
set of m examples, each of which is (Âµ, âˆ’1), the algorithm will output some wÌ‚.
Now, if wÌ‚ < âˆ’1/(2Âµ), we will set the distribution to be D1 . Hence,
LD1 (wÌ‚) â‰¥ Âµ(wÌ‚)2 â‰¥ 1/(4Âµ).
However,
min LD1 (w) â‰¤ LD1 (0) = (1 âˆ’ Âµ).
w

It follows that
LD1 (wÌ‚) âˆ’ min LD1 (w) â‰¥
w

1
âˆ’ (1 âˆ’ Âµ) > .
4Âµ

Therefore, such algorithm A fails on D1 . On the other hand, if wÌ‚ â‰¥ âˆ’1/(2Âµ)
then weâ€™ll set the distribution to be D2 . Then we have that LD2 (wÌ‚) â‰¥ 1/4 while
minw LD2 (w) = 0, so A fails on D2 . In summary, we have shown that for every
A there exists a distribution on which A fails, which implies that the problem is
not PAC learnable.
A possible solution to this problem is to add another constraint on the hypothesis class. In addition to the convexity requirement, we require that H will be
bounded ; namely, we assume that for some predefined scalar B, every hypothesis
w âˆˆ H satisfies kwk â‰¤ B.
Boundedness and convexity alone are still not sufficient for ensuring that the
problem is learnable, as the following example demonstrates.
Example 12.9 As in Example 12.8, consider a regression problem with the
squared loss. However, this time let H = {w : |w| â‰¤ 1} âŠ‚ R be a bounded
1

Namely, given S the output of A is determined. This requirement is for the sake of
simplicity. A slightly more involved argument will show that nondeterministic algorithms
will also fail to learn the problem.

166

Convex Learning Problems

hypothesis class. It is easy to verify that H is convex. The argument will be
the same as in Example 12.8, except that now the two distributions, D1 , D2 will
be supported on z1 = (1/Âµ, 0) and z2 = (1, âˆ’1). If the algorithm A returns
wÌ‚ < âˆ’1/2 upon receiving m examples of the second type, then we will set the
distribution to be D1 and have that
LD1 (wÌ‚) âˆ’ min LD1 (w) â‰¥ Âµ(wÌ‚/Âµ)2 âˆ’ LD1 (0) â‰¥ 1/(4Âµ) âˆ’ (1 âˆ’ Âµ) > .
w

Similarly, if wÌ‚ â‰¥ âˆ’1/2 we will set the distribution to be D2 and have that
LD2 (wÌ‚) âˆ’ min LD2 (w) â‰¥ (âˆ’1/2 + 1)2 âˆ’ 0 > .
w

This example shows that we need additional assumptions on the learning
problem, and this time the solution is in Lipschitzness or smoothness of the
loss function. This motivates a definition of two families of learning problems,
convex-Lipschitz-bounded and convex-smooth-bounded, which are defined later.

12.2.2

Convex-Lipschitz/Smooth-Bounded Learning Problems
definition 12.12 (Convex-Lipschitz-Bounded Learning Problem) A learning
problem, (H, Z, `), is called Convex-Lipschitz-Bounded, with parameters Ï, B if
the following holds:
â€¢ The hypothesis class H is a convex set and for all w âˆˆ H we have kwk â‰¤ B.
â€¢ For all z âˆˆ Z, the loss function, `(Â·, z), is a convex and Ï-Lipschitz function.
Example 12.10 Let X = {x âˆˆ Rd : kxk â‰¤ Ï} and Y = R. Let H = {w âˆˆ Rd :
kwk â‰¤ B} and let the loss function be `(w, (x, y)) = |hw, xi âˆ’ y|. This corresponds to a regression problem with the absolute-value loss, where we assume
that the instances are in a ball of radius Ï and we restrict the hypotheses to be
homogenous linear functions defined by a vector w whose norm is bounded by
B. Then, the resulting problem is Convex-Lipschitz-Bounded with parameters
Ï, B.
definition 12.13 (Convex-Smooth-Bounded Learning Problem) A learning
problem, (H, Z, `), is called Convex-Smooth-Bounded, with parameters Î², B if
the following holds:
â€¢ The hypothesis class H is a convex set and for all w âˆˆ H we have kwk â‰¤ B.
â€¢ For all z âˆˆ Z, the loss function, `(Â·, z), is a convex, nonnegative, and Î²-smooth
function.
Note that we also required that the loss function is nonnegative. This is needed
to ensure that the loss function is self-bounded, as described in the previous
section.

12.3 Surrogate Loss Functions

167

Example 12.11 Let X = {x âˆˆ Rd : kxk â‰¤ Î²/2} and Y = R. Let H = {w âˆˆ
Rd : kwk â‰¤ B} and let the loss function be `(w, (x, y)) = (hw, xi âˆ’ y)2 . This
corresponds to a regression problem with the squared loss, where we assume that
the instances are in a ball of radius Î²/2 and we restrict the hypotheses to be
homogenous linear functions defined by a vector w whose norm is bounded by B.
Then, the resulting problem is Convex-Smooth-Bounded with parameters Î², B.
We claim that these two families of learning problems are learnable. That is,
the properties of convexity, boundedness, and Lipschitzness or smoothness of the
loss function are sufficient for learnability. We will prove this claim in the next
chapters by introducing algorithms that learn these problems successfully.

12.3

Surrogate Loss Functions
As mentioned, and as we will see in the next chapters, convex problems can
be learned effficiently. However, in many cases, the natural loss function is not
convex and, in particular, implementing the ERM rule is hard.
As an example, consider the problem of learning the hypothesis class of halfspaces with respect to the 0 âˆ’ 1 loss. That is,
`0âˆ’1 (w, (x, y)) = 1[y6=sign(hw,xi)] = 1[yhw,xiâ‰¤0] .
This loss function is not convex with respect to w and indeed, when trying to
minimize the empirical risk with respect to this loss function we might encounter
local minima (see Exercise 1). Furthermore, as discussed in Chapter 8, solving
the ERM problem with respect to the 0 âˆ’ 1 loss in the unrealizable case is known
to be NP-hard.
To circumvent the hardness result, one popular approach is to upper bound
the nonconvex loss function by a convex surrogate loss function. As its name
indicates, the requirements from a convex surrogate loss are as follows:
1. It should be convex.
2. It should upper bound the original loss.
For example, in the context of learning halfspaces, we can define the so-called
hinge loss as a convex surrogate for the 0 âˆ’ 1 loss, as follows:
def

`hinge (w, (x, y)) = max{0, 1 âˆ’ yhw, xi}.
Clearly, for all w and all (x, y), `0âˆ’1 (w, (x, y)) â‰¤ `hinge (w, (x, y)). In addition,
the convexity of the hinge loss follows directly from Claim 12.5. Hence, the hinge
loss satisfies the requirements of a convex surrogate loss function for the zero-one
loss. An illustration of the functions `0âˆ’1 and `hinge is given in the following.

168

Convex Learning Problems

`hinge

`0âˆ’1

1

yhw, xi

1

Once we have defined the surrogate convex loss, we can learn the problem with
respect to it. The generalization requirement from a hinge loss learner will have
the form
Lhinge
(A(S)) â‰¤ min Lhinge
(w) + ,
D
D
wâˆˆH

Lhinge
(w)
D

hinge

where
= E(x,y)âˆ¼D [`
(w, (x, y))]. Using the surrogate property, we
can lower bound the left-hand side by L0âˆ’1
D (A(S)), which yields
hinge
L0âˆ’1
(w) + .
D (A(S)) â‰¤ min LD
wâˆˆH

We can further rewrite the upper bound as follows:


hinge
0âˆ’1
0âˆ’1
0âˆ’1
LD (A(S)) â‰¤ min LD (w) + min LD (w) âˆ’ min LD (w) + .
wâˆˆH

wâˆˆH

wâˆˆH

That is, the 0âˆ’1 error of the learned predictor is upper bounded by three terms:
â€¢ Approximation error : This is the term minwâˆˆH L0âˆ’1
D (w), which measures how
well the hypothesis class performs on the distribution. We already elaborated on this error term in Chapter 5.
â€¢ Estimation error : This is the error that results from the fact that we only
receive a training set and do not observe the distribution D. We already
elaborated on this error term in Chapter
5.


0âˆ’1
â€¢ Optimization error : This is the term minwâˆˆH Lhinge
(w)
âˆ’
min
L
(w)
wâˆˆH D
D
that measures the difference between the approximation error with respect
to the surrogate loss and the approximation error with respect to the original loss. The optimization error is a result of our inability to minimize the
training loss with respect to the original loss. The size of this error depends
on the specific distribution of the data and on the specific surrogate loss
we are using.

12.4

Summary
We introduced two families of learning problems: convex-Lipschitz-bounded and
convex-smooth-bounded. In the next two chapters we will describe two generic

12.5 Bibliographic Remarks

169

learning algorithms for these families. We also introduced the notion of convex
surrogate loss function, which enables us also to utilize the convex machinery for
nonconvex problems.

12.5

Bibliographic Remarks
There are several excellent books on convex analysis and optimization (Boyd &
Vandenberghe 2004, Borwein & Lewis 2006, Bertsekas 1999, Hiriart-Urruty &
LemareÌchal 1996). Regarding learning problems, the family of convex-Lipschitzbounded problems was first studied by Zinkevich (2003) in the context of online
learning and by Shalev-Shwartz, Shamir, Sridharan & Srebro (2009) in the context of PAC learning.

12.6

Exercises
1. Construct an example showing that the 0âˆ’1 loss function may suffer from
local minima; namely, construct a training sample S âˆˆ (X Ã— {Â±1})m (say, for
X = R2 ), for which there exist a vector w and some  > 0 such that
1. For any w0 such that kw âˆ’ w0 k â‰¤  we have LS (w) â‰¤ LS (w0 ) (where the
loss here is the 0âˆ’1 loss). This means that w is a local minimum of LS .
2. There exists some wâˆ— such that LS (wâˆ— ) < LS (w). This means that w is
not a global minimum of LS .
2. Consider the learning problem of logistic regression: Let H = X = {x âˆˆ
Rd : kxk â‰¤ B}, for some scalar B > 0, let Y = {Â±1}, and let the loss
function ` be defined as `(w, (x, y)) = log(1 + exp(âˆ’yhw, xi)). Show that
the resulting learning problem is both convex-Lipschitz-bounded and convexsmooth-bounded. Specify the parameters of Lipschitzness and smoothness.
3. Consider the problem of learning halfspaces with the hinge loss. We limit our
domain to the Euclidean ball with radius R. That is, X = {x : kxk2 â‰¤ R}.
The label set is Y = {Â±1} and the loss function ` is defined by `(w, (x, y)) =
max{0, 1 âˆ’ yhw, xi}. We already know that the loss function is convex. Show
that it is R-Lipschitz.
4. (*) Convex-Lipschitz-Boundedness Is Not Sufficient for Computational Efficiency: In the next chapter we show that from the statistical
perspective, all convex-Lipschitz-bounded problems are learnable (in the agnostic PAC model). However, our main motivation to learn such problems
resulted from the computational perspective â€“ convex optimization is often
efficiently solvable. Yet the goal of this exercise is to show that convexity
alone is not sufficient for efficiency. We show that even for the case d = 1,
there is a convex-Lipschitz-bounded problem which cannot be learned by any
computable learner.
Let the hypothesis class be H = [0, 1] and let the example domain, Z, be

170

Convex Learning Problems

the set of all Turing machines. Define the loss function as follows. For every
Turing machine T âˆˆ Z, let `(0, T ) = 1 if T halts on the input 0 and `(0, T ) = 0
if T doesnâ€™t halt on the input 0. Similarly, let `(1, T ) = 0 if T halts on the
input 0 and `(1, T ) = 1 if T doesnâ€™t halt on the input 0. Finally, for h âˆˆ (0, 1),
let `(h, T ) = h`(0, T ) + (1 âˆ’ h)`(1, T ).
1. Show that the resulting learning problem is convex-Lipschitz-bounded.
2. Show that no computable algorithm can learn the problem.

13 Regularization and Stability

In the previous chapter we introduced the families of convex-Lipschitz-bounded
and convex-smooth-bounded learning problems. In this section we show that all
learning problems in these two families are learnable. For some learning problems
of this type it is possible to show that uniform convergence holds; hence they
are learnable using the ERM rule. However, this is not true for all learning
problems of this type. Yet, we will introduce another learning rule and will show
that it learns all convex-Lipschitz-bounded and convex-smooth-bounded learning
problems.
The new learning paradigm we introduce in this chapter is called Regularized
Loss Minimization, or RLM for short. In RLM we minimize the sum of the empirical risk and a regularization function. Intuitively, the regularization function
measures the complexity of hypotheses. Indeed, one interpretation of the regularization function is the structural risk minimization paradigm we discussed
in Chapter 7. Another view of regularization is as a stabilizer of the learning
algorithm. An algorithm is considered stable if a slight change of its input does
not change its output much. We will formally define the notion of stability (what
we mean by â€œslight change of inputâ€ and by â€œdoes not change much the outputâ€) and prove its close relation to learnability. Finally, we will show that using
the squared `2 norm as a regularization function stabilizes all convex-Lipschitz or
convex-smooth learning problems. Hence, RLM can be used as a general learning
rule for these families of learning problems.

13.1

Regularized Loss Minimization
Regularized Loss Minimization (RLM) is a learning rule in which we jointly minimize the empirical risk and a regularization function. Formally, a regularization
function is a mapping R : Rd â†’ R, and the regularized loss minimization rule
outputs a hypothesis in
argmin (LS (w) + R(w)) .

(13.1)

w

Regularized loss minimization shares similarities with minimum description length
algorithms and structural risk minimization (see Chapter 7). Intuitively, the
â€œcomplexityâ€ of hypotheses is measured by the value of the regularization funcc 2014 by Shai Shalev-Shwartz and Shai Ben-David
Understanding Machine Learning, 
Published 2014 by Cambridge University Press.
Personal use only. Not for distribution. Do not post.
Please link to http://www.cs.huji.ac.il/~shais/UnderstandingMachineLearning

172

Regularization and Stability

tion, and the algorithm balances between low empirical risk and â€œsimpler,â€ or
â€œless complex,â€ hypotheses.
There are many possible regularization functions one can use, reflecting some
prior belief about the problem (similarly to the description language in Minimum
Description Length). Throughout this section we will focus on one of the most
simple regularization functions:
R(w) = Î»kwk2 , where Î» > 0 is a scalar and the
qP
d
2
norm is the `2 norm, kwk =
i=1 wi . This yields the learning rule:

A(S) = argmin LS (w) + Î»kwk2 .
(13.2)
w

This type of regularization function is often called Tikhonov regularization.
As mentioned before, one interpretation of Equation (13.2) is using structural
risk minimization, where the norm of w is a measure of its â€œcomplexity.â€ Recall
that in the previous chapter we introduced the notion of bounded hypothesis
classes. Therefore, we can define a sequence of hypothesis classes, H1 âŠ‚ H2 âŠ‚
H3 . . ., where Hi = {w : kwk2 â‰¤ i}. If the sample complexity of each Hi depends
on i then the RLM rule is similar to the SRM rule for this sequence of nested
classes.
A different interpretation of regularization is as a stabilizer. In the next section
we define the notion of stability and prove that stable learning rules do not
overfit. But first, let us demonstrate the RLM rule for linear regression with the
squared loss.

13.1.1

Ridge Regression
Applying the RLM rule with Tikhonov regularization to linear regression with
the squared loss, we obtain the following learning rule:
!
m
1 X1
2
2
argmin Î»kwk2 +
(hw, xi i âˆ’ yi ) .
(13.3)
m i=1 2
wâˆˆRd
Performing linear regression using Equation (13.3) is called ridge regression.
To solve Equation (13.3) we compare the gradient of the objective to zero and
obtain the set of linear equations
(2Î»mI + A)w = b,
where I is the identity matrix and A, b are as defined in Equation (9.6), namely,
!
m
m
X
X
>
A=
xi xi
and b =
yi xi .
(13.4)
i=1

i=1

Since A is a positive semidefinite matrix, the matrix 2Î»mI + A has all its eigenvalues bounded below by 2Î»m. Hence, this matrix is invertible and the solution
to ridge regression becomes
w = (2Î»mI + A)âˆ’1 b.

(13.5)

13.2 Stable Rules Do Not Overfit

173

In the next section we formally show how regularization stabilizes the algorithm and prevents overfitting. In particular, the analysis presented in the next
sections (particularly, Corollary 13.11) will yield:
theorem 13.1 Let D be a distribution over X Ã— [âˆ’1, 1], where X = {x âˆˆ
Rd : kxk â‰¤ 1}. Let H = {w âˆˆ Rd : kwk â‰¤ B}. For any  âˆˆ (0, 1), let m â‰¥
150 B 2 /2 . Then, applying the ridge regression algorithm with parameter Î» =
/(3B 2 ) satisfies
E

Sâˆ¼D m

[LD (A(S))] â‰¤ min LD (w) + .
wâˆˆH

Remark 13.1 The preceding theorem tells us how many examples are needed
to guarantee that the expected value of the risk of the learned predictor will be
bounded by the approximation error of the class plus . In the usual definition
of agnostic PAC learning we require that the risk of the learned predictor will
be bounded with probability of at least 1 âˆ’ Î´. In Exercise 1 we show how an
algorithm with a bounded expected risk can be used to construct an agnostic
PAC learner.

13.2

Stable Rules Do Not Overfit
Intuitively, a learning algorithm is stable if a small change of the input to the
algorithm does not change the output of the algorithm much. Of course, there
are many ways to define what we mean by â€œa small change of the inputâ€ and
what we mean by â€œdoes not change the output muchâ€. In this section we define
a specific notion of stability and prove that under this definition, stable rules do
not overfit.
Let A be a learning algorithm, let S = (z1 , . . . , zm ) be a training set of m
examples, and let A(S) denote the output of A. The algorithm A suffers from
overfitting if the difference between the true risk of its output, LD (A(S)), and the
empirical risk of its output, LS (A(S)), is large. As mentioned in Remark 13.1,
throughout this chapter we focus on the expectation (with respect to the choice
of S) of this quantity, namely, ES [LD (A(S)) âˆ’ LS (A(S))].
We next define the notion of stability. Given the training set S and an additional example z 0 , let S (i) be the training set obtained by replacing the iâ€™th
example of S with z 0 ; namely, S (i) = (z1 , . . . , ziâˆ’1 , z 0 , zi+1 , . . . , zm ). In our definition of stability, â€œa small change of the inputâ€ means that we feed A with S (i)
instead of with S. That is, we only replace one training example. We measure
the effect of this small change of the input on the output of A, by comparing
the loss of the hypothesis A(S) on zi to the loss of the hypothesis A(S (i) ) on zi .
Intuitively, a good learning algorithm will have `(A(S (i) ), zi ) âˆ’ `(A(S), zi ) â‰¥ 0,
since in the first term the learning algorithm does not observe the example zi
while in the second term zi is indeed observed. If the preceding difference is very
large we suspect that the learning algorithm might overfit. This is because the

174

Regularization and Stability

learning algorithm drastically changes its prediction on zi if it observes it in the
training set. This is formalized in the following theorem.
theorem 13.2 Let D be a distribution. Let S = (z1 , . . . , zm ) be an i.i.d. sequence of examples and let z 0 be another i.i.d. example. Let U (m) be the uniform
distribution over [m]. Then, for any learning algorithm,
E [LD (A(S)) âˆ’ LS (A(S))] =

Sâˆ¼D m

[`(A(S (i) , zi )) âˆ’ `(A(S), zi )].

E

(S,z 0 )âˆ¼D m+1 ,iâˆ¼U (m)

(13.6)
Proof

0

Since S and z are both drawn i.i.d. from D, we have that for every i,
E[LD (A(S))] = E 0 [`(A(S), z 0 )] = E 0 [`(A(S (i) ), zi )].
S

S,z

S,z

On the other hand, we can write
E[LS (A(S))] = E [`(A(S), zi )].
S

S,i

Combining the two equations we conclude our proof.
When the right-hand side of Equation (13.6) is small, we say that A is a stable
algorithm â€“ changing a single example in the training set does not lead to a
significant change. Formally,
definition 13.3 (On-Average-Replace-One-Stable) Let  : N â†’ R be a monotonically decreasing function. We say that a learning algorithm A is on-averagereplace-one-stable with rate (m) if for every distribution D
E

[`(A(S (i) , zi )) âˆ’ `(A(S), zi )] â‰¤ (m).

(S,z 0 )âˆ¼D m+1 ,iâˆ¼U (m)

Theorem 13.2 tells us that a learning algorithm does not overfit if and only
if it is on-average-replace-one-stable. Of course, a learning algorithm that does
not overfit is not necessarily a good learning algorithm â€“ take, for example, an
algorithm A that always outputs the same hypothesis. A useful algorithm should
find a hypothesis that on one hand fits the training set (i.e., has a low empirical
risk) and on the other hand does not overfit. Or, in light of Theorem 13.2, the
algorithm should both fit the training set and at the same time be stable. As we
shall see, the parameter Î» of the RLM rule balances between fitting the training
set and being stable.

13.3

Tikhonov Regularization as a Stabilizer
In the previous section we saw that stable rules do not overfit. In this section we
show that applying the RLM rule with Tikhonov regularization, Î»kwk2 , leads to
a stable algorithm. We will assume that the loss function is convex and that it
is either Lipschitz or smooth.
The main property of the Tikhonov regularization that we rely on is that it
makes the objective of RLM strongly convex, as defined in the following.

13.3 Tikhonov Regularization as a Stabilizer

175

definition 13.4 (Strongly Convex Functions) A function f is Î»-strongly convex if for all w, u and Î± âˆˆ (0, 1) we have
Î»
Î±(1 âˆ’ Î±)kw âˆ’ uk2 .
2
Clearly, every convex function is 0-strongly convex. An illustration of strong
convexity is given in the following figure.
f (Î±w + (1 âˆ’ Î±)u) â‰¤ Î±f (w) + (1 âˆ’ Î±)f (u) âˆ’

f (u)

â‰¥

f (w)
w

Î»
2 Î±(1

âˆ’ Î±)ku âˆ’ wk2

u

Î±w + (1 âˆ’ Î±)u

The following lemma implies that the objective of RLM is (2Î»)-strongly convex. In addition, it underscores an important property of strong convexity.
lemma 13.5
1. The function f (w) = Î»kwk2 is 2Î»-strongly convex.
2. If f is Î»-strongly convex and g is convex, then f + g is Î»-strongly convex.
3. If f is Î»-strongly convex and u is a minimizer of f , then, for any w,
Î»
kw âˆ’ uk2 .
2
Proof The first two points follow directly from the definition. To prove the last
point, we divide the definition of strong convexity by Î± and rearrange terms to
get that
f (w) âˆ’ f (u) â‰¥

f (u + Î±(w âˆ’ u)) âˆ’ f (u)
Î»
â‰¤ f (w) âˆ’ f (u) âˆ’ (1 âˆ’ Î±)kw âˆ’ uk2 .
Î±
2
Taking the limit Î± â†’ 0 we obtain that the right-hand side converges to f (w) âˆ’
f (u) âˆ’ Î»2 kw âˆ’ uk2 . On the other hand, the left-hand side becomes the derivative
of the function g(Î±) = f (u + Î±(w âˆ’ u)) at Î± = 0. Since u is a minimizer of f ,
it follows that Î± = 0 is a minimizer of g, and therefore the left-hand side of the
preceding goes to zero in the limit Î± â†’ 0, which concludes our proof.
We now turn to prove that RLM is stable. Let S = (z1 , . . . , zm ) be a training
set, let z 0 be an additional example, and let S (i) = (z1 , . . . , ziâˆ’1 , z 0 , zi+1 , . . . , zm ).
Let A be the RLM rule, namely,

A(S) = argmin LS (w) + Î»kwk2 .
w

176

Regularization and Stability

Denote fS (w) = LS (w) + Î»kwk2 , and based on Lemma 13.5 we know that fS is
(2Î»)-strongly convex. Relying on part 3 of the lemma, it follows that for any v,
fS (v) âˆ’ fS (A(S)) â‰¥ Î»kv âˆ’ A(S)k2 .

(13.7)

On the other hand, for any v and u, and for all i, we have
fS (v) âˆ’ fS (u) = LS (v) + Î»kvk2 âˆ’ (LS (u) + Î»kuk2 )
2

(13.8)
2

= LS (i) (v) + Î»kvk âˆ’ (LS (i) (u) + Î»kuk )
+

`(v, zi ) âˆ’ `(u, zi ) `(u, z 0 ) âˆ’ `(v, z 0 )
+
.
m
m

In particular, choosing v = A(S (i) ), u = A(S), and using the fact that v minimizes LS (i) (w) + Î»kwk2 , we obtain that
`(A(S (i) ), zi ) âˆ’ `(A(S), zi ) `(A(S), z 0 ) âˆ’ `(A(S (i) ), z 0 )
+
.
m
m
(13.9)
Combining this with Equation (13.7) we obtain that
fS (A(S (i) ))âˆ’fS (A(S)) â‰¤

`(A(S (i) ), zi ) âˆ’ `(A(S), zi ) `(A(S), z 0 ) âˆ’ `(A(S (i) ), z 0 )
+
.
m
m
(13.10)
The two subsections that follow continue the stability analysis for either Lipschitz or smooth loss functions. For both families of loss functions we show that
RLM is stable and therefore it does not overfit.

Î»kA(S (i) ) âˆ’ A(S)k2 â‰¤

13.3.1

Lipschitz Loss
If the loss function, `(Â·, zi ), is Ï-Lipschitz, then by the definition of Lipschitzness,
`(A(S (i) ), zi ) âˆ’ `(A(S), zi ) â‰¤ Ï kA(S (i) ) âˆ’ A(S)k.
Similarly,
`(A(S), z 0 ) âˆ’ `(A(S (i) ), z 0 ) â‰¤ Ï kA(S (i) ) âˆ’ A(S)k.
Plugging these inequalities into Equation (13.10) we obtain
Î»kA(S (i) ) âˆ’ A(S)k2 â‰¤

2 Ï kA(S (i) ) âˆ’ A(S)k
,
m

which yields
kA(S (i) ) âˆ’ A(S)k â‰¤

2Ï
.
Î»m

Plugging the preceding back into Equation (13.11) we conclude that
`(A(S (i) ), zi ) âˆ’ `(A(S), zi ) â‰¤

2 Ï2
.
Î»m

Since this holds for any S, z 0 , i we immediately obtain:

(13.11)

13.3 Tikhonov Regularization as a Stabilizer

177

corollary 13.6 Assume that the loss function is convex and Ï-Lipschitz.
Then, the RLM rule with the regularizer Î»kwk2 is on-average-replace-one-stable
2
with rate 2Î» Ïm . It follows (using Theorem 13.2) that
E m [LD (A(S)) âˆ’ LS (A(S))] â‰¤

Sâˆ¼D

13.3.2

2 Ï2
.
Î»m

Smooth and Nonnegative Loss
If the loss is Î²-smooth and nonnegative then it is also self-bounded (see Section 12.1):
kâˆ‡f (w)k2 â‰¤ 2Î²f (w).

(13.12)

We further assume that Î» â‰¥ 2Î²
m , or, in other words, that Î² â‰¤ Î»m/2. By the
smoothness assumption we have that
Î²
`(A(S (i) ), zi )âˆ’`(A(S), zi ) â‰¤ hâˆ‡`(A(S), zi ), A(S (i) )âˆ’A(S)i+ kA(S (i) )âˆ’A(S)k2 .
2
(13.13)
Using the Cauchy-Schwartz inequality and Equation (12.6) we further obtain
that
`(A(S (i) ), zi ) âˆ’ `(A(S), zi )
Î²
kA(S (i) ) âˆ’ A(S)k2
2
p
Î²
â‰¤ 2Î²`(A(S), zi ) kA(S (i) ) âˆ’ A(S)k + kA(S (i) ) âˆ’ A(S)k2 .
2
(13.14)

â‰¤ kâˆ‡`(A(S), zi )k kA(S (i) ) âˆ’ A(S)k +

By a symmetric argument it holds that,
`(A(S), z 0 ) âˆ’ `(A(S (i) ), z 0 )
q
Î²
â‰¤ 2Î²`(A(S (i) ), z 0 ) kA(S (i) ) âˆ’ A(S)k + kA(S (i) ) âˆ’ A(S)k2 .
2
Plugging these inequalities into Equation (13.10) and rearranging terms we obtain that
âˆš


q
p
2Î²
(i)
(i)
0
kA(S ) âˆ’ A(S)k â‰¤
`(A(S), zi ) + `(A(S ), z ) .
(Î» m âˆ’ Î²)
Combining the preceding with the assumption Î² â‰¤ Î»m/2 yields
âˆš

kA(S

(i)

8Î²
) âˆ’ A(S)k â‰¤
Î»m


p

`(A(S), zi ) +

q



`(A(S (i) ), z 0 )

.

178

Regularization and Stability

Combining the preceding with Equation (13.14) and again using the assumption
Î² â‰¤ Î»m/2 yield
`(A(S (i) ), zi ) âˆ’ `(A(S), zi )
p
Î²
â‰¤ 2Î²`(A(S), zi ) kA(S (i) ) âˆ’ A(S)k + kA(S (i) ) âˆ’ A(S)k2
2


2
q
2
p
4Î²
8Î²
(i)
0
â‰¤
+
`(A(S), zi ) + `(A(S ), z )
Î»m (Î»m)2
2

q
8Î² p
â‰¤
`(A(S), zi ) + `(A(S (i) ), z 0 )
Î»m

24Î² 
â‰¤
`(A(S), zi ) + `(A(S (i) ), z 0 ) ,
Î»m
where in the last step we used the inequality (a+b)2 â‰¤ 3(a2 +b2 ). Taking expectation with respect to S, z 0 , i and noting that E[`(A(S), zi )] = E[`(A(S (i) ), z 0 )] =
E[LS (A(S))], we conclude that:
corollary 13.7 Assume that the loss function is Î²-smooth and nonnegative.
Then, the RLM rule with the regularizer Î»kwk2 , where Î» â‰¥ 2Î²
m , satisfies
h
i 48Î²
E[LS (A(S))].
E `(A(S (i) ), zi ) âˆ’ `(A(S), zi ) â‰¤
Î»m
Note that if for all z we have `(0, z) â‰¤ C, for some scalar C > 0, then for
every S,
LS (A(S)) â‰¤ LS (A(S)) + Î»kA(S)k2 â‰¤ LS (0) + Î»k0k2 = LS (0) â‰¤ C.
Hence, Corollary 13.7 also implies that
h
i 48 Î² C
E `(A(S (i) ), zi ) âˆ’ `(A(S), zi ) â‰¤
.
Î»m

13.4

Controlling the Fitting-Stability Tradeoff
We can rewrite the expected risk of a learning algorithm as
E[LD (A(S))] = E[LS (A(S))] + E[LD (A(S)) âˆ’ LS (A(S))].
S

S

S

(13.15)

The first term reflects how well A(S) fits the training set while the second term
reflects the difference between the true and empirical risks of A(S). As we have
shown in Theorem 13.2, the second term is equivalent to the stability of A. Since
our goal is to minimize the risk of the algorithm, we need that the sum of both
terms will be small.
In the previous section we have bounded the stability term. We have shown
that the stability term decreases as the regularization parameter, Î», increases.
On the other hand, the empirical risk increases with Î». We therefore face a

13.4 Controlling the Fitting-Stability Tradeoff

179

tradeoff between fitting and overfitting. This tradeoff is quite similar to the biascomplexity tradeoff we discussed previously in the book.
We now derive bounds on the empirical risk term for the RLM rule. Recall
that the RLM rule is defined as A(S) = argminw LS (w) + Î»kwk2 . Fix some
arbitrary vector wâˆ— . We have
LS (A(S)) â‰¤ LS (A(S)) + Î»kA(S)k2 â‰¤ LS (wâˆ— ) + Î»kwâˆ— k2 .
Taking expectation of both sides with respect to S and noting that ES [LS (wâˆ— )] =
LD (wâˆ— ), we obtain that
E[LS (A(S))] â‰¤ LD (wâˆ— ) + Î»kwâˆ— k2 .

(13.16)

S

Plugging this into Equation (13.15) we obtain
E[LD (A(S))] â‰¤ LD (wâˆ— ) + Î»kwâˆ— k2 + E[LD (A(S)) âˆ’ LS (A(S))].
S

S

Combining the preceding with Corollary 13.6 we conclude:
corollary 13.8 Assume that the loss function is convex and Ï-Lipschitz.
Then, the RLM rule with the regularization function Î»kwk2 satisfies
âˆ€wâˆ— , E[LD (A(S))] â‰¤ LD (wâˆ— ) + Î»kwâˆ— k2 +
S

2Ï2
.
Î»m

This bound is often called an oracle inequality â€“ if we think of wâˆ— as a hypothesis with low risk, the bound tells us how many examples are needed so that
A(S) will be almost as good as wâˆ— , had we known the norm of wâˆ— . In practice,
however, we usually do not know the norm of wâˆ— . We therefore usually tune Î»
on the basis of a validation set, as described in Chapter 11.
We can also easily derive a PAC-like guarantee1 from Corollary 13.8 for convexLipschitz-bounded learning problems:
corollary 13.9 Let (H, Z, `) be a convex-Lipschitz-bounded
qlearning problem

with parameters Ï, B. For any training set size m, let Î» =
RLM rule with the regularization function Î»kwk2 satisfies
r
8
E[LD (A(S))] â‰¤ min LD (w) + Ï B
.
S
wâˆˆH
m
In particular, for every  > 0, if m â‰¥
ES [LD (A(S))] â‰¤ minwâˆˆH LD (w) + .

8Ï2 B 2
2

2Ï2
B2 m .

Then, the

then for every distribution D,

The preceding corollary holds for Lipschitz loss functions. If instead the loss
function is smooth and nonnegative, then we can combine Equation (13.16) with
Corollary 13.7 to get:
1

Again, the bound below is on the expected risk, but using Exercise 1 it can be used to
derive an agnostic PAC learning guarantee.

180

Regularization and Stability

corollary 13.10 Assume that the loss function is convex, Î²-smooth, and
nonnegative. Then, the RLM rule with the regularization function Î»kwk2 , for
âˆ—
Î» â‰¥ 2Î²
m , satisfies the following for all w :





48Î²
48Î²
E[LS (A(S))] â‰¤ 1 +
LD (wâˆ— ) + Î»kwâˆ— k2 .
E[LD (A(S))] â‰¤ 1 +
S
Î»m S
Î»m
For example, if we choose Î» = 48Î²
m we obtain from the preceding that the
expected true risk of A(S) is at most twice the expected empirical risk of A(S).
Furthermore, for this value of Î», the expected empirical risk of A(S) is at most
âˆ— 2
LD (wâˆ— ) + 48Î²
m kw k .
We can also derive a learnability guarantee for convex-smooth-bounded learning problems based on Corollary 13.10.
corollary 13.11 Let (H, Z, `) be a convex-smooth-bounded learning problem
with parameters Î², B. Assume in addition that `(0, z) â‰¤ 1 for all z âˆˆ Z. For any
2
and set Î» = /(3B 2 ). Then, for every distribution D,
 âˆˆ (0, 1) let m â‰¥ 150Î²B
2
E[LD (A(S))] â‰¤ min LD (w) +  .
S

13.5

wâˆˆH

Summary
We introduced stability and showed that if an algorithm is stable then it does not
overfit. Furthermore, for convex-Lipschitz-bounded or convex-smooth-bounded
problems, the RLM rule with Tikhonov regularization leads to a stable learning
algorithm. We discussed how the regularization parameter, Î», controls the tradeoff between fitting and overfitting. Finally, we have shown that all learning problems that are from the families of convex-Lipschitz-bounded and convex-smoothbounded problems are learnable using the RLM rule. The RLM paradigm is the
basis for many popular learning algorithms, including ridge regression (which we
discussed in this chapter) and support vector machines (which will be discussed
in Chapter 15).
In the next chapter we will present Stochastic Gradient Descent, which gives us
a very practical alternative way to learn convex-Lipschitz-bounded and convexsmooth-bounded problems and can also be used for efficiently implementing the
RLM rule.

13.6

Bibliographic Remarks
Stability is widely used in many mathematical contexts. For example, the necessity of stability for so-called inverse problems to be well posed was first recognized
by Hadamard (1902). The idea of regularization and its relation to stability became widely known through the works of Tikhonov (1943) and Phillips (1962).

13.7 Exercises

181

In the context of modern learning theory, the use of stability can be traced back
at least to the work of Rogers & Wagner (1978), which noted that the sensitivity of a learning algorithm with regard to small changes in the sample controls
the variance of the leave-one-out estimate. The authors used this observation to
obtain generalization bounds for the k-nearest neighbor algorithm (see Chapter 19). These results were later extended to other â€œlocalâ€ learning algorithms
(see Devroye, GyoÌˆrfi & Lugosi (1996) and references therein). In addition, practical methods have been developed to introduce stability into learning algorithms,
in particular the Bagging technique introduced by (Breiman 1996).
Over the last decade, stability was studied as a generic condition for learnability. See (Kearns & Ron 1999, Bousquet & Elisseeff 2002, Kutin & Niyogi 2002,
Rakhlin, Mukherjee & Poggio 2005, Mukherjee, Niyogi, Poggio & Rifkin 2006).
Our presentation follows the work of Shalev-Shwartz, Shamir, Srebro & Sridharan (2010), who showed that stability is sufficient and necessary for learning.
They have also shown that all convex-Lipschitz-bounded learning problems are
learnable using RLM, even though for some convex-Lipschitz-bounded learning
problems uniform convergence does not hold in a strong sense.

13.7

Exercises
1. From Bounded Expected Risk to Agnostic PAC Learning: Let A be
an algorithm that guarantees the following: If m â‰¥ mH () then for every
distribution D it holds that
E [LD (A(S))] â‰¤ min LD (h) + .

Sâˆ¼D m

hâˆˆH

â€¢ Show that for every Î´ âˆˆ (0, 1), if m â‰¥ mH ( Î´) then with probability of at
least 1 âˆ’ Î´ it holds that LD (A(S)) â‰¤ minhâˆˆH LD (h) + .
Hint: Observe that the random variable LD (A(S)) âˆ’ minhâˆˆH LD (h) is
nonnegative and rely on Markovâ€™s inequality.
â€¢ For every Î´ âˆˆ (0, 1) let


log(4/Î´) + log(dlog2 (1/Î´)e)
.
mH (, Î´) = mH (/2)dlog2 (1/Î´)e +
2
Suggest a procedure that agnostic PAC learns the problem with sample
complexity of mH (, Î´), assuming that the loss function is bounded by
1.
Hint: Let k = dlog2 (1/Î´)e. Divide the data into k +1 chunks, where each
of the first k chunks is of size mH (/2) examples. Train the first k chunks
using A. On the basis of the previous question argue that the probability
that for all of these chunks we have LD (A(S)) > minhâˆˆH LD (h) +  is
at most 2âˆ’k â‰¤ Î´/2. Finally, use the last chunk as a validation set.
2. Learnability without Uniform Convergence: Let B be the unit ball of

182

Regularization and Stability

Rd , let H = B, let Z = B Ã— {0, 1}d , and let ` : Z Ã— H â†’ R be defined as
follows:
`(w, (x, Î±)) =

d
X

Î±i (xi âˆ’ wi )2 .

i=1

This problem corresponds to an unsupervised learning task, meaning that we
do not try to predict the label of x. Instead, what we try to do is to find the
â€œcenter of massâ€ of the distribution over B. However, there is a twist, modeled
by the vectors Î±. Each example is a pair (x, Î±), where x is the instance x and
Î± indicates which features of x are â€œactiveâ€ and which are â€œturned off.â€ A
hypothesis is a vector w representing the center of mass of the distribution,
and the loss function is the squared Euclidean distance between x and w, but
only with respect to the â€œactiveâ€ elements of x.
â€¢ Show that this problem is learnable using the RLM rule with a sample
complexity that does not depend on d.
â€¢ Consider a distribution D over Z as follows: x is fixed to be some x0 , and
each element of Î± is sampled to be either 1 or 0 with equal probability.
Show that the rate of uniform convergence of this problem grows with
d.
Hint: Let m be a training set size. Show that if d  2m , then there is
a high probability of sampling a set of examples such that there exists
some j âˆˆ [d] for which Î±j = 1 for all the examples in the training set.
Show that such a sample cannot be -representative. Conclude that the
sample complexity of uniform convergence must grow with log(d).
â€¢ Conclude that if we take d to infinity we obtain a problem that is learnable
but for which the uniform convergence property does not hold. Compare
to the fundamental theorem of statistical learning.
3. Stability and Asymptotic ERM Are Sufficient for Learnability:
We say that a learning rule A is an AERM (Asymptotic Empirical Risk
Minimizer) with rate (m) if for every distribution D it holds that


E m LS (A(S)) âˆ’ min LS (h) â‰¤ (m).
Sâˆ¼D

hâˆˆH

We say that a learning rule A learns a class H with rate (m) if for every
distribution D it holds that


E m LD (A(S)) âˆ’ min LD (h) â‰¤ (m).
Sâˆ¼D

hâˆˆH

Prove the following:
theorem 13.12 If a learning algorithm A is on-average-replace-one-stable
with rate 1 (m) and is an AERM with rate 2 (m), then it learns H with rate
1 (m) + 2 (m).

13.7 Exercises

183

4. Strong Convexity with Respect to General Norms:
Throughout the section we used the `2 norm. In this exercise we generalize
some of the results to general norms. Let kÂ·k be some arbitrary norm, and let f
be a strongly convex function with respect to this norm (see Definition 13.4).
1. Show that items 2â€“3 of Lemma 13.5 hold for every norm.
2. (*) Give an example of a norm for which item 1 of Lemma 13.5 does not
hold.
3. Let R(w) be a function that is (2Î»)-strongly convex with respect to some
norm k Â· k. Let A be an RLM rule with respect to R, namely,
A(S) = argmin (LS (w) + R(w)) .
w

Assume that for every z, the loss function `(Â·, z) is Ï-Lipschitz with respect
to the same norm, namely,
âˆ€z, âˆ€w, v,

`(w, z) âˆ’ `(v, z) â‰¤ Ï kw âˆ’ vk .

Prove that A is on-average-replace-one-stable with rate
4. (*) Let q âˆˆ (1, 2) and consider the `q -norm
!1/q
d
X
q
kwkq =
|wi |
.

2Ï2
Î»m .

i=1

It can be shown (see, for example, Shalev-Shwartz (2007)) that the function
R(w) =

1
kwk2q
2(q âˆ’ 1)

log(d)
is 1-strongly convex with respect to kwkq . Show that if q = log(d)âˆ’1
then


1
R(w) is 3 log(d)
-strongly convex with respect to the `1 norm over Rd .

14 Stochastic Gradient Descent

Recall that the goal of learning is to minimize the risk function, LD (h) =
Ezâˆ¼D [`(h, z)]. We cannot directly minimize the risk function since it depends
on the unknown distribution D. So far in the book, we have discussed learning
methods that depend on the empirical risk. That is, we first sample a training
set S and define the empirical risk function LS (h). Then, the learner picks a
hypothesis based on the value of LS (h). For example, the ERM rule tells us to
pick the hypothesis that minimizes LS (h) over the hypothesis class, H. Or, in the
previous chapter, we discussed regularized risk minimization, in which we pick a
hypothesis that jointly minimizes LS (h) and a regularization function over h.
In this chapter we describe and analyze a rather different learning approach,
which is called Stochastic Gradient Descent (SGD). As in Chapter 12 we will
focus on the important family of convex learning problems, and following the
notation in that chapter, we will refer to hypotheses as vectors w that come from
a convex hypothesis class, H. In SGD, we try to minimize the risk function LD (w)
directly using a gradient descent procedure. Gradient descent is an iterative
optimization procedure in which at each step we improve the solution by taking
a step along the negative of the gradient of the function to be minimized at
the current point. Of course, in our case, we are minimizing the risk function,
and since we do not know D we also do not know the gradient of LD (w). SGD
circumvents this problem by allowing the optimization procedure to take a step
along a random direction, as long as the expected value of the direction is the
negative of the gradient. And, as we shall see, finding a random direction whose
expected value corresponds to the gradient is rather simple even though we do
not know the underlying distribution D.
The advantage of SGD, in the context of convex learning problems, over the
regularized risk minimization learning rule is that SGD is an efficient algorithm
that can be implemented in a few lines of code, yet still enjoys the same sample
complexity as the regularized risk minimization rule. The simplicity of SGD also
allows us to use it in situations when it is not possible to apply methods that
are based on the empirical risk, but this is beyond the scope of this book.
We start this chapter with the basic gradient descent algorithm and analyze its
convergence rate for convex-Lipschitz functions. Next, we introduce the notion of
subgradient and show that gradient descent can be applied for nondifferentiable
functions as well. The core of this chapter is Section 14.3, in which we describe
c 2014 by Shai Shalev-Shwartz and Shai Ben-David
Understanding Machine Learning, 
Published 2014 by Cambridge University Press.
Personal use only. Not for distribution. Do not post.
Please link to http://www.cs.huji.ac.il/~shais/UnderstandingMachineLearning

14.1 Gradient Descent

185

the Stochastic Gradient Descent algorithm, along with several useful variants.
We show that SGD enjoys an expected convergence rate similar to the rate
of gradient descent. Finally, we turn to the applicability of SGD to learning
problems.

14.1

Gradient Descent
Before we describe the stochastic gradient descent method, we would like to
describe the standard gradient descent approach for minimizing a differentiable
convex function f (w).
The gradient of a differentiable function f : Rd â†’ R at w,
 denoted âˆ‡f (w),


(w)
âˆ‚f (w)
is the vector of partial derivatives of f , namely, âˆ‡f (w) = âˆ‚f
âˆ‚w[1] , . . . , âˆ‚w[d] .
Gradient descent is an iterative algorithm. We start with an initial value of w
(say, w(1) = 0). Then, at each iteration, we take a step in the direction of the
negative of the gradient at the current point. That is, the update step is

w(t+1) = w(t) âˆ’ Î·âˆ‡f (w(t) ),

(14.1)

where Î· > 0 is a parameter to be discussed later. Intuitively, since the gradient points in the direction of the greatest rate of increase of f around w(t) ,
the algorithm makes a small step in the opposite direction, thus decreasing the
value of the function. Eventually, after T iterations, the algorithm outputs the
PT
averaged vector, wÌ„ = T1 t=1 w(t) . The output could also be the last vector,
w(T ) , or the best performing vector, argmintâˆˆ[T ] f (w(t) ), but taking the average
turns out to be rather useful, especially when we generalize gradient descent to
nondifferentiable functions and to the stochastic case.
Another way to motivate gradient descent is by relying on Taylor approximation. The gradient of f at w yields the first order Taylor approximation of f
around w by f (u) â‰ˆ f (w) + hu âˆ’ w, âˆ‡f (w)i. When f is convex, this approximation lower bounds f , that is,
f (u) â‰¥ f (w) + hu âˆ’ w, âˆ‡f (w)i.
Therefore, for w close to w(t) we have that f (w) â‰ˆ f (w(t) )+hwâˆ’w(t) , âˆ‡f (w(t) )i.
Hence we can minimize the approximation of f (w). However, the approximation
might become loose for w, which is far away from w(t) . Therefore, we would like
to minimize jointly the distance between w and w(t) and the approximation of
f around w(t) . If the parameter Î· controls the tradeoff between the two terms,
we obtain the update rule


1
w(t+1) = argmin kw âˆ’ w(t) k2 + Î· f (w(t) ) + hw âˆ’ w(t) , âˆ‡f (w(t) )i .
2
w
Solving the preceding by taking the derivative with respect to w and comparing
it to zero yields the same update rule as in Equation (14.1).

186

Stochastic Gradient Descent

Figure 14.1 An illustration of the gradient descent algorithm. The function to be

minimized is 1.25(x1 + 6)2 + (x2 âˆ’ 8)2 .

14.1.1

Analysis of GD for Convex-Lipschitz Functions
To analyze the convergence rate of the GD algorithm, we limit ourselves to
the case of convex-Lipschitz functions (as we have seen, many problems lend
themselves easily to this setting). Let w? be any vector and let B be an upper
bound on kw? k. It is convenient to think of w? as the minimizer of f (w), but
the analysis that follows holds for every w? .
We would like to obtain an upper bound on the suboptimality of our solution
PT
with respect to w? , namely, f (wÌ„) âˆ’ f (w? ), where wÌ„ = T1 t=1 w(t) . From the
definition of wÌ„, and using Jensenâ€™s inequality, we have that
!
T
X
w(t) âˆ’ f (w? )
f (wÌ„) âˆ’ f (w? ) = f T1
t=1

1
T

â‰¤

=

T 
X


f (w(t) ) âˆ’ f (w? )

t=1

T

1 X
f (w(t) ) âˆ’ f (w? ) .
T t=1

(14.2)

For every t, because of the convexity of f , we have that
f (w(t) ) âˆ’ f (w? ) â‰¤ hw(t) âˆ’ w? , âˆ‡f (w(t) )i.
Combining the preceding we obtain
f (wÌ„) âˆ’ f (w? ) â‰¤

T
1 X (t)
hw âˆ’ w? , âˆ‡f (w(t) )i.
T t=1

To bound the right-hand side we rely on the following lemma:

(14.3)

14.1 Gradient Descent

187

lemma 14.1 Let v1 , . . . , vT be an arbitrary sequence of vectors. Any algorithm
with an initialization w(1) = 0 and an update rule of the form
w(t+1) = w(t) âˆ’ Î·vt

(14.4)

T
T
X
Î·X
kw? k2
+
kvt k2 .
hw(t) âˆ’ w? , vt i â‰¤
2Î·
2
t=1
t=1

(14.5)

satisfies

In particular,
for every B, Ï > 0, if for all t we have that kvt k â‰¤ Ï and if we set
q
B2
Î· = Ï2 T , then for every w? with kw? k â‰¤ B we have
T
1 X (t)
BÏ
hw âˆ’ w? , vt i â‰¤ âˆš .
T t=1
T

Proof

Using algebraic manipulations (completing the square), we obtain:
1 (t)
hw âˆ’ w? , Î·vt i
Î·
1
=
(âˆ’kw(t) âˆ’ w? âˆ’ Î·vt k2 + kw(t) âˆ’ w? k2 + Î· 2 kvt k2 )
2Î·
1
Î·
=
(âˆ’kw(t+1) âˆ’ w? k2 + kw(t) âˆ’ w? k2 ) + kvt k2 ,
2Î·
2

hw(t) âˆ’ w? , vt i =

where the last equality follows from the definition of the update rule. Summing
the equality over t, we have
T
X

T
T
 Î·X
1 X
kvt k2 .
âˆ’kw(t+1) âˆ’ w? k2 + kw(t) âˆ’ w? k2 +
2Î·
2
t=1
t=1
t=1
(14.6)
The first sum on the right-hand side is a telescopic sum that collapses to

hw(t) âˆ’w? , vt i =

kw(1) âˆ’ w? k2 âˆ’ kw(T +1) âˆ’ w? k2 .
Plugging this in Equation (14.6), we have
T
T
X
1
Î·X
hw(t) âˆ’ w? , vt i =
(kw(1) âˆ’ w? k2 âˆ’ kw(T +1) âˆ’ w? k2 ) +
kvt k2
2Î·
2
t=1
t=1

â‰¤

T
1
Î·X
kw(1) âˆ’ w? k2 +
kvt k2
2Î·
2 t=1

=

T
Î·X
1
kw? k2 +
kvt k2 ,
2Î·
2 t=1

where the last equality is due to the definition w(1) = 0. This proves the first
part of the lemma (Equation (14.5)). The second part follows by upper bounding
kw? k by B, kvt k by Ï, dividing by T , and plugging in the value of Î·.

188

Stochastic Gradient Descent

Lemma 14.1 applies to the GD algorithm with vt = âˆ‡f (w(t) ). As we will
show later in Lemma 14.7, if f is Ï-Lipschitz, then kâˆ‡f (w(t) )k â‰¤ Ï. We therefore
satisfy the lemmaâ€™s conditions and achieve the following corollary:
corollary 14.2 Let f be a convex, Ï-Lipschitz function, and let w? âˆˆ argmin{w:kwkâ‰¤B} f (w).
q
2
If we run the GD algorithm on f for T steps with Î· = ÏB2 T , then the output
vector wÌ„ satisfies
BÏ
f (wÌ„) âˆ’ f (w? ) â‰¤ âˆš .
T
Furthermore, for every  > 0, to achieve f (wÌ„) âˆ’ f (w? ) â‰¤ , it suffices to run the
GD algorithm for a number of iterations that satisfies
T â‰¥

14.2

B 2 Ï2
.
2

Subgradients
The GD algorithm requires that the function f be differentiable. We now generalize the discussion beyond differentiable functions. We will show that the GD
algorithm can be applied to nondifferentiable functions by using a so-called subgradient of f (w) at w(t) , instead of the gradient.
To motivate the definition of subgradients, recall that for a convex function f ,
the gradient at w defines the slope of a tangent that lies below f , that is,
âˆ€u,

f (u) â‰¥ f (w) + hu âˆ’ w, âˆ‡f (w)i.

(14.7)

An illustration is given on the left-hand side of Figure 14.2.
The existence of a tangent that lies below f is an important property of convex
functions, which is in fact an alternative characterization of convexity.
lemma 14.3 Let S be an open convex set. A function f : S â†’ R is convex iff
for every w âˆˆ S there exists v such that
âˆ€u âˆˆ S,

f (u) â‰¥ f (w) + hu âˆ’ w, vi.

(14.8)

The proof of this lemma can be found in many convex analysis textbooks (e.g.,
(Borwein & Lewis 2006)). The preceding inequality leads us to the definition of
subgradients.
definition 14.4 (Subgradients) A vector v that satisfies Equation (14.8) is
called a subgradient of f at w. The set of subgradients of f at w is called the
differential set and denoted âˆ‚f (w).
An illustration of subgradients is given on the right-hand side of Figure 14.2.
For scalar functions, a subgradient of a convex function f at w is a slope of a
line that touches f at w and is not above f elsewhere.

189

f(

w

)i

14.2 Subgradients

w

f(

f (w)

w

)+

hu

âˆ’

w

,âˆ‡

f (u)

u

Figure 14.2 Left: The right-hand side of Equation (14.7) is the tangent of f at w. For
a convex function, the tangent lower bounds f . Right: Illustration of several
subgradients of a nondifferentiable convex function.

14.2.1

Calculating Subgradients
How do we construct subgradients of a given convex function? If a function is
differentiable at a point w, then the differential set is trivial, as the following
claim shows.
claim 14.5 If f is differentiable at w then âˆ‚f (w) contains a single element â€“
the gradient of f at w, âˆ‡f (w).
Example 14.1 (The Differential Set of the Absolute Function) Consider the
absolute value function f (x) = |x|. Using Claim 14.5, we can easily construct
the differential set for the differentiable parts of f , and the only point that
requires special attention is x0 = 0. At that point, it is easy to verify that the
subdifferential is the set of all numbers between âˆ’1 and 1. Hence:
ï£±
ï£´
if x > 0
ï£´
ï£²{1}
âˆ‚f (x) = {âˆ’1} if x < 0
ï£´
ï£´
ï£³[âˆ’1, 1] if x = 0
For many practical uses, we do not need to calculate the whole set of subgradients at a given point, as one member of this set would suffice. The following
claim shows how to construct a sub-gradient for pointwise maximum functions.
claim 14.6 Let g(w) = maxiâˆˆ[r] gi (w) for r convex differentiable functions
g1 , . . . , gr . Given some w, let j âˆˆ argmaxi gi (w). Then âˆ‡gj (w) âˆˆ âˆ‚g(w).
Proof

Since gj is convex we have that for all u
gj (u) â‰¥ gj (w) + hu âˆ’ w, âˆ‡gj (w)i.

Since g(w) = gj (w) and g(u) â‰¥ gj (u) we obtain that
g(u) â‰¥ g(w) + hu âˆ’ w, âˆ‡gj (w)i,
which concludes our proof.

190

Stochastic Gradient Descent

Example 14.2 (A Subgradient of the Hinge Loss) Recall the hinge loss function
from Section 12.3, f (w) = max{0, 1 âˆ’ yhw, xi} for some vector x and scalar y.
To calculate a subgradient of the hinge loss at some w we rely on the preceding
claim and obtain that the vector v defined in the following is a subgradient of
the hinge loss at w:
(
0
if 1 âˆ’ yhw, xi â‰¤ 0
v=
âˆ’yx if 1 âˆ’ yhw, xi > 0

14.2.2

Subgradients of Lipschitz Functions
Recall that a function f : A â†’ R is Ï-Lipschitz if for all u, v âˆˆ A
|f (u) âˆ’ f (v)| â‰¤ Ï ku âˆ’ vk.
The following lemma gives an equivalent definition using norms of subgradients.
lemma 14.7 Let A be a convex open set and let f : A â†’ R be a convex function.
Then, f is Ï-Lipschitz over A iff for all w âˆˆ A and v âˆˆ âˆ‚f (w) we have that
kvk â‰¤ Ï.
Proof Assume that for all v âˆˆ âˆ‚f (w) we have that kvk â‰¤ Ï. Since v âˆˆ âˆ‚f (w)
we have
f (w) âˆ’ f (u) â‰¤ hv, w âˆ’ ui.
Bounding the right-hand side using Cauchy-Schwartz inequality we obtain
f (w) âˆ’ f (u) â‰¤ hv, w âˆ’ ui â‰¤ kvk kw âˆ’ uk â‰¤ Ï kw âˆ’ uk.
An analogous argument can show that f (u) âˆ’ f (w) â‰¤ Ï kw âˆ’ uk. Hence f is
Ï-Lipschitz.
Now assume that f is Ï-Lipschitz. Choose some w âˆˆ A, v âˆˆ âˆ‚f (w). Since A
is open, there exists  > 0 such that u = w + v/kvk belongs to A. Therefore,
hu âˆ’ w, vi = kvk and ku âˆ’ wk = . From the definition of the subgradient,
f (u) âˆ’ f (w) â‰¥ hv, u âˆ’ wi = kvk.
On the other hand, from the Lipschitzness of f we have
Ï  = Ï ku âˆ’ wk â‰¥ f (u) âˆ’ f (w).
Combining the two inequalities we conclude that kvk â‰¤ Ï.

14.2.3

Subgradient Descent
The gradient descent algorithm can be generalized to nondifferentiable functions
by using a subgradient of f (w) at w(t) , instead of the gradient. The analysis of
the convergence rate remains unchanged: Simply note that Equation (14.3) is
true for subgradients as well.

14.3 Stochastic Gradient Descent (SGD)

191

Figure 14.3 An illustration of the gradient descent algorithm (left) and the stochastic

gradient descent algorithm (right). The function to be minimized is
1.25(x + 6)2 + (y âˆ’ 8)2 . For the stochastic case, the black line depicts the averaged
value of w.

14.3

Stochastic Gradient Descent (SGD)
In stochastic gradient descent we do not require the update direction to be based
exactly on the gradient. Instead, we allow the direction to be a random vector
and only require that its expected value at each iteration will equal the gradient
direction. Or, more generally, we require that the expected value of the random
vector will be a subgradient of the function at the current vector.
Stochastic Gradient Descent (SGD) for minimizing
f (w)
parameters: Scalar Î· > 0, integer T > 0
initialize: w(1) = 0
for t = 1, 2, . . . , T
choose vt at random from a distribution such that E[vt | w(t) ] âˆˆ âˆ‚f (w(t) )
update w(t+1) = w(t) âˆ’ Î·vt
PT
output wÌ„ = T1 t=1 w(t)
An illustration of stochastic gradient descent versus gradient descent is given
in Figure 14.3. As we will see in Section 14.5, in the context of learning problems,
it is easy to find a random vector whose expectation is a subgradient of the risk
function.

14.3.1

Analysis of SGD for Convex-Lipschitz-Bounded Functions
Recall the bound we achieved for the GD algorithm in Corollary 14.2. For the
stochastic case, in which only the expectation of vt is in âˆ‚f (w(t) ), we cannot
directly apply Equation (14.3). However, since the expected value of vt is a

192

Stochastic Gradient Descent

subgradient of f at w(t) , we can still derive a similar bound on the expected
output of stochastic gradient descent. This is formalized in the following theorem.
theorem 14.8 Let B, Ï > 0. Let f be a convex function and let w? âˆˆ argminw:kwkâ‰¤B f (w).
q
2
Assume that SGD is run for T iterations with Î· = ÏB2 T . Assume also that for
all t, kvt k â‰¤ Ï with probability 1. Then,
BÏ
E [f (wÌ„)] âˆ’ f (w? ) â‰¤ âˆš .
T
Therefore, for any  > 0, to achieve E[f (wÌ„)] âˆ’ f (w? ) â‰¤ , it suffices to run the
SGD algorithm for a number of iterations that satisfies
T â‰¥

B 2 Ï2
.
2

Proof Let us introduce the notation v1:t to denote the sequence v1 , . . . , vt .
Taking expectation of Equation (14.2), we obtain
" T
#
X
?
(t)
?
1
E [f (wÌ„) âˆ’ f (w )] â‰¤ E T
(f (w ) âˆ’ f (w )) .
v1:T

v1:T

t=1

Since Lemma 14.1 holds for any sequence v1 , v2 , ...vT , it applies to SGD as well.
By taking expectation of the bound in the lemma we have
#
"
T
BÏ
1 X (t)
?
(14.9)
hw âˆ’ w , vt i â‰¤ âˆš .
E
v1:T T
T
t=1
It is left to show that
" T
#
" T
#
X
X
(t)
?
(t)
?
1
1
E T
(f (w ) âˆ’ f (w )) â‰¤ E T
hw âˆ’ w , vt i ,
v1:T

v1:T

t=1

(14.10)

t=1

which we will hereby prove.
Using the linearity of the expectation we have
"
#
T
T
1 X (t)
1X
?
E
hw âˆ’ w , vt i =
E [hw(t) âˆ’ w? , vt i].
v1:T T
v1:T
T
t=1
t=1
Next, we recall the law of total expectation: For every two random variables Î±, Î²,
and a function g, EÎ± [g(Î±)] = EÎ² EÎ± [g(Î±)|Î²]. Setting Î± = v1:t and Î² = v1:tâˆ’1 we
get that
E [hw(t) âˆ’ w? , vt i] = E [hw(t) âˆ’ w? , vt i]

v1:T

v1:t

=

E

E [hw(t) âˆ’ w? , vt i | v1:tâˆ’1 ] .

v1:tâˆ’1 v1:t

Once we know v1:tâˆ’1 , the value of w(t) is not random any more and therefore
E

E [hw(t) âˆ’ w? , vt i | v1:tâˆ’1 ] =

v1:tâˆ’1 v1:t

E hw(t) âˆ’ w? , E [vt | v1:tâˆ’1 ]i .

v1:tâˆ’1

vt

14.4 Variants

193

Since w(t) only depends on v1:tâˆ’1 and SGD requires that Evt [vt | w(t) ] âˆˆ âˆ‚f (w(t) )
we obtain that Evt [vt | v1:tâˆ’1 ] âˆˆ âˆ‚f (w(t) ). Thus,
E hw(t) âˆ’ w? , E [vt | v1: tâˆ’1 ]i â‰¥

v1: tâˆ’1

vt

E [f (w(t) ) âˆ’ f (w? )].

v1: tâˆ’1

Overall, we have shown that
E [hw(t) âˆ’ w? , vt i] â‰¥

v1:T

E [f (w(t) ) âˆ’ f (w? )]

v1:tâˆ’1

= E [f (w(t) ) âˆ’ f (w? )] .
v1:T

Summing over t, dividing by T , and using the linearity of expectation, we get
that Equation (14.10) holds, which concludes our proof.

14.4

Variants
In this section we describe several variants of Stochastic Gradient Descent.

14.4.1

Adding a Projection Step
In the previous analyses of the GD and SGD algorithms, we required that the
norm of w? will be at most B, which is equivalent to requiring that w? is in the
set H = {w : kwk â‰¤ B}. In terms of learning, this means restricting ourselves to
a B-bounded hypothesis class. Yet any step we take in the opposite direction of
the gradient (or its expected direction) might result in stepping out of this bound,
and there is even no guarantee that wÌ„ satisfies it. We show in the following how
to overcome this problem while maintaining the same convergence rate.
The basic idea is to add a projection step; namely, we will now have a two-step
update rule, where we first subtract a subgradient from the current value of w
and then project the resulting vector onto H. Formally,
1

1.. w(t+ 2 ) = w(t) âˆ’ Î·vt
1
2.. w(t+1) = argminwâˆˆH kw âˆ’ w(t+ 2 ) k
The projection step replaces the current value of w by the vector in H closest
to it.
Clearly, the projection step guarantees that w(t) âˆˆ H for all t. Since H is
convex this also implies that wÌ„ âˆˆ H as required. We next show that the analysis
of SGD with projections remains the same. This is based on the following lemma.
lemma 14.9 (Projection Lemma)
projection of w onto H, namely,

Let H be a closed convex set and let v be the

v = argmin kx âˆ’ wk2 .
xâˆˆH

194

Stochastic Gradient Descent

Then, for every u âˆˆ H,
kw âˆ’ uk2 âˆ’ kv âˆ’ uk2 â‰¥ 0.
Proof By the convexity of H, for every Î± âˆˆ (0, 1) we have that v+Î±(uâˆ’v) âˆˆ H.
Therefore, from the optimality of v we obtain
kv âˆ’ wk2 â‰¤ kv + Î±(u âˆ’ v) âˆ’ wk2
= kv âˆ’ wk2 + 2Î±hv âˆ’ w, u âˆ’ vi + Î±2 ku âˆ’ vk2 .
Rearranging, we obtain
2hv âˆ’ w, u âˆ’ vi â‰¥ âˆ’Î± ku âˆ’ vk2 .
Taking the limit Î± â†’ 0 we get that
hv âˆ’ w, u âˆ’ vi â‰¥ 0.
Therefore,
kw âˆ’ uk2 = kw âˆ’ v + v âˆ’ uk2
= kw âˆ’ vk2 + kv âˆ’ uk2 + 2hv âˆ’ w, u âˆ’ vi
â‰¥ kv âˆ’ uk2 .

Equipped with the preceding lemma, we can easily adapt the analysis of SGD
to the case in which we add projection steps on a closed and convex set. Simply
note that for every t,
kw(t+1) âˆ’ w? k2 âˆ’ kw(t) âˆ’ w? k2
1

1

= kw(t+1) âˆ’ w? k2 âˆ’ kw(t+ 2 ) âˆ’ w? k2 + kw(t+ 2 ) âˆ’ w? k2 âˆ’ kw(t) âˆ’ w? k2
1

â‰¤ kw(t+ 2 ) âˆ’ w? k2 âˆ’ kw(t) âˆ’ w? k2 .
Therefore, Lemma 14.1 holds when we add projection steps and hence the rest
of the analysis follows directly.

14.4.2

Variable Step Size
Another variant of SGD is decreasing the step size as a function of t. That is,
rather than updating with a constant Î·, we use Î·t . For instance, we can set
âˆš and achieve a bound similar to Theorem 14.8. The idea is that when
Î·t = ÏB
t
we are closer to the minimum of the function, we take our steps more carefully,
so as not to â€œovershootâ€ the minimum.

14.4 Variants

14.4.3

195

Other Averaging Techniques
PT
We have set the output vector to be wÌ„ = T1 t=1 w(t) . There are alternative
approaches such as outputting w(t) for some random t âˆˆ [t], or outputting the
average of w(t) over the last Î±T iterations, for some Î± âˆˆ (0, 1). One can also take
a weighted average of the last few iterates. These more sophisticated averaging
schemes can improve the convergence speed in some situations, such as in the
case of strongly convex functions defined in the following.

14.4.4

Strongly Convex Functions*
In this section we show a variant of SGD that enjoys a faster convergence rate for
problems in which the objective function is strongly convex (see Definition 13.4
of strong convexity in the previous chapter). We rely on the following claim,
which generalizes Lemma 13.5.
claim 14.10
have

If f is Î»-strongly convex then for every w, u and v âˆˆ âˆ‚f (w) we
hw âˆ’ u, vi â‰¥ f (w) âˆ’ f (u) + Î»2 kw âˆ’ uk2 .

The proof is similar to the proof of Lemma 13.5 and is left as an exercise.
SGD for minimizing a Î»-strongly convex function
Goal: Solve minwâˆˆH f (w)
parameter: T
initialize: w(1) = 0
for t = 1, . . . , T
Choose a random vector vt s.t. E[vt |w(t) ] âˆˆ âˆ‚f (w(t) )
Set Î·t = 1/(Î» t)
1
Set w(t+ 2 ) = w(t) âˆ’ Î·t vt
1
Set w(t+1) = arg minwâˆˆH kw âˆ’ w(t+ 2 ) k2
P
T
output: wÌ„ = T1 t=1 w(t)
theorem 14.11 Assume that f is Î»-strongly convex and that E[kvt k2 ] â‰¤ Ï2 .
Let w? âˆˆ argminwâˆˆH f (w) be an optimal solution. Then,
E[f (wÌ„)] âˆ’ f (w? ) â‰¤

Ï2
(1 + log(T )).
2Î»T

Proof Let âˆ‡(t) = E[vt |w(t) ]. Since f is strongly convex and âˆ‡(t) is in the
subgradient set of f at w(t) we have that
hw(t) âˆ’ w? , âˆ‡(t) i â‰¥ f (w(t) ) âˆ’ f (w? ) + Î»2 kw(t) âˆ’ w? k2 .

(14.11)

Next, we show that
hw(t) âˆ’ w? , âˆ‡(t) i â‰¤

E[kw(t) âˆ’ w? k2 âˆ’ kw(t+1) âˆ’ w? k2 ] Î·t 2
+ Ï .
2 Î·t
2

(14.12)

196

Stochastic Gradient Descent

1

Since w(t+1) is the projection of w(t+ 2 ) onto H, and w? âˆˆ H we have that
1
kw(t+ 2 ) âˆ’ w? k2 â‰¥ kw(t+1) âˆ’ w? k2 . Therefore,
1

kw(t) âˆ’ w? k2 âˆ’ kw(t+1) âˆ’ w? k2 â‰¥ kw(t) âˆ’ w? k2 âˆ’ kw(t+ 2 ) âˆ’ w? k2
= 2Î·t hw(t) âˆ’ w? , vt i âˆ’ Î·t2 kvt k2 .
Taking expectation of both sides, rearranging, and using the assumption E[kvt k2 ] â‰¤
Ï2 yield Equation (14.12). Comparing Equation (14.11) and Equation (14.12) and
summing over t we obtain
T
X
(E[f (w(t) )] âˆ’ f (w? ))
t=1

â‰¤E

" T 
X kw(t) âˆ’ w? k2 âˆ’ kw(t+1) âˆ’ w? k2
t=1

2 Î·t

âˆ’

(t)
Î»
2 kw

? 2

#

âˆ’w k

+

T
Ï2 X
Î·t .
2 t=1

Next, we use the definition Î·t = 1/(Î» t) and note that the first sum on the
right-hand side of the equation collapses to âˆ’Î»T kw(T +1) âˆ’ w? k2 â‰¤ 0. Thus,
T
T
X
Ï2 X 1
Ï2
(E[f (w(t) )] âˆ’ f (w? )) â‰¤
â‰¤
(1 + log(T )).
2 Î» t=1 t
2Î»
t=1

The theorem follows from the preceding by dividing by T and using Jensenâ€™s
inequality.
Remark 14.3 Rakhlin, Shamir & Sridharan (2012) derived a convergence rate
in which the log(T ) term is eliminated for a variant of the algorithm in which
PT
we output the average of the last T /2 iterates, wÌ„ = T2 t=T /2+1 w(t) . Shamir &
Zhang (2013) have shown that Theorem 14.11 holds even if we output wÌ„ = w(T ) .

14.5

Learning with SGD
We have so far introduced and analyzed the SGD algorithm for general convex
functions. Now we shall consider its applicability to learning tasks.

14.5.1

SGD for Risk Minimization
Recall that in learning we face the problem of minimizing the risk function
LD (w) = E [`(w, z)].
zâˆ¼D

We have seen the method of empirical risk minimization, where we minimize the
empirical risk, LS (w), as an estimate to minimizing LD (w). SGD allows us to
take a different approach and minimize LD (w) directly. Since we do not know
D, we cannot simply calculate âˆ‡LD (w(t) ) and minimize it with the GD method.
With SGD, however, all we need is to find an unbiased estimate of the gradient of

14.5 Learning with SGD

197

LD (w), that is, a random vector whose conditional expected value is âˆ‡LD (w(t) ).
We shall now see how such an estimate can be easily constructed.
For simplicity, let us first consider the case of differentiable loss functions.
Hence the risk function LD is also differentiable. The construction of the random
vector vt will be as follows: First, sample z âˆ¼ D. Then, define vt to be the
gradient of the function `(w, z) with respect to w, at the point w(t) . Then, by
the linearity of the gradient we have
E[vt |w(t) ] = E [âˆ‡`(w(t) , z)] = âˆ‡ E [`(w(t) , z)] = âˆ‡LD (w(t) ).
zâˆ¼D

zâˆ¼D

(14.13)

The gradient of the loss function `(w, z) at w(t) is therefore an unbiased estimate
of the gradient of the risk function LD (w(t) ) and is easily constructed by sampling
a single fresh example z âˆ¼ D at each iteration t.
The same argument holds for nondifferentiable loss functions. We simply let
vt be a subgradient of `(w, z) at w(t) . Then, for every u we have
`(u, z) âˆ’ `(w(t) , z) â‰¥ hu âˆ’ w(t) , vt i.
Taking expectation on both sides with respect to z âˆ¼ D and conditioned on the
value of w(t) we obtain
LD (u) âˆ’ LD (w(t) ) = E[`(u, z) âˆ’ `(w(t) , z)|w(t) ]
â‰¥ E[hu âˆ’ w(t) , vt i|w(t) ]
= hu âˆ’ w(t) , E[vt |w(t) ]i.
It follows that E[vt |w(t) ] is a subgradient of LD (w) at w(t) .
To summarize, the stochastic gradient descent framework for minimizing the
risk is as follows.
Stochastic Gradient Descent (SGD) for minimizing
LD (w)
parameters: Scalar Î· > 0, integer T > 0
initialize: w(1) = 0
for t = 1, 2, . . . , T
sample z âˆ¼ D
pick vt âˆˆ âˆ‚`(w(t) , z)
update w(t+1) = w(t) âˆ’ Î·vt
PT
output wÌ„ = T1 t=1 w(t)
We shall now use our analysis of SGD to obtain a sample complexity analysis for learning convex-Lipschitz-bounded problems. Theorem 14.8 yields the
following:
corollary 14.12 Consider a convex-Lipschitz-bounded learning problem with
parameters Ï, B. Then, for every  > 0, if we run the SGD method for minimizing

198

Stochastic Gradient Descent

LD (w) with a number of iterations (i.e., number of examples)
T â‰¥
and with Î· =

q

B2
Ï2 T

B 2 Ï2
2

, then the output of SGD satisfies
E [LD (wÌ„)] â‰¤ min LD (w) + .
wâˆˆH

It is interesting to note that the required sample complexity is of the same order
of magnitude as the sample complexity guarantee we derived for regularized loss
minimization. In fact, the sample complexity of SGD is even better than what
we have derived for regularized loss minimization by a factor of 8.

14.5.2

Analyzing SGD for Convex-Smooth Learning Problems
In the previous chapter we saw that the regularized loss minimization rule also
learns the class of convex-smooth-bounded learning problems. We now show that
the SGD algorithm can be also used for such problems.
theorem 14.13 Assume that for all z, the loss function `(Â·, z) is convex, Î²smooth, and nonnegative. Then, if we run the SGD algorithm for minimizing
LD (w) we have that for every w? ,


1
kw? k2
E[LD (wÌ„)] â‰¤
LD (w? ) +
.
1 âˆ’ Î·Î²
2Î· T
Proof Recall that if a function is Î²-smooth and nonnegative then it is selfbounded:
kâˆ‡f (w)k2 â‰¤ 2Î²f (w).
To analyze SGD for convex-smooth problems, let us define z1 , . . . , zT the random
samples of the SGD algorithm, let ft (Â·) = `(Â·, zt ), and note that vt = âˆ‡ft (w(t) ).
For all t, ft is a convex function and therefore ft (w(t) )âˆ’ft (w? ) â‰¤ hvt , w(t) âˆ’w? i.
Summing over t and using Lemma 14.1 we obtain
T
T
T
X
X
kw? k2
Î·X
kvt k2 .
(ft (w(t) ) âˆ’ ft (w? )) â‰¤
hvt , w(t) âˆ’ w? i â‰¤
+
2Î·
2
t=1
t=1
t=1

Combining the preceding with the self-boundedness of ft yields
T
T
X
X
kw? k2
(ft (w(t) ) âˆ’ ft (w? )) â‰¤
+ Î·Î²
ft (w(t) ).
2Î·
t=1
t=1

Dividing by T and rearranging, we obtain
T
1X
1
ft (w(t) ) â‰¤
T t=1
1 âˆ’ Î·Î²

T
1X
kw? k2
ft (w? ) +
T t=1
2Î· T

!
.

Next, we take expectation of the two sides of the preceding equation with respect

14.5 Learning with SGD

199

to z1 , . . . , zT . Clearly, E[ft (w? )] = LD (w? ). In addition, using the same argument
as in the proof of Theorem 14.8 we have that
"

#
"
#
T
T
1X
1X
(t)
(t)
ft (w ) = E
LD (w ) â‰¥ E[LD (wÌ„)].
E
T t=1
T t=1
Combining all we conclude our proof.
As a direct corollary we obtain:
corollary 14.14 Consider a convex-smooth-bounded learning problem with
parameters Î², B. Assume in addition that `(0, z) â‰¤ 1 for all z âˆˆ Z. For every
1
 > 0, set Î· = Î²(1+3/)
. Then, running SGD with T â‰¥ 12B 2 Î²/2 yields
E[LD (wÌ„)] â‰¤ min LD (w) + .
wâˆˆH

14.5.3

SGD for Regularized Loss Minimization
We have shown that SGD enjoys the same worst-case sample complexity bound
as regularized loss minimization. However, on some distributions, regularized loss
minimization may yield a better solution. Therefore, in some cases we may want
to solve the optimization problem associated with regularized loss minimization,
namely,1

min
w


Î»
2
kwk + LS (w) .
2

(14.14)

Since we are dealing with convex learning problems in which the loss function is
convex, the preceding problem is also a convex optimization problem that can
be solved using SGD as well, as we shall see in this section.
Define f (w) = Î»2 kwk2 + LS (w). Note that f is a Î»-strongly convex function;
therefore, we can apply the SGD variant given in Section 14.4.4 (with H = Rd ).
To apply this algorithm, we only need to find a way to construct an unbiased
estimate of a subgradient of f at w(t) . This is easily done by noting that if
we pick z uniformly at random from S, and choose vt âˆˆ âˆ‚`(w(t) , z) then the
expected value of Î»w(t) + vt is a subgradient of f at w(t) .
To analyze the resulting algorithm, we first rewrite the update rule (assuming
1

We divided Î» by 2 for convenience.

200

Stochastic Gradient Descent

that H = Rd and therefore the projection step does not matter) as follows

1  (t)
w(t+1) = w(t) âˆ’
Î»w + vt
Î»

t
1
1
= 1âˆ’
w(t) âˆ’
vt
t
Î»t
t âˆ’ 1 (t)
1
=
w âˆ’
vt
t 
Î»t

1
t âˆ’ 1 t âˆ’ 2 (tâˆ’1)
1
w
vtâˆ’1 âˆ’
vt
=
âˆ’
t
tâˆ’1
Î» (t âˆ’ 1)
Î»t
t
1 X
=âˆ’
vi .
(14.15)
Î» t i=1
If we assume that the loss function is Ï-Lipschitz, it follows that for all t we have
kvt k â‰¤ Ï and therefore kÎ»w(t) k â‰¤ Ï, which yields
kÎ»w(t) + vt k â‰¤ 2Ï.
Theorem 14.11 therefore tells us that after performing T iterations we have that
E[f (wÌ„)] âˆ’ f (w? ) â‰¤

14.6

4Ï2
(1 + log(T )).
Î»T

Summary
We have introduced the Gradient Descent and Stochastic Gradient Descent algorithms, along with several of their variants. We have analyzed their convergence
rate and calculated the number of iterations that would guarantee an expected
objective of at most  plus the optimal objective. Most importantly, we have
shown that by using SGD we can directly minimize the risk function. We do
so by sampling a point i.i.d from D and using a subgradient of the loss of the
current hypothesis w(t) at this point as an unbiased estimate of the gradient (or
a subgradient) of the risk function. This implies that a bound on the number of
iterations also yields a sample complexity bound. Finally, we have also shown
how to apply the SGD method to the problem of regularized risk minimization.
In future chapters we show how this yields extremely simple solvers to some
optimization problems associated with regularized risk minimization.

14.7

Bibliographic Remarks
SGD dates back to Robbins & Monro (1951). It is especially effective in large
scale machine learning problems. See, for example, (Murata 1998, Le Cun 2004,
Zhang 2004, Bottou & Bousquet 2008, Shalev-Shwartz, Singer & Srebro 2007,
Shalev-Shwartz & Srebro 2008). In the optimization community it was studied

14.8 Exercises

201

in the context of stochastic optimization. See, for example, (Nemirovski & Yudin
1978, Nesterov & Nesterov 2004, Nesterov 2005, Nemirovski, Juditsky, Lan &
Shapiro 2009, Shapiro, Dentcheva & RuszczynÌski 2009).
The bound we have derived for strongly convex function is due to Hazan,
Agarwal & Kale (2007). As mentioned previously, improved bounds have been
obtained in Rakhlin et al. (2012).

14.8

Exercises
1. Prove Claim 14.10. Hint: Extend the proof of Lemma 13.5.
2. Prove Corollary 14.14.
3. Perceptron as a subgradient descent algorithm: Let S = ((x1 , y1 ), . . . , (xm , ym )) âˆˆ
(Rd Ã— {Â±1})m . Assume that there exists w âˆˆ Rd such that for every i âˆˆ [m]
we have yi hw, xi i â‰¥ 1, and let w? be a vector that has the minimal norm
among all vectors that satisfy the preceding requirement. Let R = maxi kxi k.
Define a function
f (w) = max (1 âˆ’ yi hw, xi i) .
iâˆˆ[m]

â€¢ Show that minw:kwkâ‰¤kw? k f (w) = 0 and show that any w for which f (w) <
1 separates the examples in S.
â€¢ Show how to calculate a subgradient of f .
â€¢ Describe and analyze the subgradient descent algorithm for this case. Compare the algorithm and the analysis to the Batch Perceptron algorithm
given in Section 9.1.2.
4. Variable step size (*): Prove an analog of Theorem 14.8 for SGD with a
âˆš .
variable step size, Î·t = ÏB
t

15 Support Vector Machines

In this chapter and the next we discuss a very useful machine learning tool: the
support vector machine paradigm (SVM) for learning linear predictors in high
dimensional feature spaces. The high dimensionality of the feature space raises
both sample complexity and computational complexity challenges.
The SVM algorithmic paradigm tackles the sample complexity challenge by
searching for â€œlarge marginâ€ separators. Roughly speaking, a halfspace separates
a training set with a large margin if all the examples are not only on the correct
side of the separating hyperplane but also far away from it. Restricting the
algorithm to output a large margin separator can yield a small sample complexity
even if the dimensionality of the feature space is high (and even infinite). We
introduce the concept of margin and relate it to the regularized loss minimization
paradigm as well as to the convergence rate of the Perceptron algorithm.
In the next chapter we will tackle the computational complexity challenge
using the idea of kernels.

15.1

Margin and Hard-SVM
Let S = (x1 , y1 ), . . . , (xm , ym ) be a training set of examples, where each xi âˆˆ Rd
and yi âˆˆ {Â±1}. We say that this training set is linearly separable, if there exists
a halfspace, (w, b), such that yi = sign(hw, xi i + b) for all i. Alternatively, this
condition can be rewritten as

âˆ€i âˆˆ [m], yi (hw, xi i + b) > 0.

All halfspaces (w, b) that satisfy this condition are ERM hypotheses (their 0-1
error is zero, which is the minimum possible error). For any separable training
sample, there are many ERM halfspaces. Which one of them should the learner
pick?
Consider, for example, the training set described in the picture that follows.
c 2014 by Shai Shalev-Shwartz and Shai Ben-David
Understanding Machine Learning, 
Published 2014 by Cambridge University Press.
Personal use only. Not for distribution. Do not post.
Please link to http://www.cs.huji.ac.il/~shais/UnderstandingMachineLearning

15.1 Margin and Hard-SVM

203

x

x

While both the dashed-black and solid-green hyperplanes separate the four examples, our intuition would probably lead us to prefer the black hyperplane over
the green one. One way to formalize this intuition is using the concept of margin.
The margin of a hyperplane with respect to a training set is defined to be the
minimal distance between a point in the training set and the hyperplane. If a
hyperplane has a large margin, then it will still separate the training set even if
we slightly perturb each instance.
We will see later on that the true error of a halfspace can be bounded in terms
of the margin it has over the training sample (the larger the margin, the smaller
the error), regardless of the Euclidean dimension in which this halfspace resides.
Hard-SVM is the learning rule in which we return an ERM hyperplane that
separates the training set with the largest possible margin. To define Hard-SVM
formally, we first express the distance between a point x to a hyperplane using
the parameters defining the halfspace.
claim 15.1 The distance between a point x and the hyperplane defined by
(w, b) where kwk = 1 is |hw, xi + b|.
Proof

The distance between a point x and the hyperplane is defined as
min{kx âˆ’ vk : hw, vi + b = 0}.

Taking v = x âˆ’ (hw, xi + b)w we have that
hw, vi + b = hw, xi âˆ’ (hw, xi + b)kwk2 + b = 0,
and
kx âˆ’ vk = |hw, xi + b| kwk = |hw, xi + b|.
Hence, the distance is at most |hw, xi + b|. Next, take any other point u on the
hyperplane, thus hw, ui + b = 0. We have
kx âˆ’ uk2 = kx âˆ’ v + v âˆ’ uk2
= kx âˆ’ vk2 + kv âˆ’ uk2 + 2hx âˆ’ v, v âˆ’ ui
â‰¥ kx âˆ’ vk2 + 2hx âˆ’ v, v âˆ’ ui
= kx âˆ’ vk2 + 2(hw, xi + b)hw, v âˆ’ ui
= kx âˆ’ vk2 ,
where the last equality is because hw, vi = hw, ui = âˆ’b. Hence, the distance

204

Support Vector Machines

between x and u is at least the distance between x and v, which concludes our
proof.
On the basis of the preceding claim, the closest point in the training set to the
separating hyperplane is miniâˆˆ[m] |hw, xi i + b|. Therefore, the Hard-SVM rule is
min |hw, xi i + b| s.t. âˆ€i, yi (hw, xi i + b) > 0.

argmax

(w,b):kwk=1 iâˆˆ[m]

Whenever there is a solution to the preceding problem (i.e., we are in the separable case), we can write an equivalent problem as follows (see Exercise 1):
min yi (hw, xi i + b).

argmax

(15.1)

(w,b):kwk=1 iâˆˆ[m]

Next, we give another equivalent formulation of the Hard-SVM rule as a quadratic
optimization problem.1
Hard-SVM
input: (x1 , y1 ), . . . , (xm , ym )
solve:
(w0 , b0 ) = argmin kwk2 s.t. âˆ€i, yi (hw, xi i + b) â‰¥ 1

(15.2)

(w,b)

output: wÌ‚ =

w0
kw0 k ,

bÌ‚ =

b0
kw0 k

The lemma that follows shows that the output of hard-SVM is indeed the
separating hyperplane with the largest margin. Intuitively, hard-SVM searches
for w of minimal norm among all the vectors that separate the data and for
which |hw, xi i + b| â‰¥ 1 for all i. In other words, we enforce the margin to be 1,
but now the units in which we measure the margin scale with the norm of w.
Therefore, finding the largest margin halfspace boils down to finding w whose
norm is minimal. Formally:
lemma 15.2

The output of Hard-SVM is a solution of Equation (15.1).

Proof Let (w? , b? ) be a solution of Equation (15.1) and define the margin
achieved by (w? , b? ) to be Î³ ? = miniâˆˆ[m] yi (hw? , xi i + b? ). Therefore, for all
i we have
yi (hw? , xi i + b? ) â‰¥ Î³ ?
or equivalently
?

yi (h w
Î³ ? , xi i +
?

b?
Î³? )

â‰¥ 1.

?

b
Hence, the pair ( w
Î³ ? , Î³ ? ) satisfies the conditions of the quadratic optimization
1

A quadratic optimization problem is an optimization problem in which the objective is a
convex quadratic function and the constraints are linear inequalities.

15.1 Margin and Hard-SVM

?

problem given in Equation (15.2). Therefore, kw0 k â‰¤ k w
Î³? k =
for all i,
yi (hwÌ‚, xi i + bÌ‚) =

1
Î³? .

205

It follows that

1
1
yi (hw0 , xi i + b0 ) â‰¥
â‰¥ Î³?.
kw0 k
kw0 k

Since kwÌ‚k = 1 we obtain that (wÌ‚, bÌ‚) is an optimal solution of Equation (15.1).

15.1.1

The Homogenous Case
It is often more convenient to consider homogenous halfspaces, namely, halfspaces
that pass through the origin and are thus defined by sign(hw, xi), where the bias
term b is set to be zero. Hard-SVM for homogenous halfspaces amounts to solving
min kwk2
w

s.t. âˆ€i, yi hw, xi i â‰¥ 1.

(15.3)

As we discussed in Chapter 9, we can reduce the problem of learning nonhomogenous
halfspaces to the problem of learning homogenous halfspaces by adding one more
feature to each instance of xi , thus increasing the dimension to d + 1.
Note, however, that the optimization problem given in Equation (15.2) does
not regularize the bias term b, while if we learn a homogenous halfspace in Rd+1
using Equation (15.3) then we regularize the bias term (i.e., the d + 1 component
of the weight vector) as well. However, regularizing b usually does not make a
significant difference to the sample complexity.

15.1.2

The Sample Complexity of Hard-SVM
Recall that the VC-dimension of halfspaces in Rd is d + 1. It follows that the
sample complexity of learning halfspaces grows with the dimensionality of the
problem. Furthermore, the fundamental theorem of learning tells us that if the
number of examples is significantly smaller than d/ then no algorithm can learn
an -accurate halfspace. This is problematic when d is very large.
To overcome this problem, we will make an additional assumption on the
underlying data distribution. In particular, we will define a â€œseparability with
margin Î³â€ assumption and will show that if the data is separable with margin
Î³ then the sample complexity is bounded from above by a function of 1/Î³ 2 . It
follows that even if the dimensionality is very large (or even infinite), as long as
the data adheres to the separability with margin assumption we can still have a
small sample complexity. There is no contradiction to the lower bound given in
the fundamental theorem of learning because we are now making an additional
assumption on the underlying data distribution.
Before we formally define the separability with margin assumption, there is a
scaling issue we need to resolve. Suppose that a training set S = (x1 , y1 ), . . . , (xm , ym )
is separable with a margin Î³, namely, the maximal objective value of Equation (15.1) is at least Î³. Then, for any positive scalar Î± > 0, the training set

206

Support Vector Machines

S 0 = (Î±x1 , y1 ), . . . , (Î±xm , ym ) is separable with a margin of Î±Î³. That is, a simple scaling of the data can make it separable with an arbitrarily large margin. It
follows that in order to give a meaningful definition of margin we must take into
account the scale of the examples as well. One way to formalize this is using the
definition that follows.
definition 15.3 Let D be a distribution over Rd Ã— {Â±1}. We say that D is
separable with a (Î³, Ï)-margin if there exists (w? , b? ) such that kw? k = 1 and
such that with probability 1 over the choice of (x, y) âˆ¼ D we have that y(hw? , xi+
b? ) â‰¥ Î³ and kxk â‰¤ Ï. Similarly, we say that D is separable with a (Î³, Ï)-margin
using a homogenous halfspace if the preceding holds with a halfspace of the form
(w? , 0).
In the advanced part of the book (Chapter 26), we will prove that the sample
complexity of Hard-SVM depends on (Ï/Î³)2 and is independent of the dimension
d. In particular, Theorem 26.13 in Section 26.3 states the following:
theorem 15.4 Let D be a distribution over Rd Ã— {Â±1} that satisfies the (Î³, Ï)separability with margin assumption using a homogenous halfspace. Then, with
probability of at least 1 âˆ’ Î´ over the choice of a training set of size m, the 0-1
error of the output of Hard-SVM is at most
r
r
4 (Ï/Î³)2
2 log(2/Î´)
+
.
m
m
Remark 15.1 (Margin and the Perceptron) In Section 9.1.2 we have described
and analyzed the Perceptron algorithm for finding an ERM hypothesis with
respect to the class of halfspaces. In particular, in Theorem 9.1 we upper bounded
the number of updates the Perceptron might make on a given training set. It
can be shown (see Exercise 2) that the upper bound is exactly (Ï/Î³)2 , where Ï
is the radius of examples and Î³ is the margin.

15.2

Soft-SVM and Norm Regularization
The Hard-SVM formulation assumes that the training set is linearly separable,
which is a rather strong assumption. Soft-SVM can be viewed as a relaxation of
the Hard-SVM rule that can be applied even if the training set is not linearly
separable.
The optimization problem in Equation (15.2) enforces the hard constraints
yi (hw, xi i + b) â‰¥ 1 for all i. A natural relaxation is to allow the constraint to be
violated for some of the examples in the training set. This can be modeled by
introducing nonnegative slack variables, Î¾1 , . . . , Î¾m , and replacing each constraint
yi (hw, xi i + b) â‰¥ 1 by the constraint yi (hw, xi i + b) â‰¥ 1 âˆ’ Î¾i . That is, Î¾i measures
by how much the constraint yi (hw, xi i+b) â‰¥ 1 is being violated. Soft-SVM jointly
minimizes the norm of w (corresponding to the margin) and the average of Î¾i
(corresponding to the violations of the constraints). The tradeoff between the two

15.2 Soft-SVM and Norm Regularization

207

terms is controlled by a parameter Î». This leads to the Soft-SVM optimization
problem:
Soft-SVM
input: (x1 , y1 ), . . . , (xm , ym )
parameter: Î» > 0
solve:
m

min

w,b,Î¾

1 X
Î¾i
Î»kwk +
m i=1

!

2

(15.4)

s.t. âˆ€i, yi (hw, xi i + b) â‰¥ 1 âˆ’ Î¾i and Î¾i â‰¥ 0
output: w, b
We can rewrite Equation (15.4) as a regularized loss minimization problem.
Recall the definition of the hinge loss:
`hinge ((w, b), (x, y)) = max{0, 1 âˆ’ y(hw, xi + b)}.
Given (w, b) and a training set S, the averaged hinge loss on S is denoted by
Lhinge
((w, b)). Now, consider the regularized loss minimization problem:
S


min Î»kwk2 + Lhinge
((w,
b))
.
(15.5)
S
w,b

claim 15.5

Equation (15.4) and Equation (15.5) are equivalent.

Proof Fix some w, b and consider the minimization over Î¾ in Equation (15.4).
Fix some i. Since Î¾i must be nonnegative, the best assignment to Î¾i would be 0
if yi (hw, xi i + b) â‰¥ 1 and would be 1 âˆ’ yi (hw, xi i + b) otherwise. In other words,
Î¾i = `hinge ((w, b), (xi , yi )) for all i, and the claim follows.
We therefore see that Soft-SVM falls into the paradigm of regularized loss
minimization that we studied in the previous chapter. A Soft-SVM algorithm,
that is, a solution for Equation (15.5), has a bias toward low norm separators.
The objective function that we aim to minimize in Equation (15.5) penalizes not
only for training errors but also for large norm.
It is often more convenient to consider Soft-SVM for learning a homogenous
halfspace, where the bias term b is set to be zero, which yields the following
optimization problem:


min Î»kwk2 + Lhinge
(w) ,
(15.6)
S
w

where
m

Lhinge
(w) =
S

1 X
max{0, 1 âˆ’ yhw, xi i}.
m i=1

208

Support Vector Machines

15.2.1

The Sample Complexity of Soft-SVM
We now analyze the sample complexity of Soft-SVM for the case of homogenous
halfspaces (namely, the output of Equation (15.6)). In Corollary 13.8 we derived
a generalization bound for the regularized loss minimization framework assuming
that the loss function is convex and Lipschitz. We have already shown that the
hinge loss is convex so it is only left to analyze the Lipschitzness of the hinge
loss.
claim 15.6

Let f (w) = max{0, 1 âˆ’ yhw, xi}. Then, f is kxk-Lipschitz.

Proof It is easy to verify that any subgradient of f at w is of the form Î±x where
|Î±| â‰¤ 1. The claim now follows from Lemma 14.7.
Corollary 13.8 therefore yields the following:
corollary 15.7 Let D be a distribution over X Ã— {0, 1}, where X = {x :
kxk â‰¤ Ï}. Consider running Soft-SVM (Equation (15.6)) on a training set S âˆ¼
Dm and let A(S) be the solution of Soft-SVM. Then, for every u,
(u) + Î»kuk2 +
(A(S))] â‰¤ Lhinge
E m [Lhinge
D
D

Sâˆ¼D

2Ï2
.
Î»m

Furthermore, since the hinge loss upper bounds the 0âˆ’1 loss we also have
hinge
E m [L0âˆ’1
(u) + Î»kuk2 +
D (A(S))] â‰¤ LD

Sâˆ¼D

Last, for every B > 0, if we set Î» =

q

2Ï2
B2 m

2Ï2
.
Î»m

then
r

E

Sâˆ¼D

[L0âˆ’1
D (A(S))]
m

â‰¤

E

Sâˆ¼D

[Lhinge
(A(S))]
D
m

â‰¤

min
w:kwkâ‰¤B

Lhinge
(w)
D

+

8Ï2 B 2
.
m

We therefore see that we can control the sample complexity of learning a halfspace as a function of the norm of that halfspace, independently of the Euclidean
dimension of the space over which the halfspace is defined. This becomes highly
significant when we learn via embeddings into high dimensional feature spaces,
as we will consider in the next chapter.
Remark 15.2 The condition that X will contain vectors with a bounded norm
follows from the requirement that the loss function will be Lipschitz. This is
not just a technicality. As we discussed before, separation with large margin
is meaningless without imposing a restriction on the scale of the instances. Indeed, without a constraint on the scale, we can always enlarge the margin by
multiplying all instances by a large scalar.

15.2.2

Margin and Norm-Based Bounds versus Dimension
The bounds we have derived for Hard-SVM and Soft-SVM do not depend on the
dimension of the instance space. Instead, the bounds depend on the norm of the

15.2 Soft-SVM and Norm Regularization

209

examples, Ï, the norm of the halfspace B (or equivalently the margin parameter
Î³) and, in the nonseparable case, the bounds also depend on the minimum hinge
loss of all halfspaces of norm â‰¤ B. In contrast, the VC-dimension of the class of
homogenous halfspaces
is d, which implies that the error of an ERM hypothesis
p
decreases as d/m does. We now give an example in which Ï2 B 2  d; hence
the bound given in Corollary 15.7 is much better than the VC bound.
Consider the problem of learning to classify a short text document according
to its topic, say, whether the document is about sports or not. We first need to
represent documents as vectors. One simple yet effective way is to use a bagof-words representation. That is, we define a dictionary of words and set the
dimension d to be the number of words in the dictionary. Given a document,
we represent it as a vector x âˆˆ {0, 1}d , where xi = 1 if the iâ€™th word in the
dictionary appears in the document and xi = 0 otherwise. Therefore, for this
problem, the value of Ï2 will be the maximal number of distinct words in a given
document.
A halfspace for this problem assigns weights to words. It is natural to assume
that by assigning positive and negative weights to a few dozen words we will
be able to determine whether a given document is about sports or not with
reasonable accuracy. Therefore, for this problem, the value of B 2 can be set to
be less than 100. Overall, it is reasonable to say that the value of B 2 Ï2 is smaller
than 10,000.
On the other hand, a typical size of a dictionary is much larger than 10,000.
For example, there are more than 100,000 distinct words in English. We have
therefore shown a problem in which there can be an order of magnitude difference
between learning a halfspace with the SVM rule and learning a halfspace using
the vanilla ERM rule.
Of course, it is possible to construct problems in which the SVM bound will
be worse than the VC bound. When we use SVM, we in fact introduce another
form of inductive bias â€“ we prefer large margin halfspaces. While this inductive bias can significantly decrease our estimation error, it can also enlarge the
approximation error.

15.2.3

The Ramp Loss*
The margin-based bounds we have derived in Corollary 15.7 rely on the fact that
we minimize
the hinge loss. As we have shown in the previous subsection, the
p
Ï2 B 2 /m can be much smaller than the corresponding term in the VC
term p
bound, d/m. However, the approximation error in Corollary 15.7 is measured
with respect to the hinge loss while the approximation error in VC bounds is
measured with respect to the 0âˆ’1 loss. Since the hinge loss upper bounds the
0âˆ’1 loss, the approximation error with respect to the 0âˆ’1 loss will never exceed
that of the hinge loss.
pIt is not possible to derive bounds that involve the estimation error term
Ï2 B 2 /m for the 0âˆ’1 loss. This follows from the fact that the 0âˆ’1 loss is scale

210

Support Vector Machines

insensitive, and therefore there is no meaning to the norm of w or its margin
when we measure error with the 0âˆ’1 loss. However, it is possible to define a loss
function
p that on one hand it is scale sensitive and thus enjoys the estimation
error Ï2 B 2 /m while on the other hand it is more similar to the 0âˆ’1 loss. One
option is the ramp loss, defined as
`ramp (w, (x, y)) = min{1, `hinge (w, (x, y))} = min{1 , max{0, 1 âˆ’ yhw, xi}}.
The ramp loss penalizes mistakes in the same way as the 0âˆ’1 loss and does not
penalize examples that are separated with margin. The difference between the
ramp loss and the 0âˆ’1 loss is only with respect to examples that are correctly
classified but not with a significant margin. Generalization bounds for the ramp
loss are given in the advanced part of this book (see Appendix 26.3).
`hinge

`0âˆ’1

`ramp
1

1

yhw, xi

The reason SVM relies on the hinge loss and not on the ramp loss is that
the hinge loss is convex and, therefore, from the computational point of view,
minimizing the hinge loss can be performed efficiently. In contrast, the problem
of minimizing the ramp loss is computationally intractable.

15.3

Optimality Conditions and â€œSupport Vectorsâ€*
The name â€œSupport Vector Machineâ€ stems from the fact that the solution of
hard-SVM, w0 , is supported by (i.e., is in the linear span of) the examples that
are exactly at distance 1/kw0 k from the separating hyperplane. These vectors are
therefore called support vectors. To see this, we rely on Fritz John optimality
conditions.
theorem 15.8 Let w0 be as defined in Equation (15.3) and let I = {i :
|hw0 , xi i| = 1}. Then, there exist coefficients Î±1 , . . . , Î±m such that
X
w0 =
Î±i xi .
iâˆˆI

The examples {xi : i âˆˆ I} are called support vectors.
The proof of this theorem follows by applying the following lemma to Equation (15.3).

15.4 Duality*

lemma 15.9 (Fritz John)

211

Suppose that

w? âˆˆ argmin f (w)

s.t. âˆ€i âˆˆ [m], gi (w) â‰¤ 0,

w

where f, g1 , . . . , gm are differentiable. Then, there exists Î± âˆˆ Rm such that
P
âˆ‡f (w? ) + iâˆˆI Î±i âˆ‡gi (w? ) = 0, where I = {i : gi (w? ) = 0}.

15.4

Duality*
Historically, many of the properties of SVM have been obtained by considering
the dual of Equation (15.3). Our presentation of SVM does not rely on duality.
For completeness, we present in the following how to derive the dual of Equation (15.3).
We start by rewriting the problem in an equivalent form as follows. Consider
the function
(
m
X
0
if âˆ€i, yi hw, xi i â‰¥ 1
g(w) =
max
Î±i (1 âˆ’ yi hw, xi i) =
.
m
Î±âˆˆR :Î±â‰¥0
âˆž otherwise
i=1
We can therefore rewrite Equation (15.3) as

min kwk2 + g(w) .
w

(15.7)

Rearranging the preceding we obtain that Equation (15.3) can be rewritten as
the problem
!
m
X
1
2
min max
kwk +
Î±i (1 âˆ’ yi hw, xi i) .
(15.8)
w Î±âˆˆRm :Î±â‰¥0
2
i=1
Now suppose that we flip the order of min and max in the above equation. This
can only decrease the objective value (see Exercise 4), and we have
!
m
X
1
2
kwk +
Î±i (1 âˆ’ yi hw, xi i)
min max
w Î±âˆˆRm :Î±â‰¥0
2
i=1
!
m
X
1
2
â‰¥ max
min
kwk +
Î±i (1 âˆ’ yi hw, xi i) .
Î±âˆˆRm :Î±â‰¥0 w
2
i=1
The preceding inequality is called weak duality. It turns out that in our case,
strong duality also holds; namely, the inequality holds with equality. Therefore,
the dual problem is
!
m
X
1
2
max min
kwk +
Î±i (1 âˆ’ yi hw, xi i) .
(15.9)
Î±âˆˆRm :Î±â‰¥0 w
2
i=1
We can simplify the dual problem by noting that once Î± is fixed, the optimization

212

Support Vector Machines

problem with respect to w is unconstrained and the objective is differentiable;
thus, at the optimum, the gradient equals zero:
wâˆ’

m
X

Î±i yi xi = 0

â‡’

w=

i=1

m
X

Î±i yi xi .

i=1

This shows us that the solution must be in the linear span of the examples, a
fact we will use later to derive SVM with kernels. Plugging the preceding into
Equation (15.9) we obtain that the dual problem can be rewritten as
ï£«
ï£« 
2
*
+ï£¶ï£¶
m
m
X

X
X
1


Î±i yi xi  +
Î±i ï£­1 âˆ’ yi
Î±j yj xj , xi ï£¸ï£¸ . (15.10)
max ï£­ 
Î±âˆˆRm :Î±â‰¥0

2
i=1

i=1

j

Rearranging yields the dual problem
ï£«
ï£¶
m
m X
m
X
X
1
Î±i âˆ’
Î±i Î±j yi yj hxj , xi iï£¸ .
max ï£­
Î±âˆˆRm :Î±â‰¥0
2
i=1 j=1
i=1

(15.11)

Note that the dual problem only involves inner products between instances and
does not require direct access to specific elements within an instance. This property is important when implementing SVM with kernels, as we will discuss in
the next chapter.

15.5

Implementing Soft-SVM Using SGD
In this section we describe a very simple algorithm for solving the optimization
problem of Soft-SVM, namely,
!
m
Î»
1 X
2
max{0, 1 âˆ’ yhw, xi i} .
(15.12)
min
kwk +
w
2
m i=1
We rely on the SGD framework for solving regularized loss minimization problems, as described in Section 14.5.3.
Recall that, on the basis of Equation (14.15), we can rewrite the update rule
of SGD as
t

w(t+1) = âˆ’

1 X
vj ,
Î» t j=1

where vj is a subgradient of the loss function at w(j) on the random example
chosen at iteration j. For the hinge loss, given an example (x, y), we can choose vj
to be 0 if yhw(j) , xi â‰¥ 1 and vj = âˆ’y x otherwise (see Example 14.2). Denoting
P
Î¸ (t) = âˆ’ j<t vj we obtain the following procedure.

15.6 Summary

213

SGD for Solving Soft-SVM
goal: Solve Equation (15.12)
parameter: T
initialize: Î¸ (1) = 0
for t = 1, . . . , T
Let w(t) = Î»1t Î¸ (t)
Choose i uniformly at random from [m]
If (yi hw(t) , xi i < 1)
Set Î¸ (t+1) = Î¸ (t) + yi xi
Else
Set Î¸ (t+1) = Î¸ (t)
PT
output: wÌ„ = T1 t=1 w(t)

15.6

Summary
SVM is an algorithm for learning halfspaces with a certain type of prior knowledge, namely, preference for large margin. Hard-SVM seeks the halfspace that
separates the data perfectly with the largest margin, whereas soft-SVM does
not assume separability of the data and allows the constraints to be violated to
some extent. The sample complexity for both types of SVM is different from the
sample complexity of straightforward halfspace learning, as it does not depend
on the dimension of the domain but rather on parameters such as the maximal
norms of x and w.
The importance of dimension-independent sample complexity will be realized
in the next chapter, where we will discuss the embedding of the given domain
into some high dimensional feature space as means for enriching our hypothesis
class. Such a procedure raises computational and sample complexity problems.
The latter is solved by using SVM, whereas the former can be solved by using
SVM with kernels, as we will see in the next chapter.

15.7

Bibliographic Remarks
SVMs have been introduced in (Cortes & Vapnik 1995, Boser, Guyon & Vapnik
1992). There are many good books on the theoretical and practical aspects of
SVMs. For example, (Vapnik 1995, Cristianini & Shawe-Taylor 2000, SchoÌˆlkopf
& Smola 2002, Hsu, Chang & Lin 2003, Steinwart & Christmann 2008). Using
SGD for solving soft-SVM has been proposed in Shalev-Shwartz et al. (2007).

214

Support Vector Machines

15.8

Exercises
1. Show that the hard-SVM rule, namely,
argmax

min |hw, xi i + b| s.t. âˆ€i, yi (hw, xi i + b) > 0,

(w,b):kwk=1 iâˆˆ[m]

is equivalent to the following formulation:
argmax

min yi (hw, xi i + b).

(15.13)

(w,b):kwk=1 iâˆˆ[m]

Hint: Define G = {(w, b) : âˆ€i, yi (hw, xi i + b) > 0}.
1. Show that
argmax

min yi (hw, xi i + b) âˆˆ G

(w,b):kwk=1 iâˆˆ[m]

2. Show that âˆ€(w, b) âˆˆ G,
min yi (hw, xi i + b) = min |hw, xi i + b|

iâˆˆ[m]

iâˆˆ[m]

2. Margin and the Perceptron Consider a training set that is linearly separable with a margin Î³ and such that all the instances are within a ball of
radius Ï. Prove that the maximal number of updates the Batch Perceptron
algorithm given in Section 9.1.2 will make when running on this training set
is (Ï/Î³)2 .
3. Hard versus soft SVM: Prove or refute the following claim:
There exists Î» > 0 such that for every sample S of m > 1 examples, which
is separable by the class of homogenous halfspaces, the hard-SVM and the
soft-SVM (with parameter Î») learning rules return exactly the same weight
vector.
4. Weak duality: Prove that for any function f of two vector variables x âˆˆ
X , y âˆˆ Y, it holds that
min max f (x, y) â‰¥ max min f (x, y).

xâˆˆX yâˆˆY

yâˆˆY xâˆˆX

16 Kernel Methods

In the previous chapter we described the SVM paradigm for learning halfspaces
in high dimensional feature spaces. This enables us to enrich the expressive
power of halfspaces by first mapping the data into a high dimensional feature
space, and then learning a linear predictor in that space. This is similar to the
AdaBoost algorithm, which learns a composition of a halfspace over base hypotheses. While this approach greatly extends the expressiveness of halfspace
predictors, it raises both sample complexity and computational complexity challenges. In the previous chapter we tackled the sample complexity issue using
the concept of margin. In this chapter we tackle the computational complexity
challenge using the method of kernels.
We start the chapter by describing the idea of embedding the data into a high
dimensional feature space. We then introduce the idea of kernels. A kernel is a
type of a similarity measure between instances. The special property of kernel
similarities is that they can be viewed as inner products in some Hilbert space
(or Euclidean space of some high dimension) to which the instance space is virtually embedded. We introduce the â€œkernel trickâ€ that enables computationally
efficient implementation of learning, without explicitly handling the high dimensional representation of the domain instances. Kernel based learning algorithms,
and in particular kernel-SVM, are very useful and popular machine learning
tools. Their success may be attributed both to being flexible for accommodating
domain specific prior knowledge and to having a well developed set of efficient
implementation algorithms.

16.1

Embeddings into Feature Spaces
The expressive power of halfspaces is rather restricted â€“ for example, the following training set is not separable by a halfspace.
Let the domain be the real line; consider the domain points {âˆ’10, âˆ’9, âˆ’8, . . . , 0,
1, . . . , 9, 10} where the labels are +1 for all x such that |x| > 2 and âˆ’1 otherwise.
To make the class of halfspaces more expressive, we can first map the original
instance space into another space (possibly of a higher dimension) and then
learn a halfspace in that space. For example, consider the example mentioned
previously. Instead of learning a halfspace in the original representation let us
c 2014 by Shai Shalev-Shwartz and Shai Ben-David
Understanding Machine Learning, 
Published 2014 by Cambridge University Press.
Personal use only. Not for distribution. Do not post.
Please link to http://www.cs.huji.ac.il/~shais/UnderstandingMachineLearning

216

Kernel Methods

first define a mapping Ïˆ : R â†’ R2 as follows:
Ïˆ(x) = (x, x2 ).
We use the term feature space to denote the range of Ïˆ. After applying Ïˆ the
data can be easily explained using the halfspace h(x) = sign(hw, Ïˆ(x)i âˆ’ b),
where w = (0, 1) and b = 5.
The basic paradigm is as follows:
1. Given some domain set X and a learning task, choose a mapping Ïˆ : X â†’ F,
for some feature space F, that will usually be Rn for some n (however, the
range of such a mapping can be any Hilbert space, including such spaces of
infinite dimension, as we will show later).
2. Given a sequence of labeled examples, S = (x1 , y1 ), . . . , (xm , ym ), create the
image sequence SÌ‚ = (Ïˆ(x1 ), y1 ), . . . , (Ïˆ(xm ), ym ).
3. Train a linear predictor h over SÌ‚.
4. Predict the label of a test point, x, to be h(Ïˆ(x)).
Note that, for every probability distribution D over X Ã— Y, we can readily
define its image probability distribution DÏˆ over F Ã— Y by setting, for every
subset A âŠ† F Ã— Y, DÏˆ (A) = D(Ïˆ âˆ’1 (A)).1 It follows that for every predictor h
over the feature space, LDÏˆ (h) = LD (h â—¦ Ïˆ), where h â—¦ Ïˆ is the composition of h
onto Ïˆ.
The success of this learning paradigm depends on choosing a good Ïˆ for a
given learning task: that is, a Ïˆ that will make the image of the data distribution
(close to being) linearly separable in the feature space, thus making the resulting
algorithm a good learner for a given task. Picking such an embedding requires
prior knowledge about that task. However, often some generic mappings that
enable us to enrich the class of halfspaces and extend its expressiveness are used.
One notable example is polynomial mappings, which are a generalization of the
Ïˆ we have seen in the previous example.
Recall that the prediction of a standard halfspace classifier on an instance x
is based on the linear mapping x 7â†’ hw, xi. We can generalize linear mappings
to a polynomial mapping, x 7â†’ p(x), where p is a multivariate polynomial of
degree k. For simplicity, consider first the case in which x is 1 dimensional.
Pk
In that case, p(x) = j=0 wj xj , where w âˆˆ Rk+1 is the vector of coefficients
of the polynomial we need to learn. We can rewrite p(x) = hw, Ïˆ(x)i where
Ïˆ : R â†’ Rk+1 is the mapping x 7â†’ (1, x, x2 , x3 , . . . , xk ). It follows that
learning a k degree polynomial over R can be done by learning a linear mapping
in the (k + 1) dimensional feature space.
More generally, a degree k multivariate polynomial from Rn to R can be written as
r
X
Y
p(x) =
wJ
xJ i .
(16.1)
Jâˆˆ[n]r :râ‰¤k
1

i=1

This is defined for every A such that Ïˆ âˆ’1 (A) is measurable with respect to D.

16.2 The Kernel Trick

217

As before, we can rewrite p(x) = hw, Ïˆ(x)i where now Ïˆ : Rn â†’ Rd is such
that for every J âˆˆ [n]r , r â‰¤ k, the coordinate of Ïˆ(x) associated with J is the
Qr
monomial i=1 xJi .
Naturally, polynomial-based classifiers yield much richer hypothesis classes
than halfspaces. We have seen at the beginning of this chapter an example in
which the training set, in its original domain (X = R), cannot be separable
by a halfspace, but after the embedding x 7â†’ (x, x2 ) it is perfectly separable.
So, while the classifier is always linear in the feature space, it can have highly
nonlinear behavior on the original space from which instances were sampled.
In general, we can choose any feature mapping Ïˆ that maps the original instances into some Hilbert space.2 The Euclidean space Rd is a Hilbert space for
any finite d. But there are also infinite dimensional Hilbert spaces (as we shall
see later on in this chapter).
The bottom line of this discussion is that we can enrich the class of halfspaces
by first applying a nonlinear mapping, Ïˆ, that maps the instance space into some
feature space, and then learning a halfspace in that feature space. However, if
the range of Ïˆ is a high dimensional space we face two problems. First, the VCdimension of halfspaces in Rn is n + 1, and therefore, if the range of Ïˆ is very
large, we need many more samples in order to learn a halfspace in the range
of Ïˆ. Second, from the computational point of view, performing calculations in
the high dimensional space might be too costly. In fact, even the representation
of the vector w in the feature space can be unrealistic. The first issue can be
tackled using the paradigm of large margin (or low norm predictors), as we
already discussed in the previous chapter in the context of the SVM algorithm.
In the following section we address the computational issue.

16.2

The Kernel Trick
We have seen that embedding the input space into some high dimensional feature
space makes halfspace learning more expressive. However, the computational
complexity of such learning may still pose a serious hurdle â€“ computing linear
separators over very high dimensional data may be computationally expensive.
The common solution to this concern is kernel based learning. The term â€œkernelsâ€
is used in this context to describe inner products in the feature space. Given
an embedding Ïˆ of some domain space X into some Hilbert space, we define
the kernel function K(x, x0 ) = hÏˆ(x), Ïˆ(x0 )i. One can think of K as specifying
similarity between instances and of the embedding Ïˆ as mapping the domain set
2

A Hilbert space is a vector space with an inner product, which is also complete. A space is
complete if all Cauchy sequences in the space converge. p
In our case, the norm kwk is defined by the inner product hw, wi. The reason we require
the range of Ïˆ to be in a Hilbert space is that projections in a Hilbert space are well
defined. In particular, if M is a linear subspace of a Hilbert space, then every x in the
Hilbert space can be written as a sum x = u + v where u âˆˆ M and hv, wi = 0 for all
w âˆˆ M . We use this fact in the proof of the representer theorem given in the next section.

218

Kernel Methods

X into a space where these similarities are realized as inner products. It turns
out that many learning algorithms for halfspaces can be carried out just on the
basis of the values of the kernel function over pairs of domain points. The main
advantage of such algorithms is that they implement linear separators in high
dimensional feature spaces without having to specify points in that space or
expressing the embedding Ïˆ explicitly. The remainder of this section is devoted
to constructing such algorithms.
In the previous chapter we saw that regularizing the norm of w yields a small
sample complexity even if the dimensionality of the feature space is high. Interestingly, as we show later, regularizing the norm of w is also helpful in overcoming
the computational problem. To do so, first note that all versions of the SVM optimization problem we have derived in the previous chapter are instances of the
following general problem:
min (f (hw, Ïˆ(x1 )i , . . . , hw, Ïˆ(xm )i) + R(kwk)),
w

(16.2)

where f : Rm â†’ R is an arbitrary function and R : R+ â†’ R is a monotonically nondecreasing function. For example, Soft-SVM for homogenous halfspaces
(Equation (15.6)) can be derived from Equation (16.2) by letting R(a) = Î»a2 and
P
1
f (a1 , . . . , am ) = m
i max{0, 1âˆ’yi ai }. Similarly, Hard-SVM for nonhomogenous
halfspaces (Equation (15.2)) can be derived from Equation (16.2) by letting
R(a) = a2 and letting f (a1 , . . . , am ) be 0 if there exists b such that yi (ai +b) â‰¥ 1
for all i, and f (a1 , . . . , am ) = âˆž otherwise.
The following theorem shows that there exists an optimal solution of Equation (16.2) that lies in the span of {Ïˆ(x1 ), . . . , Ïˆ(xm )}.
theorem 16.1 (Representer Theorem) Assume that Ïˆ is a mapping from X to
Pm
a Hilbert space. Then, there exists a vector Î± âˆˆ Rm such that w = i=1 Î±i Ïˆ(xi )
is an optimal solution of Equation (16.2).
Proof Let w? be an optimal solution of Equation (16.2). Because w? is an
element of a Hilbert space, we can rewrite w? as
w? =

m
X

Î±i Ïˆ(xi ) + u,

i=1

where hu, Ïˆ(xi )i = 0 for all i. Set w = w? âˆ’ u. Clearly, kw? k2 = kwk2 + kuk2 ,
thus kwk â‰¤ kw? k. Since R is nondecreasing we obtain that R(kwk) â‰¤ R(kw? k).
Additionally, for all i we have that
hw, Ïˆ(xi )i = hw? âˆ’ u, Ïˆ(xi )i = hw? , Ïˆ(xi )i,
hence
f (hw, Ïˆ(x1 )i , . . . , hw, Ïˆ(xm )i) = f (hw? , Ïˆ(x1 )i , . . . , hw? , Ïˆ(xm )i) .
We have shown that the objective of Equation (16.2) at w cannot be larger
than the objective at w? and therefore w is also an optimal solution. Since
Pm
w = i=1 Î±i Ïˆ(xi ) we conclude our proof.

16.2 The Kernel Trick

219

On the basis of the representer theorem we can optimize Equation (16.2) with
respect to the coefficients Î± instead of the coefficients w as follows. Writing
Pm
w = j=1 Î±j Ïˆ(xj ) we have that for all i
*
+
m
X
X
hw, Ïˆ(xi )i =
Î±j Ïˆ(xj ), Ïˆ(xi ) =
Î±j hÏˆ(xj ), Ïˆ(xi )i.
j

j=1

Similarly,
2

kwk =

*
X

+
Î±j Ïˆ(xj ),

X

j

j

Î±j Ïˆ(xj )

=

m
X

Î±i Î±j hÏˆ(xi ), Ïˆ(xj )i.

i,j=1

Let K(x, x0 ) = hÏˆ(x), Ïˆ(x0 )i be a function that implements the kernel function
with respect to the embedding Ïˆ. Instead of solving Equation (16.2) we can solve
the equivalent problem
ï£¶
ï£«
m
m
X
X
Î±j K(xj , xm )ï£¸
Î±j K(xj , x1 ), . . . ,
min f ï£­
Î±âˆˆRm

j=1

j=1

ï£¶
ï£«v
uX
u m
Î±i Î±j K(xj , xi )ï£¸.
+ R ï£­t

(16.3)

i,j=1

To solve the optimization problem given in Equation (16.3), we do not need any
direct access to elements in the feature space. The only thing we should know is
how to calculate inner products in the feature space, or equivalently, to calculate
the kernel function. In fact, to solve Equation (16.3) we solely need to know the
value of the m Ã— m matrix G s.t. Gi,j = K(xi , xj ), which is often called the
Gram matrix.
In particular, specifying the preceding to the Soft-SVM problem given in Equation (15.6), we can rewrite the problem as
!
m

	
1 X
T
min Î»Î± GÎ± +
max 0, 1 âˆ’ yi (GÎ±)i
,
(16.4)
Î±âˆˆRm
m i=1
where (GÎ±)i is the iâ€™th element of the vector obtained by multiplying the Gram
matrix G by the vector Î±. Note that Equation (16.4) can be written as quadratic
programming and hence can be solved efficiently. In the next section we describe
an even simpler algorithm for solving Soft-SVM with kernels.
Once we learn the coefficients Î± we can calculate the prediction on a new
instance by
hw, Ïˆ(x)i =

m
X
j=1

Î±j hÏˆ(xj ), Ïˆ(x)i =

m
X

Î±j K(xj , x).

j=1

The advantage of working with kernels rather than directly optimizing w in
the feature space is that in some situations the dimension of the feature space

220

Kernel Methods

is extremely large while implementing the kernel function is very simple. A few
examples are given in the following.
Example 16.1 (Polynomial Kernels) The k degree polynomial kernel is defined
to be
K(x, x0 ) = (1 + hx, x0 i)k .
Now we will show that this is indeed a kernel function. That is, we will show
that there exists a mapping Ïˆ from the original space to some higher dimensional
space for which K(x, x0 ) = hÏˆ(x), Ïˆ(x0 )i. For simplicity, denote x0 = x00 = 1.
Then, we have
K(x, x0 ) = (1 + hx, x0 i)k = (1 + hx, x0 i) Â· Â· Â· Â· Â· (1 + hx, x0 i)
ï£«
ï£¶
ï£«
ï£¶
n
n
X
X
=ï£­
xj x0j ï£¸ Â· Â· Â· Â· Â· ï£­
xj x0j ï£¸
j=0

=

=

j=0

X

k
Y

Jâˆˆ{0,1,...,n}k

i=1

X

k
Y

xJi x0Ji

xJ i

k
Y

x0Ji .

i=1

Jâˆˆ{0,1,...,n}k i=1
k

Now, if we define Ïˆ : Rn â†’ R(n+1) such that for J âˆˆ {0, 1, . . . , n}k there is an
Qk
element of Ïˆ(x) that equals i=1 xJi , we obtain that
K(x, x0 ) = hÏˆ(x), Ïˆ(x0 )i.
Since Ïˆ contains all the monomials up to degree k, a halfspace over the range
of Ïˆ corresponds to a polynomial predictor of degree k over the original space.
Hence, learning a halfspace with a k degree polynomial kernel enables us to learn
polynomial predictors of degree k over the original space.
Note that here the complexity of implementing K is O(n) while the dimension
of the feature space is on the order of nk .
Example 16.2 (Gaussian Kernel) Let the original instance space be R and
consider the mapping Ïˆ where for each nonnegative integer n â‰¥ 0 there exists
x2

an element Ïˆ(x)n that equals âˆš1 eâˆ’ 2 xn . Then,
n!



âˆž
0 2
X
1 âˆ’ x2 n
1 âˆ’ (x )
0
0
n
âˆš e 2 x
âˆš e 2 (x )
hÏˆ(x), Ïˆ(x )i =
n!
n!
n=0

2
0 2 âˆž 
x +(x ) X
(xx0 )n
2
= eâˆ’
n!
n=0
= eâˆ’

kxâˆ’x0 k2
2

.

Here the feature space is of infinite dimension while evaluating the kernel is very

16.2 The Kernel Trick

221

simple. More generally, given a scalar Ïƒ > 0, the Gaussian kernel is defined to
be
K(x, x0 ) = eâˆ’

kxâˆ’x0 k2
2Ïƒ

.

Intuitively, the Gaussian kernel sets the inner product in the feature space
between x, x0 to be close to zero if the instances are far away from each other
(in the original domain) and close to 1 if they are close. Ïƒ is a parameter that
controls the scale determining what we mean by â€œclose.â€ It is easy to verify that
K implements an inner product in a space in which for any n and any monomial
kxk2 Q
n
of order k there exists an element of Ïˆ(x) that equals âˆš1 eâˆ’ 2
i=1 xJi .
n!
Hence, we can learn any polynomial predictor over the original space by using a
Gaussian kernel.
Recall that the VC-dimension of the class of all polynomial predictors is infinite (see Exercise 12). There is no contradiction, because the sample complexity
required to learn with Gaussian kernels depends on the margin in the feature
space, which will be large if we are lucky, but can in general be arbitrarily small.
The Gaussian kernel is also called the RBF kernel, for â€œRadial Basis Functions.â€

16.2.1

Kernels as a Way to Express Prior Knowledge
As we discussed previously, a feature mapping, Ïˆ, may be viewed as expanding
the class of linear classifiers to a richer class (corresponding to linear classifiers
over the feature space). However, as discussed in the book so far, the suitability
of any hypothesis class to a given learning task depends on the nature of that
task. One can therefore think of an embedding Ïˆ as a way to express and utilize
prior knowledge about the problem at hand. For example, if we believe that
positive examples can be distinguished by some ellipse, we can define Ïˆ to be all
the monomials up to order 2, or use a degree 2 polynomial kernel.
As a more realistic example, consider the task of learning to find a sequence of
characters (â€œsignatureâ€) in a file that indicates whether it contains a virus or not.
Formally, let Xd be the set of all strings of length at most d over some alphabet
set Î£. The hypothesis class that one wishes to learn is H = {hv : v âˆˆ Xd }, where,
for a string x âˆˆ Xd , hv (x) is 1 iff v is a substring of x (and hv (x) = âˆ’1 otherwise).
Let us show how using an appropriate embedding this class can be realized by
linear classifiers over the resulting feature space. Consider a mapping Ïˆ to a space
Rs where s = |Xd |, so that each coordinate of Ïˆ(x) corresponds to some string v
and indicates whether v is a substring of x (that is, for every x âˆˆ Xd , Ïˆ(x) is a
vector in {0, 1}|Xd | ). Note that the dimension of this feature space is exponential
in d. It is not hard to see that every member of the class H can be realized by
composing a linear classifier over Ïˆ(x), and, moreover, by such a halfspace whose
norm is 1 and that attains a margin of 1 (see Exercise 1). Furthermore, for every
x âˆˆ X , kÏˆ(x)k = O(d). So, overall, it is learnable using SVM with a sample

222

Kernel Methods

complexity that is polynomial in d. However, the dimension of the feature space
is exponential in d so a direct implementation of SVM over the feature space is
problematic. Luckily, it is easy to calculate the inner product in the feature space
(i.e., the kernel function) without explicitly mapping instances into the feature
space. Indeed, K(x, x0 ) is simply the number of common substrings of x and x0 ,
which can be easily calculated in time polynomial in d.
This example also demonstrates how feature mapping enables us to use halfspaces
for nonvectorial domains.

16.2.2

Characterizing Kernel Functions*
As we have discussed in the previous section, we can think of the specification of
the kernel matrix as a way to express prior knowledge. Consider a given similarity
function of the form K : X Ã— X â†’ R. Is it a valid kernel function? That is, does
it represent an inner product between Ïˆ(x) and Ïˆ(x0 ) for some feature mapping
Ïˆ? The following lemma gives a sufficient and necessary condition.
lemma 16.2 A symmetric function K : X Ã— X â†’ R implements an inner
product in some Hilbert space if and only if it is positive semidefinite; namely,
for all x1 , . . . , xm , the Gram matrix, Gi,j = K(xi , xj ), is a positive semidefinite
matrix.
Proof It is trivial to see that if K implements an inner product in some Hilbert
space then the Gram matrix is positive semidefinite. For the other direction,
define the space of functions over X as RX = {f : X â†’ R}. For each x âˆˆ X
let Ïˆ(x) be the function x 7â†’ K(Â·, x). Define a vector space by taking all linear
combinations of elements of the form K(Â·, x). Define an inner product on this
vector space to be
*
+
X
X
X
Î±i K(Â·, xi ),
Î²j K(Â·, x0j ) =
Î±i Î²j K(xi , x0j ).
i

j

i,j

This is a valid inner product since it is symmetric (because K is symmetric), it is
linear (immediate), and it is positive definite (it is easy to see that K(x, x) â‰¥ 0
with equality only for Ïˆ(x) being the zero function). Clearly,
hÏˆ(x), Ïˆ(x0 )i = hK(Â·, x), K(Â·, x0 )i = K(x, x0 ),
which concludes our proof.

16.3

Implementing Soft-SVM with Kernels
Next, we turn to solving Soft-SVM with kernels. While we could have designed
an algorithm for solving Equation (16.4), there is an even simpler approach that

16.3 Implementing Soft-SVM with Kernels

223

directly tackles the Soft-SVM optimization problem in the feature space,
!
m
Î»
1 X
2
min
kwk +
max{0, 1 âˆ’ yhw, Ïˆ(xi )i} ,
(16.5)
w
2
m i=1
while only using kernel evaluations. The basic observation is that the vector w(t)
maintained by the SGD procedure we have described in Section 15.5 is always in
the linear span of {Ïˆ(x1 ), . . . , Ïˆ(xm )}. Therefore, rather than maintaining w(t)
we can maintain the corresponding coefficients Î±.
Formally, let K be the kernel function, namely, for all x, x0 , K(x, x0 ) =
hÏˆ(x), Ïˆ(x0 )i. We shall maintain two vectors in Rm , corresponding to two vectors
Î¸ (t) and w(t) defined in the SGD procedure of Section 15.5. That is, Î² (t) will be
a vector such that
m
X
(t)
Î¸ (t) =
Î²j Ïˆ(xj )
(16.6)
j=1

and Î±(t) be such that
w

(t)

=

m
X

(t)

Î±j Ïˆ(xj ).

(16.7)

j=1

The vectors Î² and Î± are updated according to the following procedure.
SGD for Solving Soft-SVM with Kernels
Goal: Solve Equation (16.5)
parameter: T
Initialize: Î² (1) = 0
for t = 1, . . . , T
Let Î±(t) = Î»1t Î² (t)
Choose i uniformly at random from [m]
(t+1)
(t)
For all j 6= i set Î²j
= Î²j
Pm
(t)
If (yi j=1 Î±j K(xj , xi ) < 1)
(t+1)
(t)
Set Î²i
= Î²i + yi
Else
(t+1)
(t)
Set Î²i
= Î²i
PT
Pm
Output: wÌ„ = j=1 Î±Ì„j Ïˆ(xj ) where Î±Ì„ = T1 t=1 Î±(t)
The following lemma shows that the preceding implementation is equivalent
to running the SGD procedure described in Section 15.5 on the feature space.
lemma 16.3 Let wÌ‚ be the output of the SGD procedure described in SecPm
tion 15.5, when applied on the feature space, and let wÌ„ =
j=1 Î±Ì„j Ïˆ(xj ) be
the output of applying SGD with kernels. Then wÌ„ = wÌ‚.
Proof We will show that for every t Equation (16.6) holds, where Î¸ (t) is the
result of running the SGD procedure described in Section 15.5 in the feature

224

Kernel Methods

space. By the definition of Î±(t) = Î»1t Î² (t) and w(t) = Î»1t Î¸ (t) , this claim implies
that Equation (16.7) also holds, and the proof of our lemma will follow. To prove
that Equation (16.6) holds we use a simple inductive argument. For t = 1 the
claim trivially holds. Assume it holds for t â‰¥ 1. Then,
D
E
yi w(t) , Ïˆ(xi ) = yi

*
X

+
(t)
Î±j Ïˆ(xj ), Ïˆ(xi )

j

= yi

m
X

(t)

Î±j K(xj , xi ).

j=1

Hence, the condition in the two algorithms is equivalent and if we update Î¸ we
have
Î¸ (t+1) = Î¸ (t) + yi Ïˆ(xi ) =

m
X
j=1

(t)

Î²j Ïˆ(xj ) + yi Ïˆ(xi ) =

m
X

(t+1)

Î²j

Ïˆ(xj ),

j=1

which concludes our proof.

16.4

Summary
Mappings from the given domain to some higher dimensional space, on which a
halfspace predictor is used, can be highly powerful. We benefit from a rich and
complex hypothesis class, yet need to solve the problems of high sample and
computational complexities. In Chapter 10, we discussed the AdaBoost algorithm, which faces these challenges by using a weak learner: Even though weâ€™re
in a very high dimensional space, we have an â€œoracleâ€ that bestows on us a
single good coordinate to work with on each iteration. In this chapter we introduced a different approach, the kernel trick. The idea is that in order to find a
halfspace predictor in the high dimensional space, we do not need to know the
representation of instances in that space, but rather the values of inner products
between the mapped instances. Calculating inner products between instances in
the high dimensional space without using their representation in that space is
done using kernel functions. We have also shown how the SGD algorithm can be
implemented using kernels.
The ideas of feature mapping and the kernel trick allow us to use the framework
of halfspaces and linear predictors for nonvectorial data. We demonstrated how
kernels can be used to learn predictors over the domain of strings.
We presented the applicability of the kernel trick in SVM. However, the kernel
trick can be applied in many other algorithms. A few examples are given as
exercises.
This chapter ends the series of chapters on linear predictors and convex problems. The next two chapters deal with completely different types of hypothesis
classes.

16.5 Bibliographic Remarks

16.5

225

Bibliographic Remarks
In the context of SVM, the kernel-trick has been introduced in Boser et al. (1992).
See also Aizerman, Braverman & Rozonoer (1964). The observation that the
kernel-trick can be applied whenever an algorithm only relies on inner products
was first stated by SchoÌˆlkopf, Smola & MuÌˆller (1998). The proof of the representer
theorem is given in (SchoÌˆlkopf, Herbrich, Smola & Williamson 2000, SchoÌˆlkopf,
Herbrich & Smola 2001). The conditions stated in Lemma 16.2 are simplification
of conditions due to Mercer. Many useful kernel functions have been introduced
in the literature for various applications. We refer the reader to SchoÌˆlkopf &
Smola (2002).

16.6

Exercises
1. Consider the task of finding a sequence of characters in a file, as described
in Section 16.2.1. Show that every member of the class H can be realized by
composing a linear classifier over Ïˆ(x), whose norm is 1 and that attains a
margin of 1.
2. Kernelized Perceptron: Show how to run the Perceptron algorithm while
only accessing the instances via the kernel function. Hint: The derivation is
similar to the derivation of implementing SGD with kernels.
3. Kernel Ridge Regression: The ridge regression problem, with a feature
mapping Ïˆ, is the problem of finding a vector w that minimizes the function
m

f (w) = Î» kwk2 +

1 X
(hw, Ïˆ(xi )i âˆ’ yi )2 ,
2m i=1

(16.8)

and then returning the predictor
h(x) = hw, xi.
Show how to implement the ridge regression algorithm with kernels.
Hint: The representer theorem tells us that there exists a vector Î± âˆˆ Rm
Pm
such that i=1 Î±i Ïˆ(xi ) is a minimizer of Equation (16.8).
1. Let G be the Gram matrix with regard to S and K. That is, Gij =
K(xi , xj ). Define g : Rm â†’ R by
m

1 X
g(Î±) = Î» Â· Î± GÎ± +
(hÎ±, GÂ·,i i âˆ’ yi )2 ,
2m i=1
T

(16.9)

where GÂ·,i is the iâ€™th column of G. Show that if Î±âˆ— minimizes EquaPm
tion (16.9) then wâˆ— = i=1 Î±iâˆ— Ïˆ(xi ) is a minimizer of f .
2. Find a closed form expression for Î±âˆ— .
4. Let N be any positive integer. For every x, x0 âˆˆ {1, . . . , N } define
K(x, x0 ) = min{x, x0 }.

226

Kernel Methods

Prove that K is a valid kernel; namely, find a mapping Ïˆ : {1, . . . , N } â†’ H
where H is some Hilbert space, such that
âˆ€x, x0 âˆˆ {1, . . . , N }, K(x, x0 ) = hÏˆ(x), Ïˆ(x0 )i.
5. A supermarket manager would like to learn which of his customers have babies
on the basis of their shopping carts. Specifically, he sampled i.i.d. customers,
where for customer i, let xi âŠ‚ {1, . . . , d} denote the subset of items the
customer bought, and let yi âˆˆ {Â±1} be the label indicating whether this
customer has a baby. As prior knowledge, the manager knows that there are
k items such that the label is determined to be 1 iff the customer bought
at least one of these k items. Of course, the identity of these k items is not
known (otherwise, there was nothing to learn). In addition, according to the
store regulation, each customer can buy at most s items. Help the manager to
design a learning algorithm such that both its time complexity and its sample
complexity are polynomial in s, k, and 1/.
6. Let X be an instance set and let Ïˆ be a feature mapping of X into some
Hilbert feature space V . Let K : X Ã— X â†’ R be a kernel function that
implements inner products in the feature space V .
Consider the binary classification algorithm that predicts the label of
an unseen instance according to the class with the closest average. Formally,
given a training sequence S = (x1 , y1 ), . . . , (xm , ym ), for every y âˆˆ {Â±1} we
define
1 X
Ïˆ(xi ).
cy =
my i:y =y
i

where my = |{i : yi = y}|. We assume that m+ and mâˆ’ are nonzero. Then,
the algorithm outputs the following decision rule:
(
1 kÏˆ(x) âˆ’ c+ k â‰¤ kÏˆ(x) âˆ’ câˆ’ k
h(x) =
0 otherwise.
1. Let w = c+ âˆ’ câˆ’ and let b = 21 (kcâˆ’ k2 âˆ’ kc+ k2 ). Show that
h(x) = sign(hw, Ïˆ(x)i + b).
2. Show how to express h(x) on the basis of the kernel function, and without
accessing individual entries of Ïˆ(x) or w.

17 Multiclass, Ranking, and Complex
Prediction Problems

Multiclass categorization is the problem of classifying instances into one of several
possible target classes. That is, we are aiming at learning a predictor h : X â†’ Y,
where Y is a finite set of categories. Applications include, for example, categorizing documents according to topic (X is the set of documents and Y is the set
of possible topics) or determining which object appears in a given image (X is
the set of images and Y is the set of possible objects).
The centrality of the multiclass learning problem has spurred the development
of various approaches for tackling the task. Perhaps the most straightforward
approach is a reduction from multiclass classification to binary classification. In
Section 17.1 we discuss the most common two reductions as well as the main
drawback of the reduction approach.
We then turn to describe a family of linear predictors for multiclass problems.
Relying on the RLM and SGD frameworks from previous chapters, we describe
several practical algorithms for multiclass prediction.
In Section 17.3 we show how to use the multiclass machinery for complex prediction problems in which Y can be extremely large but has some structure on
it. This task is often called structured output learning. In particular, we demonstrate this approach for the task of recognizing handwritten words, in which Y
is the set of all possible strings of some bounded length (hence, the size of Y is
exponential in the maximal length of a word).
Finally, in Section 17.4 and Section 17.5 we discuss ranking problems in which
the learner should order a set of instances according to their â€œrelevance.â€ A typical application is ordering results of a search engine according to their relevance
to the query. We describe several performance measures that are adequate for
assessing the performance of ranking predictors and describe how to learn linear
predictors for ranking problems efficiently.

17.1

One-versus-All and All-Pairs
The simplest approach to tackle multiclass prediction problems is by reduction
to binary classification. Recall that in multiclass prediction we would like to learn
a function h : X â†’ Y. Without loss of generality let us denote Y = {1, . . . , k}.
In the One-versus-All method (a.k.a. One-versus-Rest) we train k binary clasc 2014 by Shai Shalev-Shwartz and Shai Ben-David
Understanding Machine Learning, 
Published 2014 by Cambridge University Press.
Personal use only. Not for distribution. Do not post.
Please link to http://www.cs.huji.ac.il/~shais/UnderstandingMachineLearning

228

Multiclass, Ranking, and Complex Prediction Problems

sifiers, each of which discriminates between one class and the rest of the classes.
That is, given a training set S = (x1 , y1 ), . . . , (xm , ym ), where every yi is in Y, we
construct k binary training sets, S1 , . . . , Sk , where Si = (x1 , (âˆ’1)1[y1 6=i] ), . . . , (xm , (âˆ’1)1[ym 6=i] ).
In words, Si is the set of instances labeled 1 if their label in S was i, and âˆ’1
otherwise. For every i âˆˆ [k] we train a binary predictor hi : X â†’ {Â±1} based on
Si , hoping that hi (x) should equal 1 if and only if x belongs to class i. Then,
given h1 , . . . , hk , we construct a multiclass predictor using the rule
h(x) âˆˆ argmax hi (x).

(17.1)

iâˆˆ[k]

When more than one binary hypothesis predicts â€œ1â€ we should somehow decide
which class to predict (e.g., we can arbitrarily decide to break ties by taking the
minimal index in argmaxi hi (x)). A better approach can be applied whenever
each hi hides additional information, which can be interpreted as the confidence
in the prediction y = i. For example, this is the case in halfspaces, where the
actual prediction is sign(hw, xi), but we can interpret hw, xi as the confidence
in the prediction. In such cases, we can apply the multiclass rule given in Equation (17.1) on the real valued predictions. A pseudocode of the One-versus-All
approach is given in the following.

One-versus-All
input:
training set S = (x1 , y1 ), . . . , (xm , ym )
algorithm for binary classification A
foreach i âˆˆ Y
let Si = (x1 , (âˆ’1)1[y1 6=i] ), . . . , (xm , (âˆ’1)1[ym 6=i] )
let hi = A(Si )
output:
the multiclass hypothesis defined by h(x) âˆˆ argmaxiâˆˆY hi (x)

Another popular reduction is the All-Pairs approach, in which all pairs of
classes are compared to each other. Formally, given a training set S = (x1 , y1 ), . . . , (xm , ym ),
where every yi is in [k], for every 1 â‰¤ i < j â‰¤ k we construct a binary training
sequence, Si,j , containing all examples from S whose label is either i or j. For
each such an example, we set the binary label in Si,j to be +1 if the multiclass
label in S is i and âˆ’1 if the multiclass label in S is j. Next, we train a binary
classification algorithm based on every Si,j to get hi,j . Finally, we construct
a multiclass classifier by predicting the class that had the highest number of
â€œwins.â€ A pseudocode of the All-Pairs approach is given in the following.

17.1 One-versus-All and All-Pairs

229

All-Pairs
input:
training set S = (x1 , y1 ), . . . , (xm , ym )
algorithm for binary classification A
foreach i, j âˆˆ Y s.t. i < j
initialize Si,j to be the empty sequence
for t = 1, . . . , m
If yt = i add (xt , 1) to Si,j
If yt = j add (xt , âˆ’1) to Si,j
let hi,j = A(Si,j )
output:
the multiclass hypothesis
defined by
P

sign(j
âˆ’
i)
h
(x)
h(x) âˆˆ argmaxiâˆˆY
i,j
jâˆˆY
Although reduction methods such as the One-versus-All and All-Pairs are
simple and easy to construct from existing algorithms, their simplicity has a
price. The binary learner is not aware of the fact that we are going to use its
output hypotheses for constructing a multiclass predictor, and this might lead
to suboptimal results, as illustrated in the following example.
Example 17.1 Consider a multiclass categorization problem in which the instance space is X = R2 and the label set is Y = {1, 2, 3}. Suppose that instances
of the different classes are located in nonintersecting balls as depicted in the following.

1

2

3

Suppose that the probability masses of classes 1, 2, 3 are 40%, 20%, and 40%,
respectively. Consider the application of One-versus-All to this problem, and assume that the binary classification algorithm used by One-versus-All is ERM
with respect to the hypothesis class of halfspaces. Observe that for the problem of discriminating between class 2 and the rest of the classes, the optimal
halfspace would be the all negative classifier. Therefore, the multiclass predictor constructed by One-versus-All might err on all the examples from class 2
(this will be the case if the tie in the definition of h(x) is broken by the numerical value of the class
 label). In contrast, if we choose hi (x) = hwi , xi,
where w1 =

âˆ’ âˆš12 , âˆš12 , w2 = (0, 1), and w3 =

âˆš1 , âˆš1
2
2

, then the classi-

fier defined by h(x) = argmaxi hi (x) perfectly predicts all the examples. We see

230

Multiclass, Ranking, and Complex Prediction Problems

that even though the approximation error of the class of predictors of the form
h(x) = argmaxi hwi , xi is zero, the One-versus-All approach might fail to find a
good predictor from this class.

17.2

Linear Multiclass Predictors
In light of the inadequacy of reduction methods, in this section we study a more
direct approach for learning multiclass predictors. We describe the family of
linear multiclass predictors. To motivate the construction of this family, recall
that a linear predictor for binary classification (i.e., a halfspace) takes the form
h(x) = sign(hw, xi).
An equivalent way to express the prediction is as follows:
h(x) = argmax hw, yxi,
yâˆˆ{Â±1}

where yx is the vector obtained by multiplying each element of x by y.
This representation leads to a natural generalization of halfspaces to multiclass
problems as follows. Let Î¨ : X Ã— Y â†’ Rd be a class-sensitive feature mapping.
That is, Î¨ takes as input a pair (x, y) and maps it into a d dimensional feature
vector. Intuitively, we can think of the elements of Î¨(x, y) as score functions that
assess how well the label y fits the instance x. We will elaborate on Î¨ later on.
Given Î¨ and a vector w âˆˆ Rd , we can define a multiclass predictor, h : X â†’ Y,
as follows:
h(x) = argmax hw, Î¨(x, y)i.
yâˆˆY

That is, the prediction of h for the input x is the label that achieves the highest
weighted score, where weighting is according to the vector w.
Let W be some set of vectors in Rd , for example, W = {w âˆˆ Rd : kwk â‰¤ B},
for some scalar B > 0. Each pair (Î¨, W ) defines a hypothesis class of multiclass
predictors:
HÎ¨,W = {x 7â†’ argmax hw, Î¨(x, y)i : w âˆˆ W }.
yâˆˆY

Of course, the immediate question, which we discuss in the sequel, is how to
construct a good Î¨. Note that if Y = {Â±1} and we set Î¨(x, y) = yx and
W = Rd , then HÎ¨,W becomes the hypothesis class of homogeneous halfspace
predictors for binary classification.

17.2.1

How to Construct Î¨
As mentioned before, we can think of the elements of Î¨(x, y) as score functions
that assess how well the label y fits the instance x. Naturally, designing a good Î¨
is similar to the problem of designing a good feature mapping (as we discussed in

17.2 Linear Multiclass Predictors

231

Chapter 16 and as we will discuss in more detail in Chapter 25). Two examples
of useful constructions are given in the following.

The Multivector Construction:
Let Y = {1, . . . , k} and let X = Rn . We define Î¨ : X Ã— Y â†’ Rd , where d = nk,
as follows
Î¨(x, y) = [ 0, . . . , 0 , x1 , . . . , xn , 0, . . . , 0 ].
| {z } | {z } | {z }
âˆˆR(yâˆ’1)n

âˆˆRn

(17.2)

âˆˆR(kâˆ’y)n

That is, Î¨(x, y) is composed of k vectors, each of which is of dimension n, where
we set all the vectors to be the all zeros vector except the yâ€™th vector, which is
set to be x. It follows that we can think of w âˆˆ Rnk as being composed of k
weight vectors in Rn , that is, w = [w1 ; . . . ; wk ], hence the name multivector construction. By the construction we have that hw, Î¨(x, y)i = hwy , xi, and
therefore the multiclass prediction becomes
h(x) = argmax hwy , xi.
yâˆˆY

A geometric illustration of the multiclass prediction over X = R2 is given in the
following.
w2
w1

w3

w4

TF-IDF:
The previous definition of Î¨(x, y) does not incorporate any prior knowledge
about the problem. We next describe an example of a feature function Î¨ that
does incorporate prior knowledge. Let X be a set of text documents and Y be a
set of possible topics. Let d be a size of a dictionary of words. For each word in the
dictionary, whose corresponding index is j, let T F (j, x) be the number of times
the word corresponding to j appears in the document x. This quantity is called
Term-Frequency. Additionally, let DF (j, y) be the number of times the word
corresponding to j appears in documents in our training set that are not about
topic y. This quantity is called Document-Frequency and measures whether word
j is frequent in other topics. Now, define Î¨ : X Ã— Y â†’ Rd to be such that


Î¨j (x, y) = T F (j, x) log DFm
(j,y) ,
where m is the total number of documents in our training set. The preceding quantity is called term-frequency-inverse-document-frequency or TF-IDF for

232

Multiclass, Ranking, and Complex Prediction Problems

short. Intuitively, Î¨j (x, y) should be large if the word corresponding to j appears a lot in the document x but does not appear at all in documents that are
not on topic y. If this is the case, we tend to believe that the document x is on
topic y. Note that unlike the multivector construction described previously, in
the current construction the dimension of Î¨ does not depend on the number of
topics (i.e., the size of Y).

17.2.2

Cost-Sensitive Classification
So far we used the zero-one loss as our performance measure of the quality of
h(x). That is, the loss of a hypothesis h on an example (x, y) is 1 if h(x) 6= y and
0 otherwise. In some situations it makes more sense to penalize different levels
of loss for different mistakes. For example, in object recognition tasks, it is less
severe to predict that an image of a tiger contains a cat than predicting that
the image contains a whale. This can be modeled by specifying a loss function,
âˆ† : Y Ã— Y â†’ R+ , where for every pair of labels, y 0 , y, the loss of predicting
the label y 0 when the correct label is y is defined to be âˆ†(y 0 , y). We assume
that âˆ†(y, y) = 0. Note that the zero-one loss can be easily modeled by setting
âˆ†(y 0 , y) = 1[y0 6=y] .

17.2.3

ERM
We have defined the hypothesis class HÎ¨,W and specified a loss function âˆ†. To
learn the class with respect to the loss function, we can apply the ERM rule with
respect to this class. That is, we search for a multiclass hypothesis h âˆˆ HÎ¨,W ,
parameterized by a vector w, that minimizes the empirical risk with respect to
âˆ†,
m
1 X
âˆ†(h(xi ), yi ).
LS (h) =
m i=1
We now show that when W = Rd and we are in the realizable case, then it is
possible to solve the ERM problem efficiently using linear programming. Indeed,
in the realizable case, we need to find a vector w âˆˆ Rd that satisfies
âˆ€i âˆˆ [m],

yi = argmaxhw, Î¨(xi , y)i.
yâˆˆY

Equivalently, we need that w will satisfy the following set of linear inequalities
âˆ€i âˆˆ [m], âˆ€y âˆˆ Y \ {yi }, hw, Î¨(xi , yi )i > hw, Î¨(xi , y)i.
Finding w that satisfies the preceding set of linear equations amounts to solving
a linear program.
As in the case of binary classification, it is also possible to use a generalization
of the Perceptron algorithm for solving the ERM problem. See Exercise 2.
In the nonrealizable case, solving the ERM problem is in general computationally hard. We tackle this difficulty using the method of convex surrogate

17.2 Linear Multiclass Predictors

233

loss functions (see Section 12.3). In particular, we generalize the hinge loss to
multiclass problems.

17.2.4

Generalized Hinge Loss
Recall that in binary classification, the hinge loss is defined to be max{0, 1 âˆ’
yhw, xi}. We now generalize the hinge loss to multiclass predictors of the form
hw (x) = argmax hw, Î¨(x, y0 )i.
y 0 âˆˆY

Recall that a surrogate convex loss should upper bound the original nonconvex
loss, which in our case is âˆ†(hw (x), y). To derive an upper bound on âˆ†(hw (x), y)
we first note that the definition of hw (x) implies that
hw, Î¨(x, y)i â‰¤ hw, Î¨(x, hw (x))i.
Therefore,
âˆ†(hw (x), y) â‰¤ âˆ†(hw (x), y) + hw, Î¨(x, hw (x)) âˆ’ Î¨(x, y)i.
Since hw (x) âˆˆ Y we can upper bound the right-hand side of the preceding by
max
(âˆ†(y 0 , y) + hw, Î¨(x, y 0 ) âˆ’ Î¨(x, y)i)
0
y âˆˆY

def

=

`(w, (x, y)).

(17.3)

We use the term â€œgeneralized hinge lossâ€ to denote the preceding expression. As
we have shown, `(w, (x, y)) â‰¥ âˆ†(hw (x), y). Furthermore, equality holds whenever the score of the correct label is larger than the score of any other label, y 0 ,
by at least âˆ†(y 0 , y), namely,
âˆ€y 0 âˆˆ Y \ {y},

hw, Î¨(x, y)i â‰¥ hw, Î¨(x, y0 )i + âˆ†(y 0 , y).

It is also immediate to see that `(w, (x, y)) is a convex function with respect to w
since it is a maximum over linear functions of w (see Claim 12.5 in Chapter 12),
and that `(w, (x, y)) is Ï-Lipschitz with Ï = maxy0 âˆˆY kÎ¨(x, y 0 ) âˆ’ Î¨(x, y)k.
Remark 17.2 We use the name â€œgeneralized hinge lossâ€ since in the binary
case, when Y = {Â±1}, if we set Î¨(x, y) = yx
2 , then the generalized hinge loss
becomes the vanilla hinge loss for binary classification,
`(w, (x, y)) = max{0, 1 âˆ’ yhw, xi}.

Geometric Intuition:
The feature function Î¨ : X Ã— Y â†’ Rd maps each x into |Y| vectors in Rd .
The value of `(w, (x, y)) will be zero if there exists a direction w such that
when projecting the |Y| vectors onto this direction we obtain that each vector is
represented by the scalar hw, Î¨(x, y)i, and we can rank the different points on
the basis of these scalars so that
â€¢ The point corresponding to the correct y is top-ranked

234

Multiclass, Ranking, and Complex Prediction Problems

â€¢ For each y 0 6= y, the difference between hw, Î¨(x, y)i and hw, Î¨(x, y 0 )i is larger
than the loss of predicting y 0 instead of y. The difference hw, Î¨(x, y)i âˆ’
hw, Î¨(x, y 0 )i is also referred to as the â€œmarginâ€ (see Section 15.1).
This is illustrated in the following figure:
w

(y
,
âˆ†

Î¨(x, y 00 )

â‰¥

y

00

)

Î¨(x, y)

â‰¥

âˆ†

(y
,

y0
)

Î¨(x, y 0 )

17.2.5

Multiclass SVM and SGD
Once we have defined the generalized hinge loss, we obtain a convex-Lipschitz
learning problem and we can apply our general techniques for solving such problems. In particular, the RLM technique we have studied in Chapter 13 yields the
multiclass SVM rule:
Multiclass SVM
input: (x1 , y1 ), . . . , (xm , ym )
parameters:
regularization parameter Î» > 0
loss function âˆ† : Y Ã— Y â†’ R+
class-sensitive feature mapping Î¨ : X Ã— Y â†’ Rd
solve:
min

wâˆˆRd

!
m
1 X
0
0
max (âˆ†(y , yi ) + hw, Î¨(xi , y ) âˆ’ Î¨(xi , yi )i)
Î»kwk +
m i=1 y0 âˆˆY
2

output the predictor hw (x) = argmaxyâˆˆY hw, Î¨(x, y)i
We can solve the optimization problem associated with multiclass SVM using generic convex optimization algorithms (or using the method described in
Section 15.5). Let us analyze the risk of the resulting hypothesis. The analysis
seamlessly follows from our general analysis for convex-Lipschitz problems given
in Chapter 13. In particular, applying Corollary 13.8 and using the fact that the
generalized hinge loss upper bounds the âˆ† loss, we immediately obtain an analog
of Corollary 15.7:
corollary 17.1 Let D be a distribution over X Ã— Y, let Î¨ : X Ã— Y â†’ Rd ,
and assume that for all x âˆˆ X and y âˆˆ Y we have kÎ¨(x, y)k â‰¤ Ï/2. Let B > 0.

17.2 Linear Multiclass Predictors

235

q
2
Consider running Multiclass SVM with Î» = B2Ï2 m on a training set S âˆ¼ Dm
and let hw be the output of Multiclass SVM. Then,
r
8Ï2 B 2
gâˆ’hinge
gâˆ’hinge
âˆ†
E m [LD (hw )] â‰¤
E m [LD
(w)] â‰¤
min LD
(u) +
,
Sâˆ¼D
Sâˆ¼D
m
u:kukâ‰¤B
gâˆ’hinge
where Lâˆ†
(w) = E(x,y)âˆ¼D [`(w, (x, y))]
D (h) = E(x,y)âˆ¼D [âˆ†(h(x), y)] and LD
with ` being the generalized hinge-loss as defined in Equation (17.3).
gâˆ’hinge
We can also apply the SGD learning framework for minimizing LD
(w) as
described in Chapter 14. Recall Claim 14.6, which dealt with subgradients of max
functions. In light of this claim, in order to find a subgradient of the generalized
hinge loss all we need to do is to find y âˆˆ Y that achieves the maximum in the
definition of the generalized hinge loss. This yields the following algorithm:

SGD for Multiclass Learning
parameters:
Scalar Î· > 0, integer T > 0
loss function âˆ† : Y Ã— Y â†’ R+
class-sensitive feature mapping Î¨ : X Ã— Y â†’ Rd
initialize: w(1) = 0 âˆˆ Rd
for t = 1, 2, . . . , T
sample (x, y) âˆ¼ D

find yÌ‚ âˆˆ argmaxy0 âˆˆY âˆ†(y 0 , y) + hw(t) , Î¨(x, y 0 ) âˆ’ Î¨(x, y)i
set vt = Î¨(x, yÌ‚) âˆ’ Î¨(x, y)
update w(t+1) = w(t) âˆ’ Î·vt
PT
output wÌ„ = T1 t=1 w(t)
Our general analysis of SGD given in Corollary 14.12 immediately implies:
corollary 17.2 Let D be a distribution over X Ã— Y, let Î¨ : X Ã— Y â†’ Rd ,
and assume that for all x âˆˆ X and y âˆˆ Y we have kÎ¨(x, y)k â‰¤ Ï/2. Let B > 0.
Then, for every  > 0, if we run SGD for multiclass learning with a number of
iterations (i.e., number of examples)
T â‰¥
and with Î· =

q

B2
Ï2 T

, then the output of SGD satisfies

E [Lâˆ†
D (hwÌ„ )] â‰¤

Sâˆ¼D m

B 2 Ï2
2

gâˆ’hinge
E [LD
(wÌ„)] â‰¤

Sâˆ¼D m

min Lgâˆ’hinge
(u) + .
D

u:kukâ‰¤B

Remark 17.3 It is interesting to note that the risk bounds given in Corollary 17.1 and Corollary 17.2 do not depend explicitly on the size of the label
set Y, a fact we will rely on in the next section. However, the bounds may depend implicitly on the size of Y via the norm of Î¨(x, y) and the fact that the
bounds are meaningful only when there exists some vector u, kuk â‰¤ B, for which
(u) is not excessively large.
Lgâˆ’hinge
D

236

Multiclass, Ranking, and Complex Prediction Problems

17.3

Structured Output Prediction
Structured output prediction problems are multiclass problems in which Y is
very large but is endowed with a predefined structure. The structure plays a
key role in constructing efficient algorithms. To motivate structured learning
problems, consider the problem of optical character recognition (OCR). Suppose
we receive an image of some handwritten word and would like to predict which
word is written in the image. To simplify the setting, suppose we know how to
segment the image into a sequence of images, each of which contains a patch of
the image corresponding to a single letter. Therefore, X is the set of sequences
of images and Y is the set of sequences of letters. Note that the size of Y grows
exponentially with the maximal length of a word. An example of an image x
corresponding to the label y = â€œworkableâ€ is given in the following.

To tackle structure prediction we can rely on the family of linear predictors
described in the previous section. In particular, we need to define a reasonable
loss function for the problem, âˆ†, as well as a good class-sensitive feature mapping,
Î¨. By â€œgoodâ€ we mean a feature mapping that will lead to a low approximation
error for the class of linear predictors with respect to Î¨ and âˆ†. Once we do this,
we can rely, for example, on the SGD learning algorithm defined in the previous
section.
However, the huge size of Y poses several challenges:
1. To apply the multiclass prediction we need to solve a maximization problem
over Y. How can we predict efficiently when Y is so large?
2. How do we train w efficiently? In particular, to apply the SGD rule we again
need to solve a maximization problem over Y.
3. How can we avoid overfitting?
In the previous section we have already shown that the sample complexity of
learning a linear multiclass predictor does not depend explicitly on the number
of classes. We just need to make sure that the norm of the range of Î¨ is not too
large. This will take care of the overfitting problem. To tackle the computational
challenges we rely on the structure of the problem, and define the functions Î¨ and
âˆ† so that calculating the maximization problems in the definition of hw and in
the SGD algorithm can be performed efficiently. In the following we demonstrate
one way to achieve these goals for the OCR task mentioned previously.
To simplify the presentation, let us assume that all the words in Y are of length
r and that the number of different letters in our alphabet is q. Let y and y0 be two

17.3 Structured Output Prediction

237

words (i.e., sequences of letters) in Y. We define the function âˆ†(y0 , y) to be the
Pr
average number of letters that are different in y 0 and y, namely, 1r i=1 1[yi 6=yi0 ] .
Next, let us define a class-sensitive feature mapping Î¨(x, y). It will be convenient to think about x as a matrix of size n Ã— r, where n is the number of pixels
in each image, and r is the number of images in the sequence. The jâ€™th column
of x corresponds to the jâ€™th image in the sequence (encoded as a vector of gray
level values of pixels). The dimension of the range of Î¨ is set to be d = n q + q 2 .
The first nq feature functions are â€œtype 1â€ features and take the form:
r

Î¨i,j,1 (x, y) =

1X
xi,t 1[yt =j] .
r t=1

That is, we sum the value of the iâ€™th pixel only over the images for which y
assigns the letter j. The triple index (i, j, 1) indicates that we are dealing with
feature (i, j) of type 1. Intuitively, such features can capture pixels in the image
whose gray level values are indicative of a certain letter. The second type of
features take the form
r

Î¨i,j,2 (x, y) =

1X
1[y =i] 1[ytâˆ’1 =j] .
r t=2 t

That is, we sum the number of times the letter i follows the letter j. Intuitively,
these features can capture rules like â€œIt is likely to see the pair â€˜quâ€™ in a wordâ€
or â€œIt is unlikely to see the pair â€˜rzâ€™ in a word.â€ Of course, some of these features
will not be very useful, so the goal of the learning process is to assign weights to
features by learning the vector w, so that the weighted score will give us a good
prediction via
hw (x) = argmax hw, Î¨(x, y)i.
yâˆˆY

It is left to show how to solve the optimization problem in the definition
of hw (x) efficiently, as well as how to solve the optimization problem in the
definition of yÌ‚ in the SGD algorithm. We can do this by applying a dynamic
programming procedure. We describe the procedure for solving the maximization
in the definition of hw and leave as an exercise the maximization problem in the
definition of yÌ‚ in the SGD algorithm.
To derive the dynamic programming procedure, let us first observe that we
can write
r
X
Î¨(x, y) =
Ï†(x, yt , ytâˆ’1 ),
t=1

for an appropriate Ï† : X Ã— [q] Ã— [q] âˆª {0} â†’ Rd , and for simplicity we assume
that y0 is always equal to 0. Indeed, each feature function Î¨i,j,1 can be written
in terms of
Ï†i,j,1 (x, yt , ytâˆ’1 ) = xi,t 1[yt =j] ,

238

Multiclass, Ranking, and Complex Prediction Problems

while the feature function Î¨i,j,2 can be written in terms of
Ï†i,j,2 (x, yt , ytâˆ’1 ) = 1[yt =i] 1[ytâˆ’1 =j] .
Therefore, the prediction can be written as
hw (x) = argmax
yâˆˆY

r
X
hw, Ï†(x, yt , ytâˆ’1 )i.

(17.4)

t=1

In the following we derive a dynamic programming procedure that solves every
problem of the form given in Equation (17.4). The procedure will maintain a
matrix M âˆˆ Rq,r such that
Ms,Ï„ =

max
(y1 ,...,yÏ„ ):yÏ„ =s

Ï„
X

hw, Ï†(x, yt , ytâˆ’1 )i.

t=1

Clearly, the maximum of hw, Î¨(x, y)i equals maxs Ms,r . Furthermore, we can
calculate M in a recursive manner:
Ms,Ï„ = max
(Ms0 ,Ï„ âˆ’1 + hw, Ï†(x, s, s0 )i) .
0
s

(17.5)

This yields the following procedure:
Dynamic Programming for Calculating hw (x) as Given
in Equation (17.4)
input: a matrix x âˆˆ Rn,r and a vector w
initialize:
foreach s âˆˆ [q]
Ms,1 = hw, Ï†(x, s, âˆ’1)i
for Ï„ = 2, . . . , r
foreach s âˆˆ [q]
set Ms,Ï„ as in Equation (17.5)
set Is,Ï„ to be the s0 that maximizes Equation (17.5)
set yt = argmaxs Ms,r
for Ï„ = r, r âˆ’ 1, . . . , 2
set yÏ„ âˆ’1 = IyÏ„ ,Ï„
output: y = (y1 , . . . , yr )

17.4

Ranking
Ranking is the problem of ordering a set of instances according to their â€œrelevance.â€ A typical application is ordering results of a search engine according to
their relevance to the query. Another example is a system that monitors electronic transactions and should alert for possible fraudulent transactions. Such a
system should order transactions according to how suspicious they are.
Sâˆž
Formally, let X âˆ— = n=1 X n be the set of all sequences of instances from

17.4 Ranking

239

X of arbitrary length. A ranking hypothesis, h, is a function that receives a
sequence of instances xÌ„ = (x1 , . . . , xr ) âˆˆ X âˆ— , and returns a permutation of [r].
It is more convenient to let the output of h be a vector y âˆˆ Rr , where by
sorting the elements of y we obtain the permutation over [r]. We denote by
Ï€(y) the permutation over [r] induced by y. For example, for r = 5, the vector
y = (2, 1, 6, âˆ’1, 0.5) induces the permutation Ï€(y) = (4, 3, 5, 1, 2). That is,
if we sort y in an ascending order, then we obtain the vector (âˆ’1, 0.5, 1, 2, 6).
Now, Ï€(y)i is the position of yi in the sorted vector (âˆ’1, 0.5, 1, 2, 6). This
notation reflects that the top-ranked instances are those that achieve the highest
values in Ï€(y).
In the notation of our PAC learning model, the examples domain is Z =
Sâˆž
r
r
r=1 (X Ã— R ), and the hypothesis class, H, is some set of ranking hypotheses.
We next turn to describe loss functions for ranking. There are many possible ways
to define such loss functions, and here we list a few examples. In all the examples
Sâˆž
we define `(h, (xÌ„, y)) = âˆ†(h(xÌ„), y), for some function âˆ† : r=1 (Rr Ã— Rr ) â†’ R+ .
â€¢ 0â€“1 Ranking loss: âˆ†(y0 , y) is zero if y and y0 induce exactly the same
ranking and âˆ†(y0 , y) = 1 otherwise. That is, âˆ†(y0 , y) = 1[Ï€(y0 )6=Ï€(y)] . Such
a loss function is almost never used in practice as it does not distinguish
between the case in which Ï€(y0 ) is almost equal to Ï€(y) and the case in
which Ï€(y0 ) is completely different from Ï€(y).
â€¢ Kendall-Tau Loss: We count the number of pairs (i, j) that are in different
order in the two permutations. This can be written as
âˆ†(y0 , y) =

râˆ’1 X
r
X
2
1[sign(yi0 âˆ’yj0 )6=sign(yi âˆ’yj )] .
r(r âˆ’ 1) i=1 j=i+1

This loss function is more useful than the 0â€“1 loss as it reflects the level of
similarity between the two rankings.
â€¢ Normalized Discounted Cumulative Gain (NDCG): This measure emphasizes the correctness at the top of the list by using a monotonically
nondecreasing discount function D : N â†’ R+ . We first define a discounted
cumulative gain measure:
G(y0 , y) =

r
X

D(Ï€(y0 )i ) yi .

i=1

In words, if we interpret yi as a score of the â€œtrue relevanceâ€ of item i, then
we take a weighted sum of the relevance of the elements, while the weight
of yi is determined on the basis of the position of i in Ï€(y0 ). Assuming that
all elements of y are nonnegative, it is easy to verify that 0 â‰¤ G(y0 , y) â‰¤
G(y, y). We can therefore define a normalized discounted cumulative gain
by the ratio G(y0 , y)/G(y, y), and the corresponding loss function would
be
r
X
G(y0 , y)
1
âˆ†(y0 , y) = 1 âˆ’
=
(D(Ï€(y)i ) âˆ’ D(Ï€(y0 )i )) yi .
G(y, y)
G(y, y) i=1

240

Multiclass, Ranking, and Complex Prediction Problems

We can easily see that âˆ†(y0 , y) âˆˆ [0, 1] and that âˆ†(y0 , y) = 0 whenever
Ï€(y0 ) = Ï€(y).
A typical way to define the discount function is by
(
1
if i âˆˆ {r âˆ’ k + 1, . . . , r}
D(i) = log2 (râˆ’i+2)
0
otherwise
where k < r is a parameter. This means that we care more about elements
that are ranked higher, and we completely ignore elements that are not at
the top-k ranked elements. The NDCG measure is often used to evaluate
the performance of search engines since in such applications it makes sense
completely to ignore elements that are not at the top of the ranking.
Once we have a hypothesis class and a ranking loss function, we can learn a
ranking function using the ERM rule. However, from the computational point of
view, the resulting optimization problem might be hard to solve. We next discuss
how to learn linear predictors for ranking.

17.4.1

Linear Predictors for Ranking
A natural way to define a ranking function is by projecting the instances onto
some vector w and then outputting the resulting scalars as our representation
of the ranking function. That is, assuming that X âŠ‚ Rd , for every w âˆˆ Rd we
define a ranking function
hw ((x1 , . . . , xr )) = (hw, x1 i, . . . , hw, xr i).

(17.6)

As we discussed in Chapter 16, we can also apply a feature mapping that maps
instances into some feature space and then takes the inner products with w in the
feature space. For simplicity, we focus on the simpler form as in Equation (17.6).
Given some W âŠ‚ Rd , we can now define the hypothesis class HW = {hw :
w âˆˆ W }. Once we have defined this hypothesis class, and have chosen a ranking
loss function, we can apply the ERM rule as follows: Given a training set, S =
(xÌ„1 , y1 ), . . . , (xÌ„m , ym ), where each (xÌ„i , yi ) is in (X Ã— R)ri , for some ri âˆˆ N, we
Pm
should search w âˆˆ W that minimizes the empirical loss, i=1 âˆ†(hw (xÌ„i ), yi ).
As in the case of binary classification, for many loss functions this problem is
computationally hard, and we therefore turn to describe convex surrogate loss
functions. We describe the surrogates for the Kendall tau loss and for the NDCG
loss.

A Hinge Loss for the Kendall Tau Loss Function:
We can think of the Kendall tau loss as an average of 0âˆ’1 losses for each pair.
In particular, for every (i, j) we can rewrite
1[sign(yi0 âˆ’yj0 )6=sign(yi âˆ’yj )] = 1[sign(yi âˆ’yj )(yi0 âˆ’yj0 )â‰¤0] .

17.4 Ranking

241

In our case, yi0 âˆ’ yj0 = hw, xi âˆ’ xj i. It follows that we can use the hinge loss upper
bound as follows:
1[sign(yi âˆ’yj )(yi0 âˆ’yj0 )â‰¤0] â‰¤ max {0, 1 âˆ’ sign (yi âˆ’ yj ) hw, xi âˆ’ xj i} .
Taking the average over the pairs we obtain the following surrogate convex loss
for the Kendall tau loss function:
âˆ†(hw (xÌ„), y) â‰¤

râˆ’1 X
r
X
2
max {0, 1 âˆ’ sign(yi âˆ’ yj ) hw, xi âˆ’ xj i} .
r(r âˆ’ 1) i=1 j=i+1

The right-hand side is convex with respect to w and upper bounds the Kendall
tau loss. It is also a Ï-Lipschitz function with parameter Ï â‰¤ maxi,j kxi âˆ’ xj k.

A Hinge Loss for the NDCG Loss Function:
The NDCG loss function depends on the predicted ranking vector y0 âˆˆ Rr via
the permutation it induces. To derive a surrogate loss function we first make
the following observation. Let V be the set of all permutations of [r] encoded as
vectors; namely, each v âˆˆ V is a vector in [r]r such that for all i 6= j we have
vi 6= vj . Then (see Exercise 4),
Ï€(y0 ) = argmax
vâˆˆV

Let us denote Î¨(xÌ„, v) =

Pr

i=1

r
X

vi yi0 .

(17.7)

i=1

vi xi ; it follows that

Ï€(hw (xÌ„)) = argmax
vâˆˆV

r
X

vi hw, xi i

i=1

*
= argmax w,
vâˆˆV

r
X

+
vi x i

i=1

= argmaxhw, Î¨(xÌ„, v)i.
vâˆˆV

On the basis of this observation, we can use the generalized hinge loss for costsensitive multiclass classification as a surrogate loss function for the NDCG loss
as follows:
âˆ†(hw (xÌ„), y) â‰¤ âˆ†(hw (xÌ„), y) + hw, Î¨(xÌ„, Ï€(hw (xÌ„)))i âˆ’ hw, Î¨(xÌ„, Ï€(y))i
â‰¤ max [âˆ†(v, y) + hw, Î¨(xÌ„, v)i âˆ’ hw, Î¨(xÌ„, Ï€(y))i]
vâˆˆV
"
#
r
X
= max âˆ†(v, y) +
(vi âˆ’ Ï€(y)i ) hw, xi i .
vâˆˆV

(17.8)

i=1

The right-hand side is a convex function with respect to w.
We can now solve the learning problem using SGD as described in Section 17.2.5.
The main computational bottleneck is calculating a subgradient of the loss function, which is equivalent to finding v that achieves the maximum in Equation (17.8) (see Claim 14.6). Using the definition of the NDCG loss, this is

242

Multiclass, Ranking, and Complex Prediction Problems

equivalent to solving the problem
argmin
vâˆˆV

r
X
(Î±i vi + Î²i D(vi )),
i=1

where Î±i = âˆ’hw, xi i and Î²i = yi /G(y, y). We can think of this problem a little
bit differently by defining a matrix A âˆˆ Rr,r where
Ai,j = jÎ±i + D(j) Î²i .
Now, let us think about each j as a â€œworker,â€ each i as a â€œtask,â€ and Ai,j as
the cost of assigning task i to worker j. With this view, the problem of finding
v becomes the problem of finding an assignment of the tasks to workers of
minimal cost. This problem is called â€œthe assignment problemâ€ and can be solved
efficiently. One particular algorithm is the â€œHungarian methodâ€ (Kuhn 1955).
Another way to solve the assignment problem is using linear programming. To
do so, let us first write the assignment problem as
argmin

r
X

BâˆˆRr,r
+
i,j=1

Ai,j Bi,j

s.t. âˆ€i âˆˆ [r],

âˆ€j âˆˆ [r],

r
X
j=1
r
X

(17.9)

Bi,j = 1
Bi,j = 1

i=1

âˆ€i, j, Bi,j âˆˆ {0, 1}
A matrix B that satisfies the constraints in the preceding optimization problem
is called a permutation matrix. This is because the constraints guarantee that
there is at most a single entry of each row that equals 1 and a single entry of each
column that equals 1. Therefore, the matrix B corresponds to the permutation
v âˆˆ V defined by vi = j for the single index j that satisfies Bi,j = 1.
The preceding optimization is still not a linear program because of the combinatorial constraint Bi,j âˆˆ {0, 1}. However, as it turns out, this constraint is
redundant â€“ if we solve the optimization problem while simply omitting the
combinatorial constraint, then we are still guaranteed that there is an optimal
solution that will satisfy this constraint. This is formalized later.
P
Denote hA, Bi = i,j Ai,j Bi,j . Then, Equation (17.9) is the problem of minimizing hA, Bi such that B is a permutation matrix.
A matrix B âˆˆ Rr,r is called doubly stochastic if all elements of B are nonnegative, the sum of each row of B is 1, and the sum of each column of B is 1.
Therefore, solving Equation (17.9) without the constraints Bi,j âˆˆ {0, 1} is the
problem
argminhA, Bi s.t. B is a doubly stochastic matrix.
BâˆˆRr,r

(17.10)

17.5 Bipartite Ranking and Multivariate Performance Measures

243

The following claim states that every doubly stochastic matrix is a convex
combination of permutation matrices.
claim 17.3 ((Birkhoff 1946, Von Neumann 1953)) The set of doubly stochastic
matrices in Rr,r is the convex hull of the set of permutation matrices in Rr,r .
On the basis of the claim, we easily obtain the following:
lemma 17.4 There exists an optimal solution of Equation (17.10) that is also
an optimal solution of Equation (17.9).
Proof Let B be a solution of Equation (17.10). Then, by Claim 17.3, we can
P
write B = i Î³i Ci , where each Ci is a permutation matrix, each Î³i > 0, and
P
i Î³i = 1. Since all the Ci are also doubly stochastic, we clearly have that
hA, Bi â‰¤ hA, Ci i for every i. We claim that there is some i for which hA, Bi =
hA, Ci i. This must be true since otherwise, if for every i hA, Bi < hA, Ci i, we
would have that
*
+
X
X
X
hA, Bi = A,
Î³i C i =
Î³i hA, Ci i >
Î³i hA, Bi = hA, Bi,
i

i

i

which cannot hold. We have thus shown that some permutation matrix, Ci ,
satisfies hA, Bi = hA, Ci i. But, since for every other permutation matrix C we
have hA, Bi â‰¤ hA, Ci we conclude that Ci is an optimal solution of both Equation (17.9) and Equation (17.10).

17.5

Bipartite Ranking and Multivariate Performance Measures
In the previous section we described the problem of ranking. We used a vector
y âˆˆ Rr for representing an order over the elements x1 , . . . , xr . If all elements in y
are different from each other, then y specifies a full order over [r]. However, if two
elements of y attain the same value, yi = yj for i 6= j, then y can only specify a
partial order over [r]. In such a case, we say that xi and xj are of equal relevance
according to y. In the extreme case, y âˆˆ {Â±1}r , which means that each xi is
either relevant or nonrelevant. This setting is often called â€œbipartite ranking.â€ For
example, in the fraud detection application mentioned in the previous section,
each transaction is labeled as either fraudulent (yi = 1) or benign (yi = âˆ’1).
Seemingly, we can solve the bipartite ranking problem by learning a binary
classifier, applying it on each instance, and putting the positive ones at the top
of the ranked list. However, this may lead to poor results as the goal of a binary
learner is usually to minimize the zero-one loss (or some surrogate of it), while the
goal of a ranker might be significantly different. To illustrate this, consider again
the problem of fraud detection. Usually, most of the transactions are benign (say
99.9%). Therefore, a binary classifier that predicts â€œbenignâ€ on all transactions
will have a zero-one error of 0.1%. While this is a very small number, the resulting
predictor is meaningless for the fraud detection application. The crux of the

244

Multiclass, Ranking, and Complex Prediction Problems

problem stems from the inadequacy of the zero-one loss for what we are really
interested in. A more adequate performance measure should take into account
the predictions over the entire set of instances. For example, in the previous
section we have defined the NDCG loss, which emphasizes the correctness of the
top-ranked items. In this section we describe additional loss functions that are
specifically adequate for bipartite ranking problems.
As in the previous section, we are given a sequence of instances, xÌ„ = (x1 , . . . , xr ),
and we predict a ranking vector y0 âˆˆ Rr . The feedback vector is y âˆˆ {Â±1}r . We
define a loss that depends on y0 and y and depends on a threshold Î¸ âˆˆ R. This
threshold transforms the vector y0 âˆˆ Rr into the vector (sign(yi0 âˆ’Î¸), . . . , sign(yr0 âˆ’
Î¸)) âˆˆ {Â±1}r . Usually, the value of Î¸ is set to be 0. However, as we will see, we
sometimes set Î¸ while taking into account additional constraints on the problem.
The loss functions we define in the following depend on the following 4 numbers:
True positives: a = |{i : yi = +1 âˆ§ sign(yi0 âˆ’ Î¸) = +1}|
False positives: b = |{i : yi = âˆ’1 âˆ§ sign(yi0 âˆ’ Î¸) = +1}|
False negatives: c = |{i : yi = +1 âˆ§ sign(yi0 âˆ’ Î¸) = âˆ’1}|

(17.11)

True negatives: d = |{i : yi = âˆ’1 âˆ§ sign(yi0 âˆ’ Î¸) = âˆ’1}|
The recall (a.k.a. sensitivity) of a prediction vector is the fraction of true
a
. The precision is the fraction of correct
positives y0 â€œcatches,â€ namely, a+c
a
predictions among the positive labels we predict, namely, a+b
. The specificity
d
.
is the fraction of true negatives that our predictor â€œcatches,â€ namely, d+b
Note that as we decrease Î¸ the recall increases (attaining the value 1 when
Î¸ = âˆ’âˆž). On the other hand, the precision and the specificity usually decrease
as we decrease Î¸. Therefore, there is a tradeoff between precision and recall, and
we can control it by changing Î¸. The loss functions defined in the following use
various techniques for combining both the precision and recall.
â€¢ Averaging sensitivity and specificity:
is the average of the
 This measure

1
a
d
sensitivity and specificity, namely, 2 a+c + d+b . This is also the accuracy
on positive examples averaged with the accuracy on negative examples.
Here, we set Î¸ = 0 and the corresponding loss function is âˆ†(y0 , y) =
1âˆ’

1
2

a
a+c

+

d
d+b

.

â€¢ F1 -score: The F1 score is the harmonic mean of the precision and recall:
2
. Its maximal value (of 1) is obtained when both precision
1
1
Precision + Recall
and recall are 1, and its minimal value (of 0) is obtained whenever one of
them is 0 (even if the other one is 1). The F1 score can be written using
2a
the numbers a, b, c as follows; F1 = 2a+b+c
. Again, we set Î¸ = 0, and the
0
loss function becomes âˆ†(y , y) = 1 âˆ’ F1 .
â€¢ FÎ² -score: It is like F1 score, but we attach Î² 2 times more importance to
1+Î² 2
. It can also be written as
recall than to precision, that is,
1
+Î² 2 1
Precision

Recall

17.5 Bipartite Ranking and Multivariate Performance Measures

245

2

)a
FÎ² = (1+Î²(1+Î²
2 )a+b+Î² 2 c . Again, we set Î¸ = 0, and the loss function becomes
âˆ†(y0 , y) = 1 âˆ’ FÎ² .
â€¢ Recall at k: We measure the recall while the prediction must contain at most
k positive labels. That is, we should set Î¸ so that a + b â‰¤ k. This is convenient, for example, in the application of a fraud detection system, where a
bank employee can only handle a small number of suspicious transactions.
â€¢ Precision at k: We measure the precision while the prediction must contain
at least k positive labels. That is, we should set Î¸ so that a + b â‰¥ k.

The measures defined previously are often referred to as multivariate performance measures. Note that these measures are highly different from the average
b+d
. In the aforemenzero-one loss, which in the preceding notation equals a+b+c+d
tioned example of fraud detection, when 99.9% of the examples are negatively
labeled, the zero-one loss of predicting that all the examples are negatives is
0.1%. In contrast, the recall of such prediction is 0 and hence the F1 score is also
0, which means that the corresponding loss will be 1.

17.5.1

Linear Predictors for Bipartite Ranking
We next describe how to train linear predictors for bipartite ranking. As in the
previous section, a linear predictor for ranking is defined to be
hw (xÌ„) = (hw, x1 i, . . . , hw, xr i).
The corresponding loss function is one of the multivariate performance measures
described before. The loss function depends on y0 = hw (xÌ„) via the binary vector
it induces, which we denote by
b(y0 ) = (sign(y10 âˆ’ Î¸), . . . , sign(yr0 âˆ’ Î¸)) âˆˆ {Â±1}r .

(17.12)

As in the previous section, to facilitate an efficient algorithm we derive a convex
surrogate loss function on âˆ†. The derivation is similar to the derivation of the
generalized hinge loss for the NDCG ranking loss, as described in the previous
section.
Our first observation is that for all the values of Î¸ defined before, there is some
V âŠ† {Â±1}r such that b(y0 ) can be rewritten as
b(y0 ) = argmax
vâˆˆV

r
X

vi yi0 .

(17.13)

i=1

This is clearly true for the case Î¸ = 0 if we choose V = {Â±1}r . The two measures
for which Î¸ is not taken to be 0 are precision at k and recall at k. For precision
at k we can take V to be the set Vâ‰¥k , containing all vectors in {Â±1}r whose
number of ones is at least k. For recall at k, we can take V to be Vâ‰¤k , which is
defined analogously. See Exercise 5.

246

Multiclass, Ranking, and Complex Prediction Problems

Once we have defined b as in Equation (17.13), we can easily derive a convex
surrogate loss as follows. Assuming that y âˆˆ V , we have that

âˆ†(hw (xÌ„), y) = âˆ†(b(hw (xÌ„)), y)
â‰¤ âˆ†(b(hw (xÌ„)), y) +
"
â‰¤ max
vâˆˆV

âˆ†(v, y) +

r
X

(bi (hw (xÌ„)) âˆ’ yi )hw, xi i

i=1
r
X

#

(vi âˆ’ yi ) hw, xi i .

(17.14)

i=1

The right-hand side is a convex function with respect to w.
We can now solve the learning problem using SGD as described in Section 17.2.5.
The main computational bottleneck is calculating a subgradient of the loss function, which is equivalent to finding v that achieves the maximum in Equation (17.14) (see Claim 14.6).
In the following we describe how to find this maximizer efficiently for any
performance measure that can be written as a function of the numbers a, b, c, d
given in Equation (17.11), and for which the set V contains all elements in {Â±1}r
for which the values of a, b satisfy some constraints. For example, for â€œrecall at
kâ€ the set V is all vectors for which a + b â‰¤ k.
The idea is as follows. For any a, b âˆˆ [r], let

YÌ„a,b = {v : |{i : vi = 1 âˆ§ yi = 1}| = a âˆ§ |{i : vi = 1 âˆ§ yi = âˆ’1}| = b } .

Any vector v âˆˆ V falls into YÌ„a,b for some a, b âˆˆ [r]. Furthermore, if YÌ„a,b âˆ© V
is not empty for some a, b âˆˆ [r] then YÌ„a,b âˆ© V = YÌ„a,b . Therefore, we can search
within each YÌ„a,b that has a nonempty intersection with V separately, and then
take the optimal value. The key observation is that once we are searching only
within YÌ„a,b , the value of âˆ† is fixed so we only need to maximize the expression

max
vâˆˆYÌ„a,b

r
X

vi hw, xi i.

i=1

Suppose the examples are sorted so that hw, x1 i â‰¥ Â· Â· Â· â‰¥ hw, xr i. Then, it is
easy to verify that we would like to set vi to be positive for the smallest indices
i. Doing this, with the constraint on a, b, amounts to setting vi = 1 for the a
top ranked positive examples and for the b top-ranked negative examples. This
yields the following procedure.

17.6 Summary

247

Solving Equation (17.14)
input:
(x1 , . . . , xr ), (y1 , . . . , yr ), w, V, âˆ†
assumptions:
âˆ† is a function of a, b, c, d
V contains all vectors for which f (a, b) = 1 for some function f
initialize:
P = |{i : yi = 1}|, N = |{i : yi = âˆ’1}|
Âµ = (hw, x1 i, . . . , hw, xr i), Î±? = âˆ’âˆž
sort examples so that Âµ1 â‰¥ Âµ2 â‰¥ Â· Â· Â· â‰¥ Âµr
let i1 , . . . , iP be the (sorted) indices of the positive examples
let j1 , . . . , jN be the (sorted) indices of the negative examples
for a = 0, 1, . . . , P
c=P âˆ’a
for b = 0, 1, . . . , N such that f (a, b) = 1
d=N âˆ’b
calculate âˆ† using a, b, c, d
set v1 , . . . , vr s.t. vi1 = Â· Â· Â· = via = vj1 = Â· Â· Â· = vjb = 1
and the rest of the elements of v equal âˆ’1
Pr
set Î± = âˆ† + i=1 vi Âµi
if Î± â‰¥ Î±?
Î±? = Î±, v? = v
output v?

17.6

Summary
Many real world supervised learning problems can be cast as learning a multiclass
predictor. We started the chapter by introducing reductions of multiclass learning
to binary learning. We then described and analyzed the family of linear predictors
for multiclass learning. We have shown how this family can be used even if the
number of classes is extremely large, as long as we have an adequate structure
on the problem. Finally, we have described ranking problems. In Chapter 29 we
study the sample complexity of multiclass learning in more detail.

17.7

Bibliographic Remarks
The One-versus-All and All-Pairs approach reductions have been unified under the framework of Error Correction Output Codes (ECOC) (Dietterich &
Bakiri 1995, Allwein, Schapire & Singer 2000). There are also other types of reductions such as tree-based classifiers (see, for example, Beygelzimer, Langford
& Ravikumar (2007)). The limitations of reduction techniques have been studied

248

Multiclass, Ranking, and Complex Prediction Problems

in (Daniely et al. 2011, Daniely, Sabato & Shwartz 2012). See also Chapter 29,
in which we analyze the sample complexity of multiclass learning.
Direct approaches to multiclass learning with linear predictors have been studied in (Vapnik 1998, Weston & Watkins 1999, Crammer & Singer 2001). In particular, the multivector construction is due to Crammer & Singer (2001).
Collins (2000) has shown how to apply the Perceptron algorithm for structured
output problems. See also Collins (2002). A related approach is discriminative
learning of conditional random fields; see Lafferty, McCallum & Pereira (2001).
Structured output SVM has been studied in (Weston, Chapelle, Vapnik, Elisseeff
& SchoÌˆlkopf 2002, Taskar, Guestrin & Koller 2003, Tsochantaridis, Hofmann,
Joachims & Altun 2004).
The dynamic procedure we have presented for calculating the prediction hw (x)
in the structured output section is similar to the forward-backward variables
calculated by the Viterbi procedure in HMMs (see, for instance, (Rabiner &
Juang 1986)). More generally, solving the maximization problem in structured
output is closely related to the problem of inference in graphical models (see, for
example, Koller & Friedman (2009)).
Chapelle, Le & Smola (2007) proposed to learn a ranking function with respect
to the NDCG loss using ideas from structured output learning. They also observed that the maximization problem in the definition of the generalized hinge
loss is equivalent to the assignment problem.
Agarwal & Roth (2005) analyzed the sample complexity of bipartite ranking.
Joachims (2005) studied the applicability of structured output SVM to bipartite
ranking with multivariate performance measures.

17.8

Exercises
1. Consider a set S of examples in Rn Ã—[k] for which there exist vectors Âµ1 , . . . , Âµk
such that every example (x, y) âˆˆ S falls within a ball centered at Âµy whose
radius is r â‰¥ 1. Assume also that for every i 6= j, kÂµi âˆ’ Âµj k â‰¥ 4r. Consider concatenating each instance by the constant 1 and then applying the
multivector construction, namely,
Î¨(x, y) = [

0, . . . , 0 , x1 , . . . , xn , 1 ,
|
{z
}
| {z }

âˆˆR(yâˆ’1)(n+1)

âˆˆRn+1

0, . . . , 0
| {z }

].

âˆˆR(kâˆ’y)(n+1)

Show that there exists a vector w âˆˆ Rk(n+1) such that `(w, (x, y)) = 0 for
every (x, y) âˆˆ S.
Hint: Observe that for every example (x, y) âˆˆ S we can write x = Âµy + v for
some kvk â‰¤ r. Now, take w = [w1 , . . . , wk ], where wi = [Âµi , âˆ’kÂµi k2 /2].
2. Multiclass Perceptron: Consider the following algorithm:

17.8 Exercises

249

Multiclass Batch Perceptron
Input:
A training set (x1 , y1 ), . . . , (xm , ym )
A class-sensitive feature mapping Î¨ : X Ã— Y â†’ Rd
Initialize: w(1) = (0, . . . , 0) âˆˆ Rd
For t = 1, 2, . . .
If (âˆƒ i and y 6= yi s.t. hw(t) , Î¨(xi , yi )i â‰¤ hw(t) , Î¨(xi , y)i) then
w(t+1) = w(t) + Î¨(xi , yi ) âˆ’ Î¨(xi , y)
else
output w(t)
Prove the following:
theorem 17.5 Assume that there exists w? such that for all i and for all
y 6= yi it holds that hw? , Î¨(xi , yi )i â‰¥ hw? , Î¨(xi , y)i+1. Let R = maxi,y kÎ¨(xi , yi )âˆ’
Î¨(xi , y)k. Then, the multiclass Perceptron algorithm stops after at most (Rkw? k)2
iterations, and when it stops it holds that âˆ€i âˆˆ [m], yi = argmaxy hw(t) , Î¨(xi , y)i.
3. Generalize the dynamic programming procedure given in Section 17.3 for solving the maximization problem given in the definition of hÌ‚ in the SGD procePr
dure for multiclass prediction. You can assume that âˆ†(y0 , y) = t=1 Î´(yt0 , yt )
for some arbitrary function Î´.
4. Prove that Equation (17.7) holds.
5. Show that the two definitions of Ï€ as defined in Equation (17.12) and Equation (17.13) are indeed equivalent for all the multivariate performance measures.

18 Decision Trees

A decision tree is a predictor, h : X â†’ Y, that predicts the label associated with
an instance x by traveling from a root node of a tree to a leaf. For simplicity
we focus on the binary classification setting, namely, Y = {0, 1}, but decision
trees can be applied for other prediction problems as well. At each node on the
root-to-leaf path, the successor child is chosen on the basis of a splitting of the
input space. Usually, the splitting is based on one of the features of x or on a
predefined set of splitting rules. A leaf contains a specific label. An example of
a decision tree for the papayas example (described in Chapter 2) is given in the
following:

Color?
pale green to pale yellow
other

not-tasty

Softness?
other

not-tasty

gives slightly to palm pressure

tasty

To check if a given papaya is tasty or not, the decision tree first examines
the color of the Papaya. If this color is not in the range pale green to pale
yellow, then the tree immediately predicts that the papaya is not tasty without
additional tests. Otherwise, the tree turns to examine the softness of the papaya.
If the softness level of the papaya is such that it gives slightly to palm pressure,
the decision tree predicts that the papaya is tasty. Otherwise, the prediction is
â€œnot-tasty.â€ The preceding example underscores one of the main advantages of
decision trees â€“ the resulting classifier is very simple to understand and interpret.
c 2014 by Shai Shalev-Shwartz and Shai Ben-David
Understanding Machine Learning, 
Published 2014 by Cambridge University Press.
Personal use only. Not for distribution. Do not post.
Please link to http://www.cs.huji.ac.il/~shais/UnderstandingMachineLearning

18.1 Sample Complexity

18.1

251

Sample Complexity
A popular splitting rule at internal nodes of the tree is based on thresholding the
value of a single feature. That is, we move to the right or left child of the node on
the basis of 1[xi <Î¸] , where i âˆˆ [d] is the index of the relevant feature and Î¸ âˆˆ R
is the threshold. In such cases, we can think of a decision tree as a splitting of
the instance space, X = Rd , into cells, where each leaf of the tree corresponds
to one cell. It follows that a tree with k leaves can shatter a set of k instances.
Hence, if we allow decision trees of arbitrary size, we obtain a hypothesis class
of infinite VC dimension. Such an approach can easily lead to overfitting.
To avoid overfitting, we can rely on the minimum description length (MDL)
principle described in Chapter 7, and aim at learning a decision tree that on one
hand fits the data well while on the other hand is not too large.
For simplicity, we will assume that X = {0, 1}d . In other words, each instance
is a vector of d bits. In that case, thresholding the value of a single feature
corresponds to a splitting rule of the form 1[xi =1] for some i = [d]. For instance,
we can model the â€œpapaya decision treeâ€ earlier by assuming that a papaya is
parameterized by a two-dimensional bit vector x âˆˆ {0, 1}2 , where the bit x1
represents whether the color is pale green to pale yellow or not, and the bit x2
represents whether the softness is gives slightly to palm pressure or not. With
this representation, the node Color? can be replaced with 1[x1 =1] , and the node
Softness? can be replaced with 1[x2 =1] . While this is a big simplification, the
algorithms and analysis we provide in the following can be extended to more
general cases.
With the aforementioned simplifying assumption, the hypothesis class becomes
finite, but is still very large. In particular, any classifier from {0, 1}d to {0, 1}
can be represented by a decision tree with 2d leaves and depth of d + 1 (see
Exercise 1). Therefore, the VC dimension of the class is 2d , which means that
the number of examples we need to PAC learn the hypothesis class grows with
2d . Unless d is very small, this is a huge number of examples.
To overcome this obstacle, we rely on the MDL scheme described in Chapter 7.
The underlying prior knowledge is that we should prefer smaller trees over larger
trees. To formalize this intuition, we first need to define a description language
for decision trees, which is prefix free and requires fewer bits for smaller decision
trees. Here is one possible way: A tree with n nodes will be described in n + 1
blocks, each of size log2 (d + 3) bits. The first n blocks encode the nodes of the
tree, in a depth-first order (preorder), and the last block marks the end of the
code. Each block indicates whether the current node is:
â€¢ An internal node of the form 1[xi =1] for some i âˆˆ [d]
â€¢ A leaf whose value is 1
â€¢ A leaf whose value is 0
â€¢ End of the code

252

Decision Trees

Overall, there are d + 3 options, hence we need log2 (d + 3) bits to describe each
block.
Assuming each internal node has two children,1 it is not hard to show that
this is a prefix-free encoding of the tree, and that the description length of a tree
with n nodes is (n + 1) log2 (d + 3).
By Theorem 7.7 we have that with probability of at least 1 âˆ’ Î´ over a sample
of size m, for every n and every decision tree h âˆˆ H with n nodes it holds that
r
(n + 1) log2 (d + 3) + log(2/Î´)
LD (h) â‰¤ LS (h) +
.
(18.1)
2m
This bound performs a tradeoff: on the one hand, we expect larger, more complex
decision trees to have a smaller training risk, LS (h), but the respective value of
n will be larger. On the other hand, smaller decision trees will have a smaller
value of n, but LS (h) might be larger. Our hope (or prior knowledge) is that we
can find a decision tree with both low empirical risk, LS (h), and a number of
nodes n not too high. Our bound indicates that such a tree will have low true
risk, LD (h).

18.2

Decision Tree Algorithms
The bound on LD (h) given in Equation (18.1) suggests a learning rule for decision
trees â€“ search for a tree that minimizes the right-hand side of Equation (18.1).
Unfortunately, it turns out that solving this problem is computationally hard.2
Consequently, practical decision tree learning algorithms are based on heuristics
such as a greedy approach, where the tree is constructed gradually, and locally
optimal decisions are made at the construction of each node. Such algorithms
cannot guarantee to return the globally optimal decision tree but tend to work
reasonably well in practice.
A general framework for growing a decision tree is as follows. We start with
a tree with a single leaf (the root) and assign this leaf a label according to a
majority vote among all labels over the training set. We now perform a series of
iterations. On each iteration, we examine the effect of splitting a single leaf. We
define some â€œgainâ€ measure that quantifies the improvement due to this split.
Then, among all possible splits, we either choose the one that maximizes the
gain and perform it, or choose not to split the leaf at all.
In the following we provide a possible implementation. It is based on a popular
decision tree algorithm known as â€œID3â€ (short for â€œIterative Dichotomizer 3â€).
We describe the algorithm for the case of binary features, namely, X = {0, 1}d ,
1

2

We may assume this without loss of generality, because if a decision node has only one
child, we can replace the node by its child without affecting the predictions of the decision
tree.
More precisely, if NP6=P then no algorithm can solve Equation (18.1) in time polynomial
in n, d, and m.

18.2 Decision Tree Algorithms

253

and therefore all splitting rules are of the form 1[xi =1] for some feature i âˆˆ [d].
We discuss the case of real valued features in Section 18.2.3.
The algorithm works by recursive calls, with the initial call being ID3(S, [d]),
and returns a decision tree. In the pseudocode that follows, we use a call to a
procedure Gain(S, i), which receives a training set S and an index i and evaluates
the gain of a split of the tree according to the ith feature. We describe several
gain measures in Section 18.2.1.
ID3(S, A)
Input: training set S, feature subset A âŠ† [d]
if all examples in S are labeled by 1, return a leaf 1
if all examples in S are labeled by 0, return a leaf 0
if A = âˆ…, return a leaf whose value = majority of labels in S
else :
Let j = argmaxiâˆˆA Gain(S, i)
if all examples in S have the same label
Return a leaf whose value = majority of labels in S
else
Let T1 be the tree returned by ID3({(x, y) âˆˆ S : xj = 1}, A \ {j}).
Let T2 be the tree returned by ID3({(x, y) âˆˆ S : xj = 0}, A \ {j}).
Return the tree:
xj = 1?

T2

18.2.1

T1

Implementations of the Gain Measure
Different algorithms use different implementations of Gain(S, i). Here we present
three. We use the notation PS [F ] to denote the probability that an event holds
with respect to the uniform distribution over S.
Train Error: The simplest definition of gain is the decrease in training error.
Formally, let C(a) = min{a, 1âˆ’a}. Note that the training error before splitting on
feature i is C(PS [y = 1]), since we took a majority vote among labels. Similarly,
the error after splitting on feature i is
P[xi = 1] C(P[y = 1|xi = 1]) + P[xi = 0]C(P[y = 1|xi = 0]).
S

S

S

S

Therefore, we can define Gain to be the difference between the two, namely,
Gain(S, i) := C(P[y = 1])
S


âˆ’ P[xi = 1] C(P[y = 1|xi = 1]) + P[xi = 0]C(P[y = 1|xi = 0]) .
S

S

S

S

254

Decision Trees

Information Gain: Another popular gain measure that is used in the ID3
and C4.5 algorithms of Quinlan (1993) is the information gain. The information
gain is the difference between the entropy of the label before and after the split,
and is achieved by replacing the function C in the previous expression by the
entropy function,
C(a) = âˆ’a log(a) âˆ’ (1 âˆ’ a) log(1 âˆ’ a).
Gini Index: Yet another definition of a gain, which is used by the CART
algorithm of Breiman, Friedman, Olshen & Stone (1984), is the Gini index,
C(a) = 2a(1 âˆ’ a).
Both the information gain and the Gini index are smooth and concave upper
bounds of the train error. These properties can be advantageous in some situations (see, for example, Kearns & Mansour (1996)).

18.2.2

Pruning
The ID3 algorithm described previously still suffers from a big problem: The
returned tree will usually be very large. Such trees may have low empirical risk,
but their true risk will tend to be high â€“ both according to our theoretical
analysis, and in practice. One solution is to limit the number of iterations of ID3,
leading to a tree with a bounded number of nodes. Another common solution is
to prune the tree after it is built, hoping to reduce it to a much smaller tree,
but still with a similar empirical error. Theoretically, according to the bound in
Equation (18.1), if we can make n much smaller without increasing LS (h) by
much, we are likely to get a decision tree with a smaller true risk.
Usually, the pruning is performed by a bottom-up walk on the tree. Each node
might be replaced with one of its subtrees or with a leaf, based on some bound
or estimate of LD (h) (for example, the bound in Equation (18.1)). A pseudocode
of a common template is given in the following.
Generic Tree Pruning Procedure
input:
function f (T, m) (bound/estimate for the generalization error
of a decision tree T , based on a sample of size m),
tree T .
foreach node j in a bottom-up walk on T (from leaves to root):
find T 0 which minimizes f (T 0 , m), where T 0 is any of the following:
the current tree after replacing node j with a leaf 1.
the current tree after replacing node j with a leaf 0.
the current tree after replacing node j with its left subtree.
the current tree after replacing node j with its right subtree.
the current tree.
let T := T 0 .

18.3 Random Forests

18.2.3

255

Threshold-Based Splitting Rules for Real-Valued Features
In the previous section we have described an algorithm for growing a decision
tree assuming that the features are binary and the splitting rules are of the
form 1[xi =1] . We now extend this result to the case of real-valued features and
threshold-based splitting rules, namely, 1[xi <Î¸] . Such splitting rules yield decision
stumps, and we have studied them in Chapter 10.
The basic idea is to reduce the problem to the case of binary features as
follows. Let x1 , . . . , xm be the instances of the training set. For each real-valued
feature i, sort the instances so that x1,i â‰¤ Â· Â· Â· â‰¤ xm,i . Define a set of thresholds
Î¸0,i , . . . , Î¸m+1,i such that Î¸j,i âˆˆ (xj,i , xj+1,i ) (where we use the convention x0,i =
âˆ’âˆž and xm+1,i = âˆž). Finally, for each i and j we define the binary feature
1[xi <Î¸j,i ] . Once we have constructed these binary features, we can run the ID3
procedure described in the previous section. It is easy to verify that for any
decision tree with threshold-based splitting rules over the original real-valued
features there exists a decision tree over the constructed binary features with
the same training error and the same number of nodes.
If the original number of real-valued features is d and the number of examples
is m, then the number of constructed binary features becomes dm. Calculating
the Gain of each feature might therefore take O(dm2 ) operations. However, using
a more clever implementation, the runtime can be reduced to O(dm log(m)). The
idea is similar to the implementation of ERM for decision stumps as described
in Section 10.1.1.

18.3

Random Forests
As mentioned before, the class of decision trees of arbitrary size has infinite VC
dimension. We therefore restricted the size of the decision tree. Another way
to reduce the danger of overfitting is by constructing an ensemble of trees. In
particular, in the following we describe the method of random forests, introduced
by Breiman (2001).
A random forest is a classifier consisting of a collection of decision trees, where
each tree is constructed by applying an algorithm A on the training set S and
an additional random vector, Î¸, where Î¸ is sampled i.i.d. from some distribution.
The prediction of the random forest is obtained by a majority vote over the
predictions of the individual trees.
To specify a particular random forest, we need to define the algorithm A and
the distribution over Î¸. There are many ways to do this and here we describe one
particular option. We generate Î¸ as follows. First, we take a random subsample
from S with replacements; namely, we sample a new training set S 0 of size m0
using the uniform distribution over S. Second, we construct a sequence I1 , I2 , . . .,
where each It is a subset of [d] of size k, which is generated by sampling uniformly
at random elements from [d]. All these random variables form the vector Î¸. Then,

256

Decision Trees

the algorithm A grows a decision tree (e.g., using the ID3 algorithm) based on
the sample S 0 , where at each splitting stage of the algorithm, the algorithm is
restricted to choosing a feature that maximizes Gain from the set It . Intuitively,
if k is small, this restriction may prevent overfitting.

18.4

Summary
Decision trees are very intuitive predictors. Typically, if a human programmer
creates a predictor it will look like a decision tree. We have shown that the VC
dimension of decision trees with k leaves is k and proposed the MDL paradigm
for learning decision trees. The main problem with decision trees is that they
are computationally hard to learn; therefore we described several heuristic procedures for training them.

18.5

Bibliographic Remarks
Many algorithms for learning decision trees (such as ID3 and C4.5) have been
derived by Quinlan (1986). The CART algorithm is due to Breiman et al. (1984).
Random forests were introduced by Breiman (2001). For additional reading we
refer the reader to (Hastie, Tibshirani & Friedman 2001, Rokach 2007).
The proof of the hardness of training decision trees is given in Hyafil & Rivest
(1976).

18.6

Exercises
1. 1. Show that any binary classifier h : {0, 1}d 7â†’ {0, 1} can be implemented
as a decision tree of height at most d + 1, with internal nodes of the form
(xi = 0?) for some i âˆˆ {1, . . . , d}.
2. Conclude that the VC dimension of the class of decision trees over the
domain {0, 1}d is 2d .
2. (Suboptimality of ID3)
Consider the following training set, where X = {0, 1}3 and Y = {0, 1}:
((1, 1, 1), 1)
((1, 0, 0), 1)
((1, 1, 0), 0)
((0, 0, 1), 0)
Suppose we wish to use this training set in order to build a decision tree of
depth 2 (i.e., for each input we are allowed to ask two questions of the form
(xi = 0?) before deciding on the label).

18.6 Exercises

257

1. Suppose we run the ID3 algorithm up to depth 2 (namely, we pick the root
node and its children according to the algorithm, but instead of keeping
on with the recursion, we stop and pick leaves according to the majority
label in each subtree). Assume that the subroutine used to measure the
quality of each feature is based on the entropy function (so we measure the
information gain), and that if two features get the same score, one of them
is picked arbitrarily. Show that the training error of the resulting decision
tree is at least 1/4.
2. Find a decision tree of depth 2 that attains zero training error.

19 Nearest Neighbor

Nearest Neighbor algorithms are among the simplest of all machine learning
algorithms. The idea is to memorize the training set and then to predict the
label of any new instance on the basis of the labels of its closest neighbors in
the training set. The rationale behind such a method is based on the assumption
that the features that are used to describe the domain points are relevant to
their labelings in a way that makes close-by points likely to have the same label.
Furthermore, in some situations, even when the training set is immense, finding
a nearest neighbor can be done extremely fast (for example, when the training
set is the entire Web and distances are based on links).
Note that, in contrast with the algorithmic paradigms that we have discussed
so far, like ERM, SRM, MDL, or RLM, that are determined by some hypothesis
class, H, the Nearest Neighbor method figures out a label on any test point
without searching for a predictor within some predefined class of functions.
In this chapter we describe Nearest Neighbor methods for classification and
regression problems. We analyze their performance for the simple case of binary
classification and discuss the efficiency of implementing these methods.

19.1

k Nearest Neighbors
Throughout the entire chapter we assume that our instance domain, X , is endowed with a metric function Ï. That is, Ï : X Ã—X â†’ R is a function that returns
the distance between any two elements of X . For example,
if X = Rd then Ï can
qP
d
0 2
be the Euclidean distance, Ï(x, x0 ) = kx âˆ’ x0 k =
i=1 (xi âˆ’ xi ) .
Let S = (x1 , y1 ), . . . , (xm , ym ) be a sequence of training examples. For each
x âˆˆ X , let Ï€1 (x), . . . , Ï€m (x) be a reordering of {1, . . . , m} according to their
distance to x, Ï(x, xi ). That is, for all i < m,
Ï(x, xÏ€i (x) ) â‰¤ Ï(x, xÏ€i+1 (x) ).
For a number k, the k-NN rule for binary classification is defined as follows:
c 2014 by Shai Shalev-Shwartz and Shai Ben-David
Understanding Machine Learning, 
Published 2014 by Cambridge University Press.
Personal use only. Not for distribution. Do not post.
Please link to http://www.cs.huji.ac.il/~shais/UnderstandingMachineLearning

19.2 Analysis

259

Figure 19.1 An illustration of the decision boundaries of the 1-NN rule. The points

depicted are the sample points, and the predicted label of any new point will be the
label of the sample point in the center of the cell it belongs to. These cells are called a
Voronoi Tessellation of the space.

k-NN
input: a training sample S = (x1 , y1 ), . . . , (xm , ym )
output: for every point x âˆˆ X ,
return the majority label among {yÏ€i (x) : i â‰¤ k}
When k = 1, we have the 1-NN rule:
hS (x) = yÏ€1 (x) .
A geometric illustration of the 1-NN rule is given in Figure 19.1.
For regression problems, namely, Y = R, one can define the prediction to be
Pk
the average target of the k nearest neighbors. That is, hS (x) = k1 i=1 yÏ€i (x) .
More generally, for some function Ï† : (X Ã— Y)k â†’ Y, the k-NN rule with respect
to Ï† is:

hS (x) = Ï† (xÏ€1 (x) , yÏ€1 (x) ), . . . , (xÏ€k (x) , yÏ€k (x) ) .
(19.1)
It is easy to verify that we can cast the prediction by majority of labels (for
classification) or by the averaged target (for regression) as in Equation (19.1) by
an appropriate choice of Ï†. The generality can lead to other rules; for example, if
Y = R, we can take a weighted average of the targets according to the distance
from x:
k
X
Ï(x, xÏ€i (x) )
yÏ€i (x) .
hS (x) =
Pk
j=1 Ï(x, xÏ€j (x) )
i=1

19.2

Analysis
Since the NN rules are such natural learning methods, their generalization properties have been extensively studied. Most previous results are asymptotic consistency results, analyzing the performance of NN rules when the sample size, m,

260

Nearest Neighbor

goes to infinity, and the rate of convergence depends on the underlying distribution. As we have argued in Section 7.4, this type of analysis is not satisfactory.
One would like to learn from finite training samples and to understand the generalization performance as a function of the size of such finite training sets and
clear prior assumptions on the data distribution. We therefore provide a finitesample analysis of the 1-NN rule, showing how the error decreases as a function
of m and how it depends on properties of the distribution. We will also explain
how the analysis can be generalized to k-NN rules for arbitrary values of k. In
particular, the analysis specifies the number of examples required to achieve a
true error of 2LD (h? ) + , where h? is the Bayes optimal hypothesis, assuming
that the labeling rule is â€œwell behavedâ€ (in a sense we will define later).

19.2.1

A Generalization Bound for the 1-NN Rule
We now analyze the true error of the 1-NN rule for binary classification with
the 0-1 loss, namely, Y = {0, 1} and `(h, (x, y)) = 1[h(x)6=y] . We also assume
throughout the analysis that X = [0, 1]d and Ï is the Euclidean distance.
We start by introducing some notation. Let D be a distribution over X Ã— Y.
Let DX denote the induced marginal distribution over X and let Î· : Rd â†’ R be
the conditional probability1 over the labels, that is,
Î·(x) = P[y = 1|x].
Recall that the Bayes optimal rule (that is, the hypothesis that minimizes LD (h)
over all functions) is
h? (x) = 1[Î·(x)>1/2] .
We assume that the conditional probability function Î· is c-Lipschitz for some
c > 0: Namely, for all x, x0 âˆˆ X , |Î·(x) âˆ’ Î·(x0 )| â‰¤ c kx âˆ’ x0 k. In other words, this
assumption means that if two vectors are close to each other then their labels
are likely to be the same.
The following lemma applies the Lipschitzness of the conditional probability
function to upper bound the true error of the 1-NN rule as a function of the
expected distance between each test instance and its nearest neighbor in the
training set.
lemma 19.1 Let X = [0, 1]d , Y = {0, 1}, and D be a distribution over X Ã— Y
for which the conditional probability function, Î·, is a c-Lipschitz function. Let
S = (x1 , y1 ), . . . , (xm , ym ) be an i.i.d. sample and let hS be its corresponding
1-NN hypothesis. Let h? be the Bayes optimal rule for Î·. Then,
E [LD (hS )] â‰¤ 2 LD (h? ) + c

Sâˆ¼D m
1

Formally, P[y = 1|x] = limÎ´â†’0
centered around x.

E

Sâˆ¼D m ,xâˆ¼D

D({(x0 ,1):x0 âˆˆB(x,Î´)})
,
D({(x0 ,y):x0 âˆˆB(x,Î´),yâˆˆY})

[kx âˆ’ xÏ€1 (x) k].

where B(x, Î´) is a ball of radius Î´

19.2 Analysis

261

Proof Since LD (hS ) = E(x,y)âˆ¼D [1[hS (x)6=y] ], we obtain that ES [LD (hS )] is the
probability to sample a training set S and an additional example (x, y), such
that the label of Ï€1 (x) is different from y. In other words, we can first sample
m unlabeled examples, Sx = (x1 , . . . , xm ), according to DX , and an additional
unlabeled example, x âˆ¼ DX , then find Ï€1 (x) to be the nearest neighbor of x in
Sx , and finally sample y âˆ¼ Î·(x) and yÏ€1 (x) âˆ¼ Î·(Ï€1 (x)). It follows that
E[LD (hS )] =
S

=

E


m ,xâˆ¼D ,yâˆ¼Î·(x),y 0 âˆ¼Î·(Ï€ (x))
Sx âˆ¼DX
1
X

E

m ,xâˆ¼D
Sx âˆ¼DX
X

[1[y6=y0 ] ]

[y =
6 y] .
0

P

yâˆ¼Î·(x),y 0 âˆ¼Î·(Ï€1 (x))

(19.2)

We next upper bound Pyâˆ¼Î·(x),y0 âˆ¼Î·(x0 ) [y 6= y 0 ] for any two domain points x, x0 :
[y 6= y 0 ] = Î·(x0 )(1 âˆ’ Î·(x)) + (1 âˆ’ Î·(x0 ))Î·(x)

P

yâˆ¼Î·(x),y 0 âˆ¼Î·(x0 )

= (Î·(x) âˆ’ Î·(x) + Î·(x0 ))(1 âˆ’ Î·(x))
+ (1 âˆ’ Î·(x) + Î·(x) âˆ’ Î·(x0 ))Î·(x)
= 2Î·(x)(1 âˆ’ Î·(x)) + (Î·(x) âˆ’ Î·(x0 ))(2Î·(x) âˆ’ 1).
Using |2Î·(x) âˆ’ 1| â‰¤ 1 and the assumption that Î· is c-Lipschitz, we obtain that
the probability is at most:
[y 6= y 0 ] â‰¤ 2Î·(x)(1 âˆ’ Î·(x)) + c kx âˆ’ x0 k.

P

yâˆ¼Î·(x),y 0 âˆ¼Î·(x0 )

Plugging this into Equation (19.2) we conclude that
E[LD (hS )] â‰¤ E[2Î·(x)(1 âˆ’ Î·(x))] + c E [kx âˆ’ xÏ€1 (x) k].
x

S

S,x

Finally, the error of the Bayes optimal classifier is
LD (h? ) = E[min{Î·(x), 1 âˆ’ Î·(x)}] â‰¥ E[Î·(x)(1 âˆ’ Î·(x))].
x

x

Combining the preceding two inequalities concludes our proof.
The next step is to bound the expected distance between a random x and its
closest element in S. We first need the following general probability lemma. The
lemma bounds the probability weight of subsets that are not hit by a random
sample, as a function of the size of that sample.
lemma 19.2 Let C1 , . . . , Cr be a collection of subsets of some domain set, X .
Let S be a sequence of m points sampled i.i.d. according to some probability
distribution, D over X . Then,
ï£®
ï£¹
X
r
E ï£°
P[Ci ]ï£» â‰¤
.
Sâˆ¼D m
me
i:Ci âˆ©S=âˆ…

262

Nearest Neighbor

Proof

From the linearity of expectation, we can rewrite:
ï£®
ï£¹
r
X
X


Eï£°
P[Ci ]ï£» =
P[Ci ] E 1[Ci âˆ©S=âˆ…] .
S

S

i=1

i:Ci âˆ©S=âˆ…

Next, for each i we have


E 1[Ci âˆ©S=âˆ…] = P[Ci âˆ© S = âˆ…] = (1 âˆ’ P[Ci ])m â‰¤ eâˆ’ P[Ci ] m .
S

S

Combining the preceding two equations we get
ï£®
ï£¹
r
X
X
Eï£°
P[Ci ]ï£» â‰¤
P[Ci ] eâˆ’ P[Ci ] m â‰¤ r max P[Ci ] eâˆ’ P[Ci ] m .
S

i

i=1

i:Ci âˆ©S=âˆ…

Finally, by a standard calculus, maxa aeâˆ’ma â‰¤

1
me

and this concludes the proof.

Equipped with the preceding lemmas we are now ready to state and prove the
main result of this section â€“ an upper bound on the expected error of the 1-NN
learning rule.
theorem 19.3 Let X = [0, 1]d , Y = {0, 1}, and D be a distribution over X Ã— Y
for which the conditional probability function, Î·, is a c-Lipschitz function. Let
hS denote the result of applying the 1-NN rule to a sample S âˆ¼ Dm . Then,
1
âˆš
âˆ’
E m [LD (hS )] â‰¤ 2 LD (h? ) + 4 c d m d+1 .
Sâˆ¼D

Proof Fix some  = 1/T , for some integer T , let r = T d and let C1 , . . . , Cr be the
cover of the set X using boxes of length : Namely, for every (Î±1 , . . . , Î±d ) âˆˆ [T ]d ,
there exists a set Ci of the form {x : âˆ€j, xj âˆˆ [(Î±j âˆ’ 1)/T, Î±j /T ]}. An illustration
for d = 2, T = 5 and the set corresponding to Î± = (2, 4) is given in the following.
1

1

âˆš
âˆš
For each x, x0 in the same box we have kxâˆ’x0 k â‰¤ d . Otherwise, kxâˆ’x0 k â‰¤ d.
Therefore,
ï£® ï£®
ï£¹
ï£®
ï£¹
ï£¹
[
[
âˆš
âˆš
Ci ï£» d + P ï£°
Ci ï£»  dï£» ,
E [kx âˆ’ xÏ€1 (x) k] â‰¤ E ï£°P ï£°
x,S

S

i:Ci âˆ©S=âˆ…

i:Ci âˆ©S6=âˆ…

S
and by combining Lemma 19.2 with the trivial bound P[ i:Ci âˆ©S6=âˆ… Ci ] â‰¤ 1 we
get that
âˆš

r
+ .
E [kx âˆ’ xÏ€1 (x) k] â‰¤ d me
x,S

19.2 Analysis

263

Since the number of boxes is r = (1/)d we get that

âˆš  d âˆ’d
E [kx âˆ’ xÏ€1 (x) k] â‰¤ d 2 m e +  .
S,x

Combining the preceding with Lemma 19.1 we obtain that

âˆš  d âˆ’d
E[LD (hS )] â‰¤ 2 LD (h? ) + c d 2 m e +  .
S

Finally, setting  = 2 mâˆ’1/(d+1) and noting that
2d 2âˆ’d md/(d+1)
2d âˆ’d
+=
+ 2 mâˆ’1/(d+1)
me
me
= mâˆ’1/(d+1) (1/e + 2) â‰¤ 4mâˆ’1/(d+1)
we conclude our proof.
The theorem implies that if we first fix the data-generating distribution and
then let m go to infinity, then the error of the 1-NN rule converges to twice the
Bayes error. The analysis can be generalized to larger p
values of k, showing that
the expected error of the k-NN rule converges to (1 + 8/k) times the error of
the Bayes classifier. This is formalized in Theorem 19.5, whose proof is left as a
guided exercise.

19.2.2

The â€œCurse of Dimensionalityâ€
The upper bound given in Theorem 19.3 grows with c (the Lipschitz coefficient
of Î·) and with d, the Euclidean dimension of the domain set X . In fact, it is easy
to see that a necessary condition
for the last term in Theorem 19.3 to be smaller
âˆš
than  is that m â‰¥ (4 c d/)d+1 . That is, the size of the training set should
increase exponentially with the dimension. The following theorem tells us that
this is not just an artifact of our upper bound, but, for some distributions, this
amount of examples is indeed necessary for learning with the NN rule.
theorem 19.4 For any c > 1, and every learning rule, L, there exists a
distribution over [0, 1]d Ã— {0, 1}, such that Î·(x) is c-Lipschitz, the Bayes error of
the distribution is 0, but for sample sizes m â‰¤ (c + 1)d /2, the true error of the
rule L is greater than 1/4.
Proof Fix any values of c and d. Let Gdc be the grid on [0, 1]d with distance of
1/c between points on the grid. That is, each point on the grid is of the form
(a1 /c, . . . , ad /c) where ai is in {0, . . . , c âˆ’ 1, c}. Note that, since any two distinct
points on this grid are at least 1/c apart, any function Î· : GD
C â†’ [0, 1] is a
c-Lipschitz function. It follows that the set of all c-Lipschitz functions over Gdc
contains the set of all binary valued functions over that domain. We can therefore
invoke the No-Free-Lunch result (Theorem 5.1) to obtain a lower bound on the
needed sample sizes for learning that class. The number of points on the grid is
(c + 1)d ; hence, if m < (c + 1)d /2, Theorem 5.1 implies the lower bound we are
after.

264

Nearest Neighbor

The exponential dependence on the dimension is known as the curse of dimensionality. As we saw, the 1-NN rule might fail if the number of examples is
smaller than â„¦((c+1)d ). Therefore, while the 1-NN rule does not restrict itself to
a predefined set of hypotheses, it still relies on some prior knowledge â€“ its success
depends on the assumption that the dimension and the Lipschitz constant of the
underlying distribution, Î·, are not too high.

19.3

Efficient Implementation*
Nearest Neighbor is a learning-by-memorization type of rule. It requires the
entire training data set to be stored, and at test time, we need to scan the entire
data set in order to find the neighbors. The time of applying the NN rule is
therefore Î˜(d m). This leads to expensive computation at test time.
When d is small, several results from the field of computational geometry have
proposed data structures that enable to apply the NN rule in time o(dO(1) log(m)).
However, the space required by these data structures is roughly mO(d) , which
makes these methods impractical for larger values of d.
To overcome this problem, it was suggested to improve the search method by
allowing an approximate search. Formally, an r-approximate search procedure is
guaranteed to retrieve a point within distance of at most r times the distance
to the nearest neighbor. Three popular approximate algorithms for NN are the
kd-tree, balltrees, and locality-sensitive hashing (LSH). We refer the reader, for
example, to (Shakhnarovich, Darrell & Indyk 2006).

19.4

Summary
The k-NN rule is a very simple learning algorithm that relies on the assumption
that â€œthings that look alike must be alike.â€ We formalized this intuition using
the Lipschitzness of the conditional probability. We have shown that with a sufficiently large training set, the risk of the 1-NN is upper bounded by twice the
risk of the Bayes optimal rule. We have also derived a lower bound that shows
the â€œcurse of dimensionalityâ€ â€“ the required sample size might increase exponentially with the dimension. As a result, NN is usually performed in practice
after a dimensionality reduction preprocessing step. We discuss dimensionality
reduction techniques later on in Chapter 23.

19.5

Bibliographic Remarks
Cover & Hart (1967) gave the first analysis of 1-NN, showing that its risk converges to twice the Bayes optimal error under mild conditions. Following a lemma
due to Stone (1977), Devroye & GyoÌˆrfi (1985) have shown that the k-NN rule

19.6 Exercises

265

is consistent (with respect to the hypothesis class of all functions from Rd to
{0, 1}). A good presentation of the analysis is given in the book of Devroye et al.
(1996). Here, we give a finite sample guarantee that explicitly underscores the
prior assumption on the distribution. See Section 7.4 for a discussion on consistency results. Finally, Gottlieb, Kontorovich & Krauthgamer (2010) derived
another finite sample bound for NN that is more similar to VC bounds.

19.6

Exercises
In this exercise we will prove the following theorem for the k-NN rule.
theorem 19.5 Let X = [0, 1]d , Y = {0, 1}, and D be a distribution over X Ã— Y
for which the conditional probability function, Î·, is a c-Lipschitz function. Let hS
denote the result of applying the k-NN rule to a sample S âˆ¼ Dm , where k â‰¥ 10.
Let h? be the Bayes optimal hypothesis. Then,
r !

 âˆš
8
LD (h? ) + 6 c d + k mâˆ’1/(d+1) .
E[LD (hS )] â‰¤ 1 +
S
k
1. Prove the following lemma.
lemma 19.6 Let C1 , . . . , Cr be a collection of subsets of some domain set,
X . Let S be a sequence of m points sampled i.i.d. according to some probability
distribution, D over X . Then, for every k â‰¥ 2,
ï£®
ï£¹
X
2rk
P[Ci ]ï£» â‰¤
E ï£°
.
Sâˆ¼D m
m
i:|Ci âˆ©S|<k

Hints:
â€¢ Show that
ï£®
Eï£°
S

ï£¹
X

P[Ci ]ï£» =

r
X
i=1

i:|Ci âˆ©S|<k

P[Ci ] P [|Ci âˆ© S| < k] .
S

â€¢ Fix some i and suppose that k < P[Ci ] m/2. Use Chernoffâ€™s bound to show
that
P [|Ci âˆ© S| < k] â‰¤ P [|Ci âˆ© S| < P[Ci ]m/2] â‰¤ eâˆ’ P[Ci ] m/8 .
S

S

â€¢ Use the inequality maxa aeâˆ’ma â‰¤

1
me

to show that for such i we have

P[Ci ] P [|Ci âˆ© S| < k] â‰¤ P[Ci ]eâˆ’ P[Ci ] m/8 â‰¤
S

8
.
me

â€¢ Conclude the proof by using the fact that for the case k â‰¥ P[Ci ] m/2 we
clearly have:
2k
P[Ci ] P [|Ci âˆ© S| < k] â‰¤ P[Ci ] â‰¤
.
S
m

266

Nearest Neighbor

2. We use the notation y âˆ¼ p as a shorthand for â€œy is a Bernoulli random variable
with expected value p.â€ Prove the following lemma:
lemma 19.7 Let k â‰¥ 10 and let Z1 , . . . , Zk be independent Bernoulli random
P
Pk
variables with P[Zi = 1] = pi . Denote p = k1 i pi and p0 = k1 i=1 Zi . Show
that
r !
8
P [y 6= 1[p>1/2] ].
E
P [y 6= 1[p0 >1/2] ] â‰¤ 1 +
Z1 ,...,Zk yâˆ¼p
k yâˆ¼p
Hints:
W.l.o.g. assume that p â‰¤ 1/2. Then, Pyâˆ¼p [y 6= 1[p>1/2] ] = p. Let y 0 = 1[p0 >1/2] .
â€¢ Show that
P [y 6= y 0 ] âˆ’ p =

E

Z1 ,...,Zk yâˆ¼p

P

Z1 ,...,Zk

[p0 > 1/2](1 âˆ’ 2p).

â€¢ Use Chernoffâ€™s bound (Lemma B.3) to show that
P[p0 > 1/2] â‰¤ eâˆ’k p h( 2p âˆ’1) ,
1

where
h(a) = (1 + a) log(1 + a) âˆ’ a.
â€¢ To conclude the proof of the lemma, you can rely on the following inequality
(without proving it): For every p âˆˆ [0, 1/2] and k â‰¥ 10:
r
8
(log(2p)+1)
âˆ’k p + k
2
â‰¤
p.
(1 âˆ’ 2p) e
k
3. Fix some p, p0 âˆˆ [0, 1] and y 0 âˆˆ {0, 1}. Show that
P [y 6= y 0 ] â‰¤ P 0 [y 6= y 0 ] + |p âˆ’ p0 |.

yâˆ¼p

yâˆ¼p

4. Conclude the proof of the theorem according to the following steps:
â€¢ As in the proof of Theorem 19.3, six some  > 0 and let C1 , . . . , Cr be the
cover of the set X usingâˆšboxes of length . For each x,âˆšx0 in the same
box we have kx âˆ’ x0 k â‰¤ d . Otherwise, kx âˆ’ x0 k â‰¤ 2 d. Show that
ï£®
ï£¹
X
E[LD (hS )] â‰¤ E ï£°
P[Ci ]ï£»
S

S

+ max
i

i:|Ci âˆ©S|<k

h
P

S,(x,y)

âˆš i
hS (x) 6= y | âˆ€j âˆˆ [k], kx âˆ’ xÏ€j (x) k â‰¤  d . (19.3)

â€¢ Bound the first summand using Lemma 19.6.
â€¢ To bound the second summand, let us fix S|x and x âˆš
such that all the k
neighbors of x in S|x are at distance of at most  d from x. W.l.o.g
assume that the k NN are x1 , . . . , xk . Denote pi = Î·(xi ) and let p =
P
1
i pi . Use Exercise 3 to show that
k
E

P [hS (x) 6= y] â‰¤

y1 ,...,yj yâˆ¼Î·(x)

E

P [hS (x) 6= y] + |p âˆ’ Î·(x)|.

y1 ,...,yj yâˆ¼p

19.6 Exercises

267

W.l.o.g. assume that p â‰¤ 1/2. Now use Lemma 19.7 to show that
r !
8
P [hS (x) 6= y] â‰¤ 1 +
P
P [1[p>1/2] 6= y].
y1 ,...,yj yâˆ¼p
k yâˆ¼p
â€¢ Show that
P [1[p>1/2] 6= y] = p = min{p, 1 âˆ’ p} â‰¤ min{Î·(x), 1 âˆ’ Î·(x)} + |p âˆ’ Î·(x)|.

yâˆ¼p

â€¢ Combine all the preceding to obtain that the second summand in Equation (19.3) is bounded by
r !
âˆš
8
LD (h? ) + 3 c  d.
1+
k
â€¢ Use r = (2/)d to obtain that:
r !
âˆš
8
2(2/)d k
E[LD (hS )] â‰¤ 1 +
LD (h? ) + 3 c  d +
.
S
k
m
Set  = 2mâˆ’1/(d+1) and use

âˆš
2k âˆ’1/(d+1)  âˆš
6 c mâˆ’1/(d+1) d +
m
â‰¤ 6c d + k mâˆ’1/(d+1)
e
to conclude the proof.

20 Neural Networks

An artificial neural network is a model of computation inspired by the structure
of neural networks in the brain. In simplified models of the brain, it consists of
a large number of basic computing devices (neurons) that are connected to each
other in a complex communication network, through which the brain is able to
carry out highly complex computations. Artificial neural networks are formal
computation constructs that are modeled after this computation paradigm.
Learning with neural networks was proposed in the mid-20th century. It yields
an effective learning paradigm and has recently been shown to achieve cuttingedge performance on several learning tasks.
A neural network can be described as a directed graph whose nodes correspond
to neurons and edges correspond to links between them. Each neuron receives
as input a weighted sum of the outputs of the neurons connected to its incoming
edges. We focus on feedforward networks in which the underlying graph does not
contain cycles.
In the context of learning, we can define a hypothesis class consisting of neural
network predictors, where all the hypotheses share the underlying graph structure of the network and differ in the weights over edges. As we will show in
Section 20.3, every predictor over n variables that can be implemented in time
T (n) can also be expressed as a neural network predictor of size O(T (n)2 ), where
the size of the network is the number of nodes in it. It follows that the family
of hypothesis classes of neural networks of polynomial size can suffice for all
practical learning tasks, in which our goal is to learn predictors which can be
implemented efficiently. Furthermore, in Section 20.4 we will show that the sample complexity of learning such hypothesis classes is also bounded in terms of the
size of the network. Hence, it seems that this is the ultimate learning paradigm
we would want to adapt, in the sense that it both has a polynomial sample complexity and has the minimal approximation error among all hypothesis classes
consisting of efficiently implementable predictors.
The caveat is that the problem of training such hypothesis classes of neural network predictors is computationally hard. This will be formalized in Section 20.5.
A widely used heuristic for training neural networks relies on the SGD framework we studied in Chapter 14. There, we have shown that SGD is a successful
learner if the loss function is convex. In neural networks, the loss function is
highly nonconvex. Nevertheless, we can still implement the SGD algorithm and
c 2014 by Shai Shalev-Shwartz and Shai Ben-David
Understanding Machine Learning, 
Published 2014 by Cambridge University Press.
Personal use only. Not for distribution. Do not post.
Please link to http://www.cs.huji.ac.il/~shais/UnderstandingMachineLearning

20.1 Feedforward Neural Networks

269

hope it will find a reasonable solution (as happens to be the case in several
practical tasks). In Section 20.6 we describe how to implement SGD for neural
networks. In particular, the most complicated operation is the calculation of the
gradient of the loss function with respect to the parameters of the network. We
present the backpropagation algorithm that efficiently calculates the gradient.

20.1

Feedforward Neural Networks
The idea behind neural networks is that many neurons can be joined together
by communication links to carry out complex computations. It is common to
describe the structure of a neural network as a graph whose nodes are the neurons
and each (directed) edge in the graph links the output of some neuron to the
input of another neuron. We will restrict our attention to feedforward network
structures in which the underlying graph does not contain cycles.
A feedforward neural network is described by a directed acyclic graph, G =
(V, E), and a weight function over the edges, w : E â†’ R. Nodes of the graph
correspond to neurons. Each single neuron is modeled as a simple scalar function, Ïƒ : R â†’ R. We will focus on three possible functions for Ïƒ: the sign
function, Ïƒ(a) = sign(a), the threshold function, Ïƒ(a) = 1[a>0] , and the sigmoid function, Ïƒ(a) = 1/(1 + exp(âˆ’a)), which is a smooth approximation to the
threshold function. We call Ïƒ the â€œactivationâ€ function of the neuron. Each edge
in the graph links the output of some neuron to the input of another neuron.
The input of a neuron is obtained by taking a weighted sum of the outputs of
all the neurons connected to it, where the weighting is according to w.
To simplify the description of the calculation performed by the network, we
further assume that the network is organized in layers. That is, the set of nodes
can be decomposed into a union of (nonempty) disjoint subsets, V = âˆªÂ· Tt=0 Vt ,
such that every edge in E connects some node in Vtâˆ’1 to some node in Vt , for
some t âˆˆ [T ]. The bottom layer, V0 , is called the input layer. It contains n + 1
neurons, where n is the dimensionality of the input space. For every i âˆˆ [n], the
output of neuron i in V0 is simply xi . The last neuron in V0 is the â€œconstantâ€
neuron, which always outputs 1. We denote by vt,i the ith neuron of the tth layer
and by ot,i (x) the output of vt,i when the network is fed with the input vector x.
Therefore, for i âˆˆ [n] we have o0,i (x) = xi and for i = n + 1 we have o0,i (x) = 1.
We now proceed with the calculation in a layer by layer manner. Suppose we
have calculated the outputs of the neurons at layer t. Then, we can calculate
the outputs of the neurons at layer t + 1 as follows. Fix some vt+1,j âˆˆ Vt+1 .
Let at+1,j (x) denote the input to vt+1,j when the network is fed with the input
vector x. Then,
at+1,j (x) =

X
r: (vt,r ,vt+1,j )âˆˆE

w((vt,r , vt+1,j )) ot,r (x),

270

Neural Networks

and
ot+1,j (x) = Ïƒ (at+1,j (x)) .
That is, the input to vt+1,j is a weighted sum of the outputs of the neurons in Vt
that are connected to vt+1,j , where weighting is according to w, and the output
of vt+1,j is simply the application of the activation function Ïƒ on its input.
Layers V1 , . . . , VT âˆ’1 are often called hidden layers. The top layer, VT , is called
the output layer. In simple prediction problems the output layer contains a single
neuron whose output is the output of the network.
We refer to T as the number of layers in the network (excluding V0 ), or the
â€œdepthâ€ of the network. The size of the network is |V |. The â€œwidthâ€ of the
network is maxt |Vt |. An illustration of a layered feedforward neural network of
depth 2, size 10, and width 5, is given in the following. Note that there is a
neuron in the hidden layer that has no incoming edges. This neuron will output
the constant Ïƒ(0).
Input
layer
(V0 )

Hidden
layer
(V1 )

Output
layer
(V2 )

v1,1
x1

v0,1

x2

v0,2

x3

v0,3

constant

v0,4

v1,2
v1,3

v2,1

Output

v1,4
v1,5

20.2

Learning Neural Networks
Once we have specified a neural network by (V, E, Ïƒ, w), we obtain a function
hV,E,Ïƒ,w : R|V0 |âˆ’1 â†’ R|VT | . Any set of such functions can serve as a hypothesis
class for learning. Usually, we define a hypothesis class of neural network predictors by fixing the graph (V, E) as well as the activation function Ïƒ and letting
the hypothesis class be all functions of the form hV,E,Ïƒ,w for some w : E â†’ R.
The triplet (V, E, Ïƒ) is often called the architecture of the network. We denote
the hypothesis class by
HV,E,Ïƒ = {hV,E,Ïƒ,w : w is a mapping from E to R}.

(20.1)

20.3 The Expressive Power of Neural Networks

271

That is, the parameters specifying a hypothesis in the hypothesis class are the
weights over the edges of the network.
We can now study the approximation error, estimation error, and optimization
error of such hypothesis classes. In Section 20.3 we study the approximation
error of HV,E,Ïƒ by studying what type of functions hypotheses in HV,E,Ïƒ can
implement, in terms of the size of the underlying graph. In Section 20.4 we
study the estimation error of HV,E,Ïƒ , for the case of binary classification (i.e.,
VT = 1 and Ïƒ is the sign function), by analyzing its VC dimension. Finally, in
Section 20.5 we show that it is computationally hard to learn the class HV,E,Ïƒ ,
even if the underlying graph is small, and in Section 20.6 we present the most
commonly used heuristic for training HV,E,Ïƒ .

20.3

The Expressive Power of Neural Networks
In this section we study the expressive power of neural networks, namely, what
type of functions can be implemented using a neural network. More concretely,
we will fix some architecture, V, E, Ïƒ, and will study what functions hypotheses
in HV,E,Ïƒ can implement, as a function of the size of V .
We start the discussion with studying which type of Boolean functions (i.e.,
functions from {Â±1}n to {Â±1}) can be implemented by HV,E,sign . Observe that
for every computer in which real numbers are stored using b bits, whenever we
calculate a function f : Rn â†’ R on such a computer we in fact calculate a
function g : {Â±1}nb â†’ {Â±1}b . Therefore, studying which Boolean functions can
be implemented by HV,E,sign can tell us which functions can be implemented on
a computer that stores real numbers using b bits.
We begin with a simple claim, showing that without restricting the size of the
network, every Boolean function can be implemented using a neural network of
depth 2.
claim 20.1 For every n, there exists a graph (V, E) of depth 2, such that
HV,E,sign contains all functions from {Â±1}n to {Â±1}.
Proof We construct a graph with |V0 | = n + 1, |V1 | = 2n + 1, and |V2 | = 1. Let
E be all possible edges between adjacent layers. Now, let f : {Â±1}n â†’ {Â±1}
be some Boolean function. We need to show that we can adjust the weights so
that the network will implement f . Let u1 , . . . , uk be all vectors in {Â±1}n on
which f outputs 1. Observe that for every i and every x âˆˆ {Â±1}n , if x 6= ui
then hx, ui i â‰¤ n âˆ’ 2 and if x = ui then hx, ui i = n. It follows that the function
gi (x) = sign(hx, ui i âˆ’ n + 1) equals 1 if and only if x = ui . It follows that we can
adapt the weights between V0 and V1 so that for every i âˆˆ [k], the neuron v1,i
implements the function gi (x). Next, we observe that f (x) is the disjunction of

272

Neural Networks

the functions gi (x), and therefore can be written as
f (x) = sign

k
X

!
gi (x) + k âˆ’ 1 ,

i=1

which concludes our proof.

The preceding claim shows that neural networks can implement any Boolean
function. However, this is a very weak property, as the size of the resulting
network might be exponentially large. In the construction given at the proof of
Claim 20.1, the number of nodes in the hidden layer is exponentially large. This
is not an artifact of our proof, as stated in the following theorem.
theorem 20.2 For every n, let s(n) be the minimal integer such that there
exists a graph (V, E) with |V | = s(n) such that the hypothesis class HV,E,sign
contains all the functions from {0, 1}n to {0, 1}. Then, s(n) is exponential in n.
Similar results hold for HV,E,Ïƒ where Ïƒ is the sigmoid function.
Proof Suppose that for some (V, E) we have that HV,E,sign contains all functions
from {0, 1}n to {0, 1}. It follows that it can shatter the set of m = 2n vectors in
{0, 1}n and hence the VC dimension of HV,E,sign is 2n . On the other hand, the
VC dimension of HV,E,sign is bounded by O(|E| log(|E|)) â‰¤ O(|V |3 ), as we will
show in the next section. This implies that |V | â‰¥ â„¦(2n/3 ), which concludes our
proof for the case of networks with the sign activation function. The proof for
the sigmoid case is analogous.
Remark 20.1 It is possible to derive a similar theorem for HV,E,Ïƒ for any Ïƒ, as
long as we restrict the weights so that it is possible to express every weight using
a number of bits which is bounded by a universal constant. We can even consider hypothesis classes where different neurons can employ different activation
functions, as long as the number of allowed activation functions is also finite.
Which functions can we express using a network of polynomial size? The preceding claim tells us that it is impossible to express all Boolean functions using
a network of polynomial size. On the positive side, in the following we show
that all Boolean functions that can be calculated in time O(T (n)) can also be
expressed by a network of size O(T (n)2 ).
theorem 20.3 Let T : N â†’ N and for every n, let Fn be the set of functions
that can be implemented using a Turing machine using runtime of at most T (n).
Then, there exist constants b, c âˆˆ R+ such that for every n, there is a graph
(Vn , En ) of size at most c T (n)2 + b such that HVn ,En ,sign contains Fn .
The proof of this theorem relies on the relation between the time complexity
of programs and their circuit complexity (see, for example, Sipser (2006)). In a
nutshell, a Boolean circuit is a type of network in which the individual neurons

20.3 The Expressive Power of Neural Networks

273

implement conjunctions, disjunctions, and negation of their inputs. Circuit complexity measures the size of Boolean circuits required to calculate functions. The
relation between time complexity and circuit complexity can be seen intuitively
as follows. We can model each step of the execution of a computer program as a
simple operation on its memory state. Therefore, the neurons at each layer of the
network will reflect the memory state of the computer at the corresponding time,
and the translation to the next layer of the network involves a simple calculation
that can be carried out by the network. To relate Boolean circuits to networks
with the sign activation function, we need to show that we can implement the
operations of conjunction, disjunction, and negation, using the sign activation
function. Clearly, we can implement the negation operator using the sign activation function. The following lemma shows that the sign activation function can
also implement conjunctions and disjunctions of its inputs.
lemma 20.4 Suppose that a neuron v, that implements the sign activation
function, has k incoming edges, connecting it to neurons whose outputs are in
{Â±1}. Then, by adding one more edge, linking a â€œconstantâ€ neuron to v, and
by adjusting the weights on the edges to v, the output of v can implement the
conjunction or the disjunction of its inputs.
Simply observe that if f : {Â±1}k â†’ {Â±1} is the conjunction func
Pk
tion, f (x) = âˆ§i xi , then it can be written as f (x) = sign 1 âˆ’ k + i=1 xi .
Proof

Similarly,
the disjunction
function, f (x) = âˆ¨i xi , can be written as f (x) =


Pk
sign k âˆ’ 1 + i=1 xi .
So far we have discussed Boolean functions. In Exercise 1 we show that neural
networks are universal approximators. That is, for every fixed precision parameter,  > 0, and every Lipschitz function f : [âˆ’1, 1]n â†’ [âˆ’1, 1], it is possible to
construct a network such that for every input x âˆˆ [âˆ’1, 1]n , the network outputs
a number between f (x) âˆ’  and f (x) + . However, as in the case of Boolean
functions, the size of the network here again cannot be polynomial in n. This is
formalized in the following theorem, whose proof is a direct corollary of Theorem 20.2 and is left as an exercise.
theorem 20.5 Fix some  âˆˆ (0, 1). For every n, let s(n) be the minimal integer
such that there exists a graph (V, E) with |V | = s(n) such that the hypothesis class
HV,E,Ïƒ , with Ïƒ being the sigmoid function, can approximate, to within precision
of , every 1-Lipschitz function f : [âˆ’1, 1]n â†’ [âˆ’1, 1]. Then s(n) is exponential
in n.

20.3.1

Geometric Intuition
We next provide several geometric illustrations of functions f : R2 â†’ {Â±1}
and show how to express them using a neural network with the sign activation
function.

274

Neural Networks

Let us start with a depth 2 network, namely, a network with a single hidden
layer. Each neuron in the hidden layer implements a halfspace predictor. Then,
the single neuron at the output layer applies a halfspace on top of the binary
outputs of the neurons in the hidden layer. As we have shown before, a halfspace
can implement the conjunction function. Therefore, such networks contain all
hypotheses which are an intersection of k âˆ’ 1 halfspaces, where k is the number
of neurons in the hidden layer; namely, they can express all convex polytopes
with k âˆ’ 1 faces. An example of an intersection of 5 halfspaces is given in the
following.

We have shown that a neuron in layer V2 can implement a function that
indicates whether x is in some convex polytope. By adding one more layer, and
letting the neuron in the output layer implement the disjunction of its inputs,
we get a network that computes the union of polytopes. An illustration of such
a function is given in the following.

20.4

The Sample Complexity of Neural Networks
Next we discuss the sample complexity of learning the class HV,E,Ïƒ . Recall that
the fundamental theorem of learning tells us that the sample complexity of learning a hypothesis class of binary classifiers depends on its VC dimension. Therefore, we focus on calculating the VC dimension of hypothesis classes of the form
HV,E,Ïƒ , where the output layer of the graph contains a single neuron.
We start with the sign activation function, namely, with HV,E,sign . What is
the VC dimension of this class? Intuitively, since we learn |E| parameters, the
VC dimension should be order of |E|. This is indeed the case, as formalized by
the following theorem.
theorem 20.6

The VC dimension of HV,E,sign is O(|E| log(|E|)).

20.4 The Sample Complexity of Neural Networks

275

Proof To simplify the notation throughout the proof, let us denote the hypothesis class by H. Recall the definition of the growth function, Ï„H (m), from
Section 6.5.1. This function measures maxCâŠ‚X :|C|=m |HC |, where HC is the restriction of H to functions from C to {0, 1}. We can naturally extend the definition for a set of functions from X to some finite set Y, by letting HC be the
restriction of H to functions from C to Y, and keeping the definition of Ï„H (m)
intact.
Our neural network is defined by a layered graph. Let V0 , . . . , VT be the layers
of the graph. Fix some t âˆˆ [T ]. By assigning different weights on the edges
between Vtâˆ’1 and Vt , we obtain different functions from R|Vtâˆ’1 | â†’ {Â±1}|Vt | . Let
H(t) be the class of all possible such mappings from R|Vtâˆ’1 | â†’ {Â±1}|Vt | . Then,
H can be written as a composition, H = H(T ) â—¦ . . . â—¦ H(1) . In Exercise 4 we show
that the growth function of a composition of hypothesis classes is bounded by
the products of the growth functions of the individual classes. Therefore,
T
Y

Ï„H (m) â‰¤

Ï„H(t) (m).

t=1

In addition, each H(t) can be written as a product of function classes, H(t) =
H(t,1) Ã— Â· Â· Â· Ã— H(t,|Vt |) , where each H(t,j) is all functions from layer t âˆ’ 1 to {Â±1}
that the jth neuron of layer t can implement. In Exercise 3 we bound product
classes, and this yields
|Vt |

Ï„H(t) (m) â‰¤

Y

Ï„H(t,i) (m).

i=1

Let dt,i be the number of edges that are headed to the ith neuron of layer t.
Since the neuron is a homogenous halfspace hypothesis and the VC dimension
of homogenous halfspaces is the dimension of their input, we have by Sauerâ€™s
lemma that
 dt,i
â‰¤ (em)dt,i .
Ï„H(t,i) (m) â‰¤ dem
t,i
Overall, we obtained that
P

Ï„H (m) â‰¤ (em)

t,i

dt,i

= (em)|E| .

Now, assume that there are m shattered points. Then, we must have Ï„H (m) =
2m , from which we obtain
2m â‰¤ (em)|E|

â‡’

m â‰¤ |E| log(em)/ log(2).

The claim follows by Lemma A.2.
Next, we consider HV,E,Ïƒ , where Ïƒ is the sigmoid function. Surprisingly, it
turns out that the VC dimension of HV,E,Ïƒ is lower bounded by â„¦(|E|2 ) (see
Exercise 5.) That is, the VC dimension is the number of tunable parameters
squared. It is also possible to upper bound the VC dimension by O(|V |2 |E|2 ),
but the proof is beyond the scope of this book. In any case, since in practice

276

Neural Networks

we only consider networks in which the weights have a short representation as
floating point numbers with O(1) bits, by using the discretization trick we easily
obtain that such networks have a VC dimension of O(|E|), even if we use the
sigmoid activation function.

20.5

The Runtime of Learning Neural Networks
In the previous sections we have shown that the class of neural networks with an
underlying graph of polynomial size can express all functions that can be implemented efficiently, and that the sample complexity has a favorable dependence
on the size of the network. In this section we turn to the analysis of the time
complexity of training neural networks.
We first show that it is NP hard to implement the ERM rule with respect to
HV,E,sign even for networks with a single hidden layer that contain just 4 neurons
in the hidden layer.
theorem 20.7 Let k â‰¥ 3. For every n, let (V, E) be a layered graph with n
input nodes, k + 1 nodes at the (single) hidden layer, where one of them is the
constant neuron, and a single output node. Then, it is NP hard to implement the
ERM rule with respect to HV,E,sign .
The proof relies on a reduction from the k-coloring problem and is left as
Exercise 6.
One way around the preceding hardness result could be that for the purpose
of learning, it may suffice to find a predictor h âˆˆ H with low empirical error,
not necessarily an exact ERM. However, it turns out that even the task of finding weights that result in close-to-minimal empirical error is computationally
infeasible (see (Bartlett & Ben-David 2002)).
One may also wonder whether it may be possible to change the architecture
of the network so as to circumvent the hardness result. That is, maybe ERM
with respect to the original network structure is computationally hard but ERM
with respect to some other, larger, network may be implemented efficiently (see
Chapter 8 for examples of such cases). Another possibility is to use other activation functions (such as sigmoids, or any other type of efficiently computable
activation functions). There is a strong indication that all of such approaches
are doomed to fail. Indeed, under some cryptographic assumption, the problem
of learning intersections of halfspaces is known to be hard even in the representation independent model of learning (see Klivans & Sherstov (2006)). This
implies that, under the same cryptographic assumption, any hypothesis class
which contains intersections of halfspaces cannot be learned efficiently.
A widely used heuristic for training neural networks relies on the SGD framework we studied in Chapter 14. There, we have shown that SGD is a successful
learner if the loss function is convex. In neural networks, the loss function is
highly nonconvex. Nevertheless, we can still implement the SGD algorithm and

20.6 SGD and Backpropagation

277

hope it will find a reasonable solution (as happens to be the case in several
practical tasks).

20.6

SGD and Backpropagation
The problem of finding a hypothesis in HV,E,Ïƒ with a low risk amounts to the
problem of tuning the weights over the edges. In this section we show how to
apply a heuristic search for good weights using the SGD algorithm. Throughout
this section we assume that Ïƒ is the sigmoid function, Ïƒ(a) = 1/(1 + eâˆ’a ), but
the derivation holds for any differentiable scalar function.
Since E is a finite set, we can think of the weight function as a vector w âˆˆ R|E| .
Suppose the network has n input neurons and k output neurons, and denote by
hw : Rn â†’ Rk the function calculated by the network if the weight function is
defined by w. Let us denote by âˆ†(hw (x), y) the loss of predicting hw (x) when
the target is y âˆˆ Y. For concreteness, we will take âˆ† to be the squared loss,
âˆ†(hw (x), y) = 21 khw (x) âˆ’ yk2 ; however, similar derivation can be obtained for
every differentiable function. Finally, given a distribution D over the examples
domain, Rn Ã— Rk , let LD (w) be the risk of the network, namely,
LD (w) =

E

(x,y)âˆ¼D

[âˆ†(hw (x), y)] .

Recall the SGD algorithm for minimizing the risk function LD (w). We repeat
the pseudocode from Chapter 14 with a few modifications, which are relevant
to the neural network application because of the nonconvexity of the objective
function. First, while in Chapter 14 we initialized w to be the zero vector, here
we initialize w to be a randomly chosen vector with values close to zero. This
is because an initialization with the zero vector will lead all hidden neurons to
have the same weights (if the network is a full layered network). In addition,
the hope is that if we repeat the SGD procedure several times, where each time
we initialize the process with a new random vector, one of the runs will lead
to a good local minimum. Second, while a fixed step size, Î·, is guaranteed to
be good enough for convex problems, here we utilize a variable step size, Î·t , as
defined in Section 14.4.2. Because of the nonconvexity of the loss function, the
choice of the sequence Î·t is more significant, and it is tuned in practice by a trial
and error manner. Third, we output the best performing vector on a validation
set. In addition, it is sometimes helpful to add regularization on the weights,
with parameter Î». That is, we try to minimize LD (w) + Î»2 kwk2 . Finally, the
gradient does not have a closed form solution. Instead, it is implemented using
the backpropagation algorithm, which will be described in the sequel.

278

Neural Networks

SGD for Neural Networks
parameters:
number of iterations Ï„
step size sequence Î·1 , Î·2 , . . . , Î·Ï„
regularization parameter Î» > 0
input:
layered graph (V, E)
differentiable activation function Ïƒ : R â†’ R
initialize:
choose w(1) âˆˆ R|E| at random
(from a distribution s.t. w(1) is close enough to 0)
for i = 1, 2, . . . , Ï„
sample (x, y) âˆ¼ D
calculate gradient vi = backpropagation(x, y, w, (V, E), Ïƒ)
update w(i+1) = w(i) âˆ’ Î·i (vi + Î»w(i) )
output:
wÌ„ is the best performing w(i) on a validation set

Backpropagation
input:
example (x, y), weight vector w, layered graph (V, E),
activation function Ïƒ : R â†’ R
initialize:
denote layers of the graph V0 , . . . , VT where Vt = {vt,1 , . . . , vt,kt }
define Wt,i,j as the weight of (vt,j , vt+1,i )
(where we set Wt,i,j = 0 if (vt,j , vt+1,i ) âˆˆ
/ E)
forward:
set o0 = x
for t = 1, . . . , T
for i = 1, . . . , kt
Pktâˆ’1
set at,i = j=1
Wtâˆ’1,i,j otâˆ’1,j
set ot,i = Ïƒ(at,i )
backward:
set Î´ T = oT âˆ’ y
for t = T âˆ’ 1, T âˆ’ 2, . . . , 1
for i = 1, . . . , kt
Pkt+1
Î´t,i = j=1
Wt,j,i Î´t+1,j Ïƒ 0 (at+1,j )
output:
foreach edge (vtâˆ’1,j , vt,i ) âˆˆ E
set the partial derivative to Î´t,i Ïƒ 0 (at,i ) otâˆ’1,j

20.6 SGD and Backpropagation

279

Explaining How Backpropagation Calculates the Gradient:
We next explain how the backpropagation algorithm calculates the gradient of
the loss function on an example (x, y) with respect to the vector w. Let us first
recall a few definitions from vector calculus. Each element of the gradient is
the partial derivative with respect to the variable in w corresponding to one of
the edges of the network. Recall the definition of a partial derivative. Given a
function f : Rn â†’ R, the partial derivative with respect to the ith variable at w
is obtained by fixing the values of w1 , . . . , wiâˆ’1 , wi+1 , wn , which yields the scalar
function g : R â†’ R defined by g(a) = f ((w1 , . . . , wiâˆ’1 , wi + a, wi+1 , . . . , wn )),
and then taking the derivative of g at 0. For a function with multiple outputs,
f : Rn â†’ Rm , the Jacobian of f at w âˆˆ Rn , denoted Jw (f ), is the m Ã— n matrix
whose i, j element is the partial derivative of fi : Rn â†’ R w.r.t. its jth variable
at w. Note that if m = 1 then the Jacobian matrix is the gradient of the function
(represented as a row vector). Two examples of Jacobian calculations, which we
will later use, are as follows.
â€¢ Let f (w) = Aw for A âˆˆ Rm,n . Then Jw (f ) = A.
â€¢ For every n, we use the notation Ïƒ to denote the function from Rn to Rn
which applies the sigmoid function element-wise. That is, Î± = Ïƒ(Î¸) means
1
. It is easy to verify
that for every i we have Î±i = Ïƒ(Î¸i ) = 1+exp(âˆ’Î¸
i)
that JÎ¸ (Ïƒ) is a diagonal matrix whose (i, i) entry is Ïƒ 0 (Î¸i ), where Ïƒ 0 is
the derivative function of the (scalar) sigmoid function, namely, Ïƒ 0 (Î¸i ) =
1
0
(1+exp(Î¸i ))(1+exp(âˆ’Î¸i )) . We also use the notation diag(Ïƒ (Î¸)) to denote this
matrix.
The chain rule for taking the derivative of a composition of functions can be
written in terms of the Jacobian as follows. Given two functions f : Rn â†’ Rm
and g : Rk â†’ Rn , we have that the Jacobian of the composition function,
(f â—¦ g) : Rk â†’ Rm , at w, is
Jw (f â—¦ g) = Jg(w) (f )Jw (g).
For example, for g(w) = Aw, where A âˆˆ Rn,k , we have that
Jw (Ïƒ â—¦ g) = diag(Ïƒ 0 (Aw)) A.
To describe the backpropagation algorithm, let us first decompose V into the
layers of the graph, V = âˆªÂ· Tt=0 Vt . For every t, let us write Vt = {vt,1 , . . . , vt,kt },
where kt = |Vt |. In addition, for every t denote Wt âˆˆ Rkt+1 ,kt a matrix which
gives a weight to every potential edge between Vt and Vt+1 . If the edge exists in
E then we set Wt,i,j to be the weight, according to w, of the edge (vt,j , vt+1,i ).
Otherwise, we add a â€œphantomâ€ edge and set its weight to be zero, Wt,i,j = 0.
Since when calculating the partial derivative with respect to the weight of some
edge we fix all other weights, these additional â€œphantomâ€ edges have no effect
on the partial derivative with respect to existing edges. It follows that we can
assume, without loss of generality, that all edges exist, that is, E = âˆªt (Vt Ã—Vt+1 ).

280

Neural Networks

Next, we discuss how to calculate the partial derivatives with respect to the
edges from Vtâˆ’1 to Vt , namely, with respect to the elements in Wtâˆ’1 . Since we
fix all other weights of the network, it follows that the outputs of all the neurons
in Vtâˆ’1 are fixed numbers which do not depend on the weights in Wtâˆ’1 . Denote
the corresponding vector by otâˆ’1 . In addition, let us denote by `t : Rkt â†’ R the
loss function of the subnetwork defined by layers Vt , . . . , VT as a function of the
outputs of the neurons in Vt . The input to the neurons of Vt can be written as
at = Wtâˆ’1 otâˆ’1 and the output of the neurons of Vt is ot = Ïƒ(at ). That is, for
every j we have ot,j = Ïƒ(at,j ). We obtain that the loss, as a function of Wtâˆ’1 ,
can be written as
gt (Wtâˆ’1 ) = `t (ot ) = `t (Ïƒ(at )) = `t (Ïƒ(Wtâˆ’1 otâˆ’1 )).
It would be convenient to rewrite this as follows. Let wtâˆ’1 âˆˆ Rktâˆ’1 kt be the
column vector obtained by concatenating the rows of Wtâˆ’1 and then taking the
transpose of the resulting long vector. Define by Otâˆ’1 the kt Ã— (ktâˆ’1 kt ) matrix
ï£« >
ï£¶
otâˆ’1
0
Â·Â·Â·
0
ï£¬
ï£·
ï£¬ 0
o>
0 ï£·
tâˆ’1 Â· Â· Â·
ï£¬
ï£·
Otâˆ’1 = ï£¬ .
.
(20.2)
..
.. ï£·
..
ï£¬ .
ï£·
.
. ï£¸
.
ï£­ .
0

0

Â·Â·Â·

o>
tâˆ’1

Then, Wtâˆ’1 otâˆ’1 = Otâˆ’1 wtâˆ’1 , so we can also write
gt (wtâˆ’1 ) = `t (Ïƒ(Otâˆ’1 wtâˆ’1 )).
Therefore, applying the chain rule, we obtain that
Jwtâˆ’1 (gt ) = JÏƒ(Otâˆ’1 wtâˆ’1 ) (`t ) diag(Ïƒ 0 (Otâˆ’1 wtâˆ’1 )) Otâˆ’1 .
Using our notation we have ot = Ïƒ(Otâˆ’1 wtâˆ’1 ) and at = Otâˆ’1 wtâˆ’1 , which yields
Jwtâˆ’1 (gt ) = Jot (`t ) diag(Ïƒ 0 (at )) Otâˆ’1 .
Let us also denote Î´ t = Jot (`t ). Then, we can further rewrite the preceding as

0
>
Jwtâˆ’1 (gt ) = Î´t,1 Ïƒ 0 (at,1 ) o>
(20.3)
tâˆ’1 , . . . , Î´t,kt Ïƒ (at,kt ) otâˆ’1 .
It is left to calculate the vector Î´ t = Jot (`t ) for every t. This is the gradient
of `t at ot . We calculate this in a recursive manner. First observe that for the
last layer we have that `T (u) = âˆ†(u, y), where âˆ† is the loss function. Since we
assume that âˆ†(u, y) = 12 kuâˆ’yk2 we obtain that Ju (`T ) = (uâˆ’y). In particular,
Î´ T = JoT (`T ) = (oT âˆ’ y). Next, note that
`t (u) = `t+1 (Ïƒ(Wt u)).
Therefore, by the chain rule,
Ju (`t ) = JÏƒ(Wt u) (`t+1 )diag(Ïƒ 0 (Wt u))Wt .

20.7 Summary

281

In particular,
Î´ t = Jot (`t ) = JÏƒ(Wt ot ) (`t+1 )diag(Ïƒ 0 (Wt ot ))Wt
= Jot+1 (`t+1 )diag(Ïƒ 0 (at+1 ))Wt
= Î´ t+1 diag(Ïƒ 0 (at+1 ))Wt .
In summary, we can first calculate the vectors {at , ot } from the bottom of
the network to its top. Then, we calculate the vectors {Î´ t } from the top of
the network back to its bottom. Once we have all of these vectors, the partial
derivatives are easily obtained using Equation (20.3). We have thus shown that
the pseudocode of backpropagation indeed calculates the gradient.

20.7

Summary
Neural networks over graphs of size s(n) can be used to describephypothesis
classes of all predictors that can be implemented in runtime of O( s(n)). We
have also shown that their sample complexity depends polynomially on s(n)
(specifically, it depends on the number of edges in the network). Therefore, classes
of neural network hypotheses seem to be an excellent choice. Regrettably, the
problem of training the network on the basis of training data is computationally
hard. We have presented the SGD framework as a heuristic approach for training
neural networks and described the backpropagation algorithm which efficiently
calculates the gradient of the loss function with respect to the weights over the
edges.

20.8

Bibliographic Remarks
Neural networks were extensively studied in the 1980s and early 1990s, but with
mixed empirical success. In recent years, a combination of algorithmic advancements, as well as increasing computational power and data size, has led to a
breakthrough in the effectiveness of neural networks. In particular, â€œdeep networksâ€ (i.e., networks of more than 2 layers) have shown very impressive practical
performance on a variety of domains. A few examples include convolutional networks (Lecun & Bengio 1995), restricted Boltzmann machines (Hinton, Osindero
& Teh 2006), auto-encoders (Ranzato, Huang, Boureau & Lecun 2007, Bengio &
LeCun 2007, Collobert & Weston 2008, Lee, Grosse, Ranganath & Ng 2009, Le,
Ranzato, Monga, Devin, Corrado, Chen, Dean & Ng 2012), and sum-product
networks (Livni, Shalev-Shwartz & Shamir 2013, Poon & Domingos 2011). See
also (Bengio 2009) and the references therein.
The expressive power of neural networks and the relation to circuit complexity
have been extensively studied in (Parberry 1994). For the analysis of the sample
complexity of neural networks we refer the reader to (Anthony & Bartlet 1999).
Our proof technique of Theorem 20.6 is due to Kakade and Tewari lecture notes.

282

Neural Networks

Klivans & Sherstov (2006) have shown that for any c > 0, intersections of nc
halfspaces over {Â±1}n are not efficiently PAC learnable, even if we allow representation independent learning. This hardness result relies on the cryptographic
assumption that there is no polynomial time solution to the unique-shortestvector problem. As we have argued, this implies that there cannot be an efficient
algorithm for training neural networks, even if we allow larger networks or other
activation functions that can be implemented efficiently.
The backpropagation algorithm has been introduced in Rumelhart, Hinton &
Williams (1986).

20.9

Exercises
1. Neural Networks are universal approximators: Let f : [âˆ’1, 1]n â†’
[âˆ’1, 1] be a Ï-Lipschitz function. Fix some  > 0. Construct a neural network N : [âˆ’1, 1]n â†’ [âˆ’1, 1], with the sigmoid activation function, such that
for every x âˆˆ [âˆ’1, 1]n it holds that |f (x) âˆ’ N (x)| â‰¤ .
Hint: Similarly to the proof of Theorem 19.3, partition [âˆ’1, 1]n into small
boxes. Use the Lipschitzness of f to show that it is approximately constant
at each box. Finally, show that a neural network can first decide which box
the input vector belongs to, and then predict the averaged value of f at that
box.
2. Prove Theorem 20.5.
Hint: For every f : {âˆ’1, 1}n â†’ {âˆ’1, 1} construct a 1-Lipschitz function
g : [âˆ’1, 1]n â†’ [âˆ’1, 1] such that if you can approximate g then you can express
f.
3. Growth function of product: For i = 1, 2, let Fi be a set of functions from
X to Yi . Define H = F1 Ã— F2 to be the Cartesian product class. That is, for
every f1 âˆˆ F1 and f2 âˆˆ F2 , there exists h âˆˆ H such that h(x) = (f1 (x), f2 (x)).
Prove that Ï„H (m) â‰¤ Ï„F1 (m) Ï„F2 (m).
4. Growth function of composition: Let F1 be a set of functions from X
to Z and let F2 be a set of functions from Z to Y. Let H = F2 â—¦ F1 be the
composition class. That is, for every f1 âˆˆ F1 and f2 âˆˆ F2 , there exists h âˆˆ H
such that h(x) = f2 (f1 (x)). Prove that Ï„H (m) â‰¤ Ï„F2 (m)Ï„F1 (m).
5. VC of sigmoidal networks: In this exercise we show that there is a graph
(V, E) such that the VC dimension of the class of neural networks over these
graphs with the sigmoid activation function is â„¦(|E|2 ). Note that for every  >
0, the sigmoid activation function can approximate the threshold activation
function, 1[Pi xi ] , up to accuracy . To simplify the presentation, throughout
the exercise we assume that we can exactly implement the activation function
1[Pi xi >0] using a sigmoid activation function.
Fix some n.
1. Construct a network, N1 , with O(n) weights, which implements a function
from R to {0, 1}n and satisfies the following property. For every x âˆˆ {0, 1}n ,

20.9 Exercises

283

if we feed the network with the real number 0.x1 x2 . . . xn , then the output
of the network will be x.
Hint: Denote Î± = 0.x1 x2 . . . xn and observe that 10k Î± âˆ’ 0.5 is at least 0.5
if xk = 1 and is at most âˆ’0.3 if xk = âˆ’1.
2. Construct a network, N2 , with O(n) weights, which implements a function
from [n] to {0, 1}n such that N2 (i) = ei for all i. That is, upon receiving
the input i, the network outputs the vector of all zeros except 1 at the iâ€™th
neuron.
(i) (i)
(i)
3. Let Î±1 , . . . , Î±n be n real numbers such that every Î±i is of the form 0.a1 a2 . . . an ,
(i)
with aj âˆˆ {0, 1}. Construct a network, N3 , with O(n) weights, which implements a function from [n] to R, and satisfies N2 (i) = Î±i for every i âˆˆ [n].
4. Combine N1 , N3 to obtain a network that receives i âˆˆ [n] and output a(i) .
(i)
5. Construct a network N4 that receives (i, j) âˆˆ [n] Ã— [n] and outputs aj .
2
Hint: Observe that the AND function over {0, 1} can be calculated using
O(1) weights.
6. Conclude that there is a graph with O(n) weights such that the VC dimension of the resulting hypothesis class is n2 .
6. Prove Theorem 20.7.
Hint: The proof is similar to the hardness of learning intersections of halfspaces â€“ see Exercise 32 in Chapter 8.

Part III
Additional Learning Models

21 Online Learning

In this chapter we describe a different model of learning, which is called online
learning. Previously, we studied the PAC learning model, in which the learner
first receives a batch of training examples, uses the training set to learn a hypothesis, and only when learning is completed uses the learned hypothesis for
predicting the label of new examples. In our papayas learning problem, this
means that we should first buy a bunch of papayas and taste them all. Then, we
use all of this information to learn a prediction rule that determines the taste
of new papayas. In contrast, in online learning there is no separation between a
training phase and a prediction phase. Instead, each time we buy a papaya, it
is first considered a test example since we should predict whether it is going to
taste good. Then, after taking a bite from the papaya, we know the true label,
and the same papaya can be used as a training example that can help us improve
our prediction mechanism for future papayas.

Concretely, online learning takes place in a sequence of consecutive rounds.
On each online round, the learner first receives an instance (the learner buys
a papaya and knows its shape and color, which form the instance). Then, the
learner is required to predict a label (is the papaya tasty?). At the end of the
round, the learner obtains the correct label (he tastes the papaya and then knows
whether it is tasty or not). Finally, the learner uses this information to improve
his future predictions.

To analyze online learning, we follow a similar route to our study of PAC
learning. We start with online binary classification problems. We consider both
the realizable case, in which we assume, as prior knowledge, that all the labels are
generated by some hypothesis from a given hypothesis class, and the unrealizable
case, which corresponds to the agnostic PAC learning model. In particular, we
present an important algorithm called Weighted-Majority. Next, we study online
learning problems in which the loss function is convex. Finally, we present the
Perceptron algorithm as an example of the use of surrogate convex loss functions
in the online learning model.
c 2014 by Shai Shalev-Shwartz and Shai Ben-David
Understanding Machine Learning, 
Published 2014 by Cambridge University Press.
Personal use only. Not for distribution. Do not post.
Please link to http://www.cs.huji.ac.il/~shais/UnderstandingMachineLearning

288

Online Learning

21.1

Online Classification in the Realizable Case
Online learning is performed in a sequence of consecutive rounds, where at round
t the learner is given an instance, xt , taken from an instance domain X , and is
required to provide its label. We denote the predicted label by pt . After predicting
the label, the correct label, yt âˆˆ {0, 1}, is revealed to the learner. The learnerâ€™s
goal is to make as few prediction mistakes as possible during this process. The
learner tries to deduce information from previous rounds so as to improve its
predictions on future rounds.
Clearly, learning is hopeless if there is no correlation between past and present
rounds. Previously in the book, we studied the PAC model in which we assume
that past and present examples are sampled i.i.d. from the same distribution
source. In the online learning model we make no statistical assumptions regarding the origin of the sequence of examples. The sequence is allowed to be deterministic, stochastic, or even adversarially adaptive to the learnerâ€™s own behavior
(as in the case of spam e-mail filtering). Naturally, an adversary can make the
number of prediction mistakes of our online learning algorithm arbitrarily large.
For example, the adversary can present the same instance on each online round,
wait for the learnerâ€™s prediction, and provide the opposite label as the correct
label.
To make nontrivial statements we must further restrict the problem. The realizability assumption is one possible natural restriction. In the realizable case, we
assume that all the labels are generated by some hypothesis, h? : X â†’ Y. Furthermore, h? is taken from a hypothesis class H, which is known to the learner.
This is analogous to the PAC learning model we studied in Chapter 3. With this
restriction on the sequence, the learner should make as few mistakes as possible,
assuming that both h? and the sequence of instances can be chosen by an adversary. For an online learning algorithm, A, we denote by MA (H) the maximal
number of mistakes A might make on a sequence of examples which is labeled by
some h? âˆˆ H. We emphasize again that both h? and the sequence of instances
can be chosen by an adversary. A bound on MA (H) is called a mistake-bound and
we will study how to design algorithms for which MA (H) is minimal. Formally:
definition 21.1 (Mistake Bounds, Online Learnability) Let H be a hypothesis class and let A be an online learning algorithm. Given any sequence S =
(x1 , h? (y1 )), . . . , (xT , h? (yT )), where T is any integer and h? âˆˆ H, let MA (S) be
the number of mistakes A makes on the sequence S. We denote by MA (H) the
supremum of MA (S) over all sequences of the above form. A bound of the form
MA (H) â‰¤ B < âˆž is called a mistake bound. We say that a hypothesis class H is
online learnable if there exists an algorithm A for which MA (H) â‰¤ B < âˆž.
Our goal is to study which hypothesis classes are learnable in the online model,
and in particular to find good learning algorithms for a given hypothesis class.
Remark 21.1

Throughout this section and the next, we ignore the computa-

21.1 Online Classification in the Realizable Case

289

tional aspect of learning, and do not restrict the algorithms to be efficient. In
Section 21.3 and Section 21.4 we study efficient online learning algorithms.
To simplify the presentation, we start with the case of a finite hypothesis class,
namely, |H| < âˆž.
In PAC learning, we identified ERM as a good learning algorithm, in the sense
that if H is learnable then it is learnable by the rule ERMH . A natural learning
rule for online learning is to use (at any online round) any ERM hypothesis,
namely, any hypothesis which is consistent with all past examples.
Consistent
input: A finite hypothesis class H
initialize: V1 = H
for t = 1, 2, . . .
receive xt
choose any h âˆˆ Vt
predict pt = h(xt )
receive true label yt = h? (xt )
update Vt+1 = {h âˆˆ Vt : h(xt ) = yt }
The Consistent algorithm maintains a set, Vt , of all the hypotheses which
are consistent with (x1 , y1 ), . . . , (xtâˆ’1 , ytâˆ’1 ). This set is often called the version
space. It then picks any hypothesis from Vt and predicts according to this hypothesis.
Obviously, whenever Consistent makes a prediction mistake, at least one
hypothesis is removed from Vt . Therefore, after making M mistakes we have
|Vt | â‰¤ |H| âˆ’ M . Since Vt is always nonempty (by the realizability assumption it
contains h? ) we have 1 â‰¤ |Vt | â‰¤ |H| âˆ’ M . Rearranging, we obtain the following:
corollary 21.2 Let H be a finite hypothesis class. The Consistent algorithm
enjoys the mistake bound MConsistent (H) â‰¤ |H| âˆ’ 1.
It is rather easy to construct a hypothesis class and a sequence of examples on
which Consistent will indeed make |H| âˆ’ 1 mistakes (see Exercise 1). Therefore,
we present a better algorithm in which we choose h âˆˆ Vt in a smarter way. We
shall see that this algorithm is guaranteed to make exponentially fewer mistakes.
Halving
input: A finite hypothesis class H
initialize: V1 = H
for t = 1, 2, . . .
receive xt
predict pt = argmaxrâˆˆ{0,1} |{h âˆˆ Vt : h(xt ) = r}|
(in case of a tie predict pt = 1)
receive true label yt = h? (xt )
update Vt+1 = {h âˆˆ Vt : h(xt ) = yt }

290

Online Learning

theorem 21.3 Let H be a finite hypothesis class. The Halving algorithm
enjoys the mistake bound MHalving (H) â‰¤ log2 (|H|).
Proof We simply note that whenever the algorithm errs we have |Vt+1 | â‰¤ |Vt |/2,
(hence the name Halving). Therefore, if M is the total number of mistakes, we
have
1 â‰¤ |VT +1 | â‰¤ |H| 2âˆ’M .
Rearranging this inequality we conclude our proof.
Of course, Halvingâ€™s mistake bound is much better than Consistentâ€™s mistake
bound. We already see that online learning is different from PAC learningâ€”while
in PAC, any ERM hypothesis is good, in online learning choosing an arbitrary
ERM hypothesis is far from being optimal.

21.1.1

Online Learnability
We next take a more general approach, and aim at characterizing online learnability. In particular, we target the following question: What is the optimal online
learning algorithm for a given hypothesis class H?
We present a dimension of hypothesis classes that characterizes the best achievable mistake bound. This measure was proposed by Nick Littlestone and we
therefore refer to it as Ldim(H).
To motivate the definition of Ldim it is convenient to view the online learning
process as a game between two players: the learner versus the environment. On
round t of the game, the environment picks an instance xt , the learner predicts a
label pt âˆˆ {0, 1}, and finally the environment outputs the true label, yt âˆˆ {0, 1}.
Suppose that the environment wants to make the learner err on the first T rounds
of the game. Then, it must output yt = 1 âˆ’ pt , and the only question is how it
should choose the instances xt in such a way that ensures that for some h? âˆˆ H
we have yt = h? (xt ) for all t âˆˆ [T ].
A strategy for an adversarial environment can be formally described as a
binary tree, as follows. Each node of the tree is associated with an instance from
X . Initially, the environment presents to the learner the instance associated with
the root of the tree. Then, if the learner predicts pt = 1 the environment will
declare that this is a wrong prediction (i.e., yt = 0) and will traverse to the right
child of the current node. If the learner predicts pt = 0 then the environment
will set yt = 1 and will traverse to the left child. This process will continue and
at each round, the environment will present the instance associated with the
current node.
Formally, consider a complete binary tree of depth T (we define the depth of
the tree as the number of edges in a path from the root to a leaf). We have
2T +1 âˆ’ 1 nodes in such a tree, and we attach an instance to each node. Let
v1 , . . . , v2T +1 âˆ’1 be these instances. We start from the root of the tree, and set
x1 = v1 . At round t, we set xt = vit where it is the current node. At the end of

21.1 Online Classification in the Realizable Case

v1
v2

v3

v1
v2
v3

h1

h2

h3

h4

0
0
âˆ—

0
1
âˆ—

1
âˆ—
0

1
âˆ—
1

291

Figure 21.1 An illustration of a shattered tree of depth 2. The dashed path

corresponds to the sequence of examples ((v1 , 1), (v3 , 0)). The tree is shattered by
H = {h1 , h2 , h3 , h4 }, where the predictions of each hypothesis in H on the instances
v1 , v2 , v3 is given in the table (the â€™*â€™ mark means that hj (vi ) can be either 1 or 0).

round t, we go to the left child of it if yt = 0 or to the right child if yt = 1. That
Ptâˆ’1
is, it+1 = 2it +yt . Unraveling the recursion we obtain it = 2tâˆ’1 + j=1 yj 2tâˆ’1âˆ’j .
The preceding strategy for the environment succeeds only if for every (y1 , . . . , yT )
there exists h âˆˆ H such that yt = h(xt ) for all t âˆˆ [T ]. This leads to the following
definition.
definition 21.4 (H Shattered Tree) A shattered tree of depth d is a sequence
of instances v1 , . . . , v2d âˆ’1 in X such that for every labeling (y1 , . . . , yd ) âˆˆ {0, 1}d
there exists h âˆˆ H such that for all t âˆˆ [d] we have h(vit ) = yt where it =
Ptâˆ’1
2tâˆ’1 + j=1 yj 2tâˆ’1âˆ’j .
An illustration of a shattered tree of depth 2 is given in Figure 21.1.
definition 21.5 (Littlestoneâ€™s Dimension (Ldim)) Ldim(H) is the maximal
integer T such that there exists a shattered tree of depth T , which is shattered
by H.
The definition of Ldim and the discussion above immediately imply the following:
lemma 21.6 No algorithm can have a mistake bound strictly smaller than
Ldim(H); namely, for every algorithm, A, we have MA (H) â‰¥ Ldim(H).
Proof Let T = Ldim(H) and let v1 , . . . , v2T âˆ’1 be a sequence that satisfies the
requirements in the definition of Ldim. If the environment sets xt = vit and
yt = 1 âˆ’ pt for all t âˆˆ [T ], then the learner makes T mistakes while the definition
of Ldim implies that there exists a hypothesis h âˆˆ H such that yt = h(xt ) for all
t.
Let us now give several examples.
Example 21.2 Let H be a finite hypothesis class. Clearly, any tree that is shattered by H has depth of at most log2 (|H|). Therefore, Ldim(H) â‰¤ log2 (|H|).
Another way to conclude this inequality is by combining Lemma 21.6 with Theorem 21.3.
Example 21.3

Let X = {1, . . . , d} and H = {h1 , . . . , hd } where hj (x) = 1 iff

292

Online Learning

x = j. Then, it is easy to show that Ldim(H) = 1 while |H| = d can be arbitrarily
large. Therefore, this example shows that Ldim(H) can be significantly smaller
than log2 (|H|).
Example 21.4 Let X = [0, 1] and H = {x 7â†’ 1[x<a] : a âˆˆ [0, 1]}; namely, H is
the class of thresholds on the interval [0, 1]. Then, Ldim(H) = âˆž. To see this,
consider the tree
1/2
1/4
1/8

3/4
3/8

5/8

7/8

This tree is shattered by H. And, because of the density of the reals, this tree
can be made arbitrarily deep.
Lemma 21.6 states that Ldim(H) lower bounds the mistake bound of any
algorithm. Interestingly, there is a standard algorithm whose mistake bound
matches this lower bound. The algorithm is similar to the Halving algorithm.
Recall that the prediction of Halving is made according to a majority vote of
the hypotheses which are consistent with previous examples. We denoted this
set by Vt . Put another way, Halving partitions Vt into two sets: Vt+ = {h âˆˆ Vt :
h(xt ) = 1} and Vtâˆ’ = {h âˆˆ Vt : h(xt ) = 0}. It then predicts according to the
larger of the two groups. The rationale behind this prediction is that whenever
Halving makes a mistake it ends up with |Vt+1 | â‰¤ 0.5 |Vt |.
The optimal algorithm we present in the following uses the same idea, but
instead of predicting according to the larger class, it predicts according to the
class with larger Ldim.
Standard Optimal Algorithm (SOA)
input: A hypothesis class H
initialize: V1 = H
for t = 1, 2, . . .
receive xt
(r)
for r âˆˆ {0, 1} let Vt = {h âˆˆ Vt : h(xt ) = r}
(r)
predict pt = argmaxrâˆˆ{0,1} Ldim(Vt )
(in case of a tie predict pt = 1)
receive true label yt
update Vt+1 = {h âˆˆ Vt : h(xt ) = yt }
The following lemma formally establishes the optimality of the preceding algorithm.

21.1 Online Classification in the Realizable Case

lemma 21.7

293

SOA enjoys the mistake bound MSOA (H) â‰¤ Ldim(H).

Proof It suffices to prove that whenever the algorithm makes a prediction mistake we have Ldim(Vt+1 ) â‰¤ Ldim(Vt ) âˆ’ 1. We prove this claim by assuming the
contrary, that is, Ldim(Vt+1 ) = Ldim(Vt ). If this holds true, then the definition
(r)
of pt implies that Ldim(Vt ) = Ldim(Vt ) for both r = 1 and r = 0. But, then
we can construct a shaterred tree of depth Ldim(Vt ) + 1 for the class Vt , which
leads to the desired contradiction.
Combining Lemma 21.7 and Lemma 21.6 we obtain:
corollary 21.8 Let H be any hypothesis class. Then, the standard optimal
algorithm enjoys the mistake bound MSOA (H) = Ldim(H) and no other algorithm
can have MA (H) < Ldim(H).

Comparison to VC Dimension
In the PAC learning model, learnability is characterized by the VC dimension of
the class H. Recall that the VC dimension of a class H is the maximal number
d such that there are instances x1 , . . . , xd that are shattered by H. That is, for
any sequence of labels (y1 , . . . , yd ) âˆˆ {0, 1}d there exists a hypothesis h âˆˆ H
that gives exactly this sequence of labels. The following theorem relates the VC
dimension to the Littlestone dimension.
theorem 21.9 For any class H, VCdim(H) â‰¤ Ldim(H), and there are classes
for which strict inequality holds. Furthermore, the gap can be arbitrarily larger.
Proof We first prove that VCdim(H) â‰¤ Ldim(H). Suppose VCdim(H) = d and
let x1 , . . . , xd be a shattered set. We now construct a complete binary tree of
instances v1 , . . . , v2d âˆ’1 , where all nodes at depth i are set to be xi â€“ see the
following illustration:
x1
x2
x3

x2
x3

x3

x3

Now, the definition of a shattered set clearly implies that we got a valid shattered
tree of depth d, and we conclude that VCdim(H) â‰¤ Ldim(H). To show that the
gap can be arbitrarily large simply note that the class given in Example 21.4 has
VC dimension of 1 whereas its Littlestone dimension is infinite.

294

Online Learning

21.2

Online Classification in the Unrealizable Case
In the previous section we studied online learnability in the realizable case. We
now consider the unrealizable case. Similarly to the agnostic PAC model, we
no longer assume that all labels are generated by some h? âˆˆ H, but we require
the learner to be competitive with the best fixed predictor from H. This is
captured by the regret of the algorithm, which measures how â€œsorryâ€ the learner
is, in retrospect, not to have followed the predictions of some hypothesis h âˆˆ H.
Formally, the regret of an algorithm A relative to h when running on a sequence
of T examples is defined as
#
" T
T
X
X
RegretA (h, T ) =
sup
|pt âˆ’ yt | âˆ’
|h(xt ) âˆ’ yt | ,
(21.1)
(x1 ,y1 ),...,(xT ,yT )

t=1

t=1

and the regret of the algorithm relative to a hypothesis class H is
RegretA (H, T ) = sup RegretA (h, T ).

(21.2)

hâˆˆH

We restate the learnerâ€™s goal as having the lowest possible regret relative to H.
An interesting question is whether we can derive an algorithm with low regret,
meaning that RegretA (H, T ) grows sublinearly with the number of rounds, T ,
which implies that the difference between the error rate of the learner and the
best hypothesis in H tends to zero as T goes to infinity.
We first show that this is an impossible missionâ€”no algorithm can obtain a
sublinear regret bound even if |H| = 2. Indeed, consider H = {h0 , h1 }, where h0
is the function that always returns 0 and h1 is the function that always returns
1. An adversary can make the number of mistakes of any online algorithm be
equal to T , by simply waiting for the learnerâ€™s prediction and then providing
the opposite label as the true label. In contrast, for any sequence of true labels,
y1 , . . . , yT , let b be the majority of labels in y1 , . . . , yT , then the number of
mistakes of hb is at most T /2. Therefore, the regret of any online algorithm
might be at least T âˆ’ T /2 = T /2, which is not sublinear in T . This impossibility
result is attributed to Cover (Cover 1965).
To sidestep Coverâ€™s impossibility result, we must further restrict the power
of the adversarial environment. We do so by allowing the learner to randomize
his predictions. Of course, this by itself does not circumvent Coverâ€™s impossibility result, since in deriving this result we assumed nothing about the learnerâ€™s
strategy. To make the randomization meaningful, we force the adversarial environment to decide on yt without knowing the random coins flipped by the learner
on round t. The adversary can still know the learnerâ€™s forecasting strategy and
even the random coin flips of previous rounds, but it does not know the actual
value of the random coin flips used by the learner on round t. With this (mild)
change of game, we analyze the expected number of mistakes of the algorithm,
where the expectation is with respect to the learnerâ€™s own randomization. That
is, if the learner outputs yÌ‚t where P[yÌ‚t = 1] = pt , then the expected loss he pays

21.2 Online Classification in the Unrealizable Case

295

on round t is
P[yÌ‚t 6= yt ] = |pt âˆ’ yt |.
Put another way, instead of having the predictions of the learner being in {0, 1}
we allow them to be in [0, 1], and interpret pt âˆˆ [0, 1] as the probability to predict
the label 1 on round t.
With this assumption it is possible to derive a low regret algorithm. In particular, we will prove the following theorem.
theorem 21.10 For every hypothesis class H, there exists an algorithm for
online classification, whose predictions come from [0, 1], that enjoys the regret
bound

âˆ€h âˆˆ H,

T
X

|pt âˆ’yt |âˆ’

t=1

T
X

|h(xt )âˆ’yt | â‰¤

p

2 min{log(|H|) , Ldim(H) log(eT )} T .

t=1

Furthermore,
no algorithm can achieve an expected regret bound smaller than
p
â„¦
Ldim(H) T .
We will provide a constructive proof of the upper bound part of the preceding
theorem. The proof of the lower bound part can be found in (Ben-David, Pal, &
Shalev-Shwartz 2009).
The proof of Theorem 21.10 relies on the Weighted-Majority algorithm for
learning with expert advice. This algorithm is important by itself and we dedicate
the next subsection to it.

21.2.1

Weighted-Majority
Weighted-majority is an algorithm for the problem of prediction with expert advice. In this online learning problem, on round t the learner has to choose the
advice of d given experts. We also allow the learner to randomize his choice by
defining a distribution over the d experts, that is, picking a vector w(t) âˆˆ [0, 1]d ,
P (t)
(t)
with i wi = 1, and choosing the ith expert with probability wi . After the
learner chooses an expert, it receives a vector of costs, vt âˆˆ [0, 1]d , where vt,i
is the cost of following the advice of the ith expert. If the learnerâ€™s predictions are randomized, then its loss is defined to be the averaged cost, namely,
P (t)
(t)
i wi vt,i = hw , vt i. The algorithm assumes that the number of rounds T is
given. In Exercise 4 we show how to get rid of this dependence using the doubling
trick.

296

Online Learning

Weighted-Majority
input: number ofp
experts, d ; number of rounds, T
parameter: Î· = 2 log(d)/T
initialize: wÌƒ(1) = (1, . . . , 1)
for t = 1, 2, . . .
P (t)
set w(t) = wÌƒ(t) /Zt where Zt = i wÌƒi
(t)
choose expert i at random according to P[i] = wi
receive costs of all experts vt âˆˆ [0, 1]d
pay cost hw(t) , vt i
(t+1)
(t)
update rule âˆ€i, wÌƒi
= wÌƒi eâˆ’Î·vt,i
The following theorem is key for analyzing the regret bound of WeightedMajority.
theorem 21.11 Assuming that T > 2 log(d), the Weighted-Majority algorithm enjoys the bound
T
T
X
X
p
hw(t) , vt i âˆ’ min
vt,i â‰¤
2 log(d) T .
t=1

Proof

iâˆˆ[d]

t=1

We have:
(t)

log

X wÌƒ
X (t)
Zt+1
i
= log
eâˆ’Î·vt,i = log
wi eâˆ’Î·vt,i .
Zt
Z
t
i
i

Using the inequality eâˆ’a â‰¤ 1 âˆ’ a + a2 /2, which holds for all a âˆˆ (0, 1), and the
P (t)
fact that i wi = 1, we obtain
log

X (t)

Zt+1
2
â‰¤ log
wi 1 âˆ’ Î·vt,i + Î· 2 vt,i
/2
Zt
i
X (t)

2
= log 1 âˆ’
wi Î·vt,i âˆ’ Î· 2 vt,i
/2 .
i

|

{z

def

}

=b

Next, note that b âˆˆ (0, 1). Therefore, taking log of the two sides of the inequality
1 âˆ’ b â‰¤ eâˆ’b we obtain the inequality log(1 âˆ’ b) â‰¤ âˆ’b, which holds for all b â‰¤ 1,
and obtain
log

X (t)

Zt+1
2
â‰¤âˆ’
wi Î·vt,i âˆ’ Î· 2 vt,i
/2
Zt
i
X (t)
2
= âˆ’Î· hw(t) , vt i + Î· 2
wi vt,i
/2
i

â‰¤ âˆ’Î· hw(t) , vt i + Î· 2 /2.

21.2 Online Classification in the Unrealizable Case

297

Summing this inequality over t we get
log(ZT +1 ) âˆ’ log(Z1 ) =

T
X

log

t=1

T
X
Zt+1
T Î·2
â‰¤ âˆ’Î·
hw(t) , vt i +
.
Zt
2
t=1
(T +1)

(21.3)
P

Next, we lower bound ZT +1 . For each i, we can rewrite wÌƒi
= eâˆ’Î· t vt,i and
we get that
!


X
X
P
P
âˆ’Î· t vt,i
vt,i .
log ZT +1 = log
e
â‰¥ log max eâˆ’Î· t vt,i = âˆ’Î· min
i

i

i

t

Combining the preceding with Equation (21.3) and using the fact that log(Z1 ) =
log(d) we get that
âˆ’Î· min
i

X

vt,i âˆ’ log(d) â‰¤ âˆ’ Î·

t

T
X
T Î·2
,
hw(t) , vt i +
2
t=1

which can be rearranged as follows:
T
X
X
log(d) Î· T
hw(t) , vt i âˆ’ min
vt,i â‰¤
+
.
i
Î·
2
t
t=1

Plugging the value of Î· into the equation concludes our proof.

Proof of Theorem 21.10
Equipped with the Weighted-Majority algorithm and Theorem 21.11, we are
ready to prove Theorem 21.10. We start with the simpler case, in which H is
a finite class, and let us write H = {h1 , . . . , hd }. In this case, we can refer to
each hypothesis, hi , as an expert, whose advice is to predict hi (xt ), and whose
cost is vt,i = |hi (xt ) âˆ’ yt |. The prediction of the algorithm will therefore be
P (t)
pt = i wi hi (xt ) âˆˆ [0, 1], and the loss is
 d
  d


X
 X

 

(t)
(t)
|pt âˆ’ yt | = 
wi hi (xt ) âˆ’ yt  = 
wi (hi (xt ) âˆ’ yt ) .

 

i=1

i=1

Now, if y = 1, then for all i, hi (xt ) âˆ’ yt â‰¤ 0. Therefore, the above equals to
P (t) t
i wi |hi (xt ) âˆ’ yt |. If yt = 0 then for all i, hi (xt ) âˆ’ yt â‰¥ 0, and the above also
P (t)
equals i wi |hi (xt ) âˆ’ yt |. All in all, we have shown that
|pt âˆ’ yt | =

d
X

(t)

wi |hi (xt ) âˆ’ yt | = hw(t) , vt i.

i=1

P

Furthermore, for each i, t vt,i is exactly the number of mistakes hypothesis hi
makes. Applying Theorem 21.11 we obtain

298

Online Learning

corollary 21.12 Let H be a finite hypothesis class. There exists an algorithm
for online classification, whose predictions come from [0, 1], that enjoys the regret
bound
T
T
X
X
p
|pt âˆ’ yt | âˆ’ min
|h(xt ) âˆ’ yt | â‰¤
2 log(|H|) T .
t=1

hâˆˆH

t=1

Next, we consider the case of a general hypothesis class. Previously, we constructed an expert for each individual hypothesis. However, if H is infinite this
leads to a vacuous bound. The main idea is to construct a set of experts in a
more sophisticated way. The challenge is how to define a set of experts that, on
one hand, is not excessively large and, on the other hand, contains experts that
give accurate predictions.
We construct the set of experts so that for each hypothesis h âˆˆ H and every
sequence of instances, x1 , x2 , . . . , xT , there exists at least one expert in the set
which behaves exactly as h on these instances. For each L â‰¤ Ldim(H) and each
sequence 1 â‰¤ i1 < i2 < Â· Â· Â· < iL â‰¤ T we define an expert. The expert simulates
the game between SOA (presented in the previous section) and the environment
on the sequence of instances x1 , x2 , . . . , xT assuming that SOA makes a mistake
precisely in rounds i1 , i2 , . . . , iL . The expert is defined by the following algorithm.
Expert(i1 , i2 , . . . , iL )
input A hypothesis class H ; Indices i1 < i2 < Â· Â· Â· < iL
initialize: V1 = H
for t = 1, 2, . . . , T
receive xt
(r)
for r âˆˆ {0, 1} let Vt = {h âˆˆ Vt: h(xt ) = r}
(r)

define yÌƒt = argmaxr Ldim Vt

(in case of a tie set yÌƒt = 0)
if t âˆˆ {i1 , i2 , . . . , iL }
predict yÌ‚t = 1 âˆ’ yÌƒt
else
predict yÌ‚t = yÌƒt
(yÌ‚ )
update Vt+1 = Vt t
Note that each such expert can give us predictions at every round t while only
observing the instances x1 , . . . , xt . Our generic online learning algorithm is now
an application of the Weighted-Majority algorithm with these experts.
To analyze the algorithm we first note that the number of experts is
Ldim(H) 

d=

X

L=0


T
.
L

(21.4)

It can be shown that when T â‰¥ Ldim(H) + 2, the right-hand side of the equation
Ldim(H)
(the proof can be found in Lemma A.5).
is bounded by (eT /Ldim(H))

21.2 Online Classification in the Unrealizable Case

299

Theorem 21.11 tells us that the expected number of mistakes
p of Weighted-Majority
is at most the number of mistakes of the best expert plus 2 log(d) T . We will
next show that the number of mistakes of the best expert is at most the number
of mistakes of the best hypothesis in H. The following key lemma shows that,
on any sequence of instances, for each hypothesis h âˆˆ H there exists an expert
with the same behavior.
lemma 21.13 Let H be any hypothesis class with Ldim(H) < âˆž. Let x1 , x2 , . . . , xT
be any sequence of instances. For any h âˆˆ H, there exists L â‰¤ Ldim(H) and indices 1 â‰¤ i1 < i2 < Â· Â· Â· < iL â‰¤ T such that when running Expert(i1 , i2 , . . . , iL )
on the sequence x1 , x2 , . . . , xT , the expert predicts h(xt ) on each online round
t = 1, 2, . . . , T .
Proof Fix h âˆˆ H and the sequence x1 , x2 , . . . , xT . We must construct L and the
indices i1 , i2 , . . . , iL . Consider running SOA on the input (x1 , h(x1 )), (x2 , h(x2 )),
. . ., (xT , h(xT )). SOA makes at most Ldim(H) mistakes on such input. We define
L to be the number of mistakes made by SOA and we define {i1 , i2 , . . . , iL } to
be the set of rounds in which SOA made the mistakes.
Now, consider the Expert(i1 , i2 , . . . , iL ) running on the sequence x1 , x2 , . . . , xT .
By construction, the set Vt maintained by Expert(i1 , i2 , . . . , iL ) equals the set Vt
maintained by SOA when running on the sequence (x1 , h(x1 )), . . . , (xT , h(xT )).
The predictions of SOA differ from the predictions of h if and only if the round is
in {i1 , i2 , . . . , iL }. Since Expert(i1 , i2 , . . . , iL ) predicts exactly like SOA if t is not
in {i1 , i2 , . . . , iL } and the opposite of SOAsâ€™ predictions if t is in {i1 , i2 , . . . , iL },
we conclude that the predictions of the expert are always the same as the predictions of h.
The previous lemma holds in particular for the hypothesis in H that makes the
least number of mistakes on the sequence of examples, and we therefore obtain
the following:
corollary 21.14 Let (x1 , y1 ), (x2 , y2 ), . . . , (xT , yT ) be a sequence of examples
and let H be a hypothesis class with Ldim(H) < âˆž. There exists L â‰¤ Ldim(H)
and indices 1 â‰¤ i1 < i2 < Â· Â· Â· < iL â‰¤ T , such that Expert(i1 , i2 , . . . , iL ) makes
at most as many mistakes as the best h âˆˆ H does, namely,

min

hâˆˆH

T
X

|h(xt ) âˆ’ yt |

t=1

mistakes on the sequence of examples.
Together with Theorem 21.11, the upper bound part of Theorem 21.10 is
proven.

300

Online Learning

21.3

Online Convex Optimization
In Chapter 12 we studied convex learning problems and showed learnability
results for these problems in the agnostic PAC learning framework. In this section
we show that similar learnability results hold for convex problems in the online
learning framework. In particular, we consider the following problem.
Online Convex Optimization
definitions:
hypothesis class H ; domain Z ; loss function ` : H Ã— Z â†’ R
assumptions:
H is convex
âˆ€z âˆˆ Z, `(Â·, z) is a convex function
for t = 1, 2, . . . , T
learner predicts a vector w(t) âˆˆ H
environment responds with zt âˆˆ Z
learner suffers loss `(w(t) , zt )
As in the online classification problem, we analyze the regret of the algorithm.
Recall that the regret of an online algorithm with respect to a competing hypothesis, which here will be some vector w? âˆˆ H, is defined as
?

RegretA (w , T ) =

T
X

(t)

`(w , zt ) âˆ’

t=1

T
X

`(w? , zt ).

(21.5)

t=1

As before, the regret of the algorithm relative to a set of competing vectors, H,
is defined as
RegretA (H, T ) = sup RegretA (w? , T ).
w? âˆˆH

In Chapter 14 we have shown that Stochastic Gradient Descent solves convex
learning problems in the agnostic PAC model. We now show that a very similar
algorithm, Online Gradient Descent, solves online convex learning problems.
Online Gradient Descent
parameter: Î· > 0
initialize: w(1) = 0
for t = 1, 2, . . . , T
predict w(t)
receive zt and let ft (Â·) = `(Â·, zt )
choose vt âˆˆ âˆ‚ft (w(t) )
update:
1
1. w(t+ 2 ) = w(t) âˆ’ Î·vt
1
2. w(t+1) = argminwâˆˆH kw âˆ’ w(t+ 2 ) k

21.4 The Online Perceptron Algorithm

301

theorem 21.15 The Online Gradient Descent algorithm enjoys the following
regret bound for every w? âˆˆ H,
RegretA (w? , T ) â‰¤

T
Î·X
kw? k2
kvt k2 .
+
2Î·
2 t=1

âˆš
If we further assume that ft is Ï-Lipschitz for all t, then setting Î· = 1/ T yields
âˆš
1
RegretA (w? , T ) â‰¤ (kw? k2 + Ï2 ) T .
2
If we further assume that H is B-bounded and we set Î· =
âˆš
RegretA (H, T ) â‰¤ B Ï T .

B
âˆš
Ï T

then

Proof The analysis is similar to the analysis of Stochastic Gradient Descent
1
with projections. Using the projection lemma, the definition of w(t+ 2 ) , and the
definition of subgradients, we have that for every t,
kw(t+1) âˆ’ w? k2 âˆ’ kw(t) âˆ’ w? k2
1

1

= kw(t+1) âˆ’ w? k2 âˆ’ kw(t+ 2 ) âˆ’ w? k2 + kw(t+ 2 ) âˆ’ w? k2 âˆ’ kw(t) âˆ’ w? k2
1

â‰¤ kw(t+ 2 ) âˆ’ w? k2 âˆ’ kw(t) âˆ’ w? k2
= kw(t) âˆ’ Î·vt âˆ’ w? k2 âˆ’ kw(t) âˆ’ w? k2
= âˆ’2Î·hw(t) âˆ’ w? , vt i + Î· 2 kvt k2
â‰¤ âˆ’2Î·(ft (w(t) ) âˆ’ ft (w? )) + Î· 2 kvt k2 .
Summing over t and observing that the left-hand side is a telescopic sum we
obtain that
kw(T +1) âˆ’ w? k2 âˆ’ kw(1) âˆ’ w? k2 â‰¤ âˆ’2Î·

T
T
X
X
(ft (w(t) ) âˆ’ ft (w? )) + Î· 2
kvt k2 .
t=1

Rearranging the inequality and using the fact that w

t=1
(1)

= 0, we get that

T
T
X
kw(1) âˆ’ w? k2 âˆ’ kw(T +1) âˆ’ w? k2
Î·X
+
kvt k2
(ft (w(t) ) âˆ’ ft (w? )) â‰¤
2Î·
2
t=1
t=1

â‰¤

T
kw? k2
Î·X
+
kvt k2 .
2Î·
2 t=1

This proves the first bound in the theorem. The second bound follows from the
assumption that ft is Ï-Lipschitz, which implies that kvt k â‰¤ Ï.

21.4

The Online Perceptron Algorithm
The Perceptron is a classic online learning algorithm for binary classification with
the hypothesis class of homogenous halfspaces, namely, H = {x 7â†’ sign(hw, xi) :

302

Online Learning

w âˆˆ Rd }. In Section 9.1.2 we have presented the batch version of the Perceptron,
which aims to solve the ERM problem with respect to H. We now present an
online version of the Perceptron algorithm.
Let X = Rd , Y = {âˆ’1, 1}. On round t, the learner receives a vector xt âˆˆ Rd .
The learner maintains a weight vector w(t) âˆˆ Rd and predicts pt = sign(hw(t) , xt i).
Then, it receives yt âˆˆ Y and pays 1 if pt 6= yt and 0 otherwise.
The goal of the learner is to make as few prediction mistakes as possible. In
Section 21.1 we characterized the optimal algorithm and showed that the best
achievable mistake bound depends on the Littlestone dimension of the class.
We show later that if d â‰¥ 2 then Ldim(H) = âˆž, which implies that we have
no hope of making few prediction mistakes. Indeed, consider the tree for which
v1 = ( 12 , 1, 0, . . . , 0), v2 = ( 14 , 1, 0, . . . , 0), v3 = ( 43 , 1, 0, . . . , 0), etc. Because of
the density of the reals, this tree is shattered by the subset of H which contains
all hypotheses that are parametrized by w of the form w = (âˆ’1, a, 0, . . . , 0), for
a âˆˆ [0, 1]. We conclude that indeed Ldim(H) = âˆž.
To sidestep this impossibility result, the Perceptron algorithm relies on the
technique of surrogate convex losses (see Section 12.3). This is also closely related
to the notion of margin we studied in Chapter 15.
A weight vector w makes a mistake on an example (x, y) whenever the sign of
hw, xi does not equal y. Therefore, we can write the 0âˆ’1 loss function as follows
`(w, (x, y)) = 1[yhw,xiâ‰¤0] .
On rounds on which the algorithm makes a prediction mistake, we shall use the
hinge-loss as a surrogate convex loss function
ft (w) = max{0, 1 âˆ’ yt hw, xt i}.
The hinge-loss satisfies the two conditions:
â€¢ ft is a convex function
â€¢ For all w, ft (w) â‰¥ `(w, (xt , yt )). In particular, this holds for w(t) .
On rounds on which the algorithm is correct, we shall define ft (w) = 0. Clearly,
ft is convex in this case as well. Furthermore, ft (w(t) ) = `(w(t) , (xt , yt )) = 0.
Remark 21.5 In Section 12.3 we used the same surrogate loss function for all the
examples. In the online model, we allow the surrogate to depend on the specific
round. It can even depend on w(t) . Our ability to use a round specific surrogate
stems from the worst-case type of analysis we employ in online learning.
Let us now run the Online Gradient Descent algorithm on the sequence of
functions, f1 , . . . , fT , with the hypothesis class being all vectors in Rd (hence,
the projection step is vacuous). Recall that the algorithm initializes w(1) = 0
and its update rule is
w(t+1) = w(t) âˆ’ Î·vt
for some vt âˆˆ âˆ‚ft (w(t) ). In our case, if yt hw(t) , xt i > 0 then ft is the zero

21.4 The Online Perceptron Algorithm

303

function and we can take vt = 0. Otherwise, it is easy to verify that vt = âˆ’yt xt
is in âˆ‚ft (w(t) ). We therefore obtain the update rule
(
w(t)
if yt hw(t) , xt i > 0
(t+1)
w
=
w(t) + Î·yt xt otherwise
Denote by M the set of rounds in which sign(hw(t) , xt i) 6= yt . Note that on
round t, the prediction of the Perceptron can be rewritten as
!
X
(t)
pt = sign(hw , xt i) = sign Î·
yi hxi , xt i .
iâˆˆM:i<t

This form implies that the predictions of the Perceptron algorithm and the set
M do not depend on the actual value of Î· as long as Î· > 0. We have therefore
obtained the Perceptron algorithm:
Perceptron
initialize: w1 = 0
for t = 1, 2, . . . , T
receive xt
predict pt = sign(hw(t) , xt i)
if yt hw(t) , xt i â‰¤ 0
w(t+1) = w(t) + yt xt
else
w(t+1) = w(t)
To analyze the Perceptron, we rely on the analysis of Online Gradient Descent given in the previous section. In our case, the subgradient of ft we use
in the Perceptron is vt = âˆ’1[yt hw(t) ,xt iâ‰¤0] yt xt . Indeed, the Perceptronâ€™s update
is w(t+1) = w(t) âˆ’ vt , and as discussed before this is equivalent to w(t+1) =
w(t) âˆ’ Î·vt for every Î· > 0. Therefore, Theorem 21.15 tells us that
T
X

ft (w(t) ) âˆ’

t=1

T
X

ft (w? ) â‰¤

t=1

T
1
Î·X
kw? k22 +
kvt k22 .
2Î·
2 t=1

Since ft (w(t) ) is a surrogate for the 0âˆ’1 loss we know that
Denote R = maxt kxt k; then we obtain
|M| âˆ’

T
X

ft (w? ) â‰¤

t=1

Setting Î· =

?

kw k
R

âˆš

|M|

PT

t=1

ft (w(t) ) â‰¥ |M|.

1
Î·
kw? k22 + |M| R2
2Î·
2

and rearranging, we obtain
|M| âˆ’ Rkw? k

T
X
p
|M| âˆ’
ft (w? ) â‰¤ 0.
t=1

This inequality implies

(21.6)

304

Online Learning

theorem 21.16 Suppose that the Perceptron algorithm runs on a sequence
(x1 , y1 ), . . . , (xT , yT ) and let R = maxt kxt k. Let M be the rounds on which the
Perceptron errs and let ft (w) = 1[tâˆˆM] [1 âˆ’ yt hw, xt i]+ . Then, for every w?
|M| â‰¤

X
t

?

?

ft (w ) + R kw k

s

X

ft (w? ) + R2 kw? k2 .

t

In particular, if there exists w? such that yt hw? , xt i â‰¥ 1 for all t then
|M| â‰¤ R2 kw? k2 .
Proof The theorem follows from Equation (21.6) and the following claim: Given
âˆš
âˆš
x, b, c âˆˆ R+ , the inequality x âˆ’ b x âˆ’ c â‰¤ 0 implies that x â‰¤ c + b2 + b c. The
last claim can be easily derived by analyzing the roots of the convex parabola
Q(y) = y 2 âˆ’ by âˆ’ c.
The last assumption of Theorem 21.16 is called separability with large margin
(see Chapter 15). That is, there exists w? that not only satisfies that the point
xt lies on the correct side of the halfspace, it also guarantees that xt is not too
close to the decision boundary. More specifically, the distance from xt to the
decision boundary is at least Î³ = 1/kw? k and the bound becomes (R/Î³)2 .
When the separability assumption does not hold, the bound involves the term
[1 âˆ’ yt hw? , xt i]+ which measures how much the separability with margin requirement is violated.
As a last remark we note that there can be cases in which there exists some
w? that makes zero errors on the sequence but the Perceptron will make many
errors. Indeed, this is a direct consequence of the fact that Ldim(H) = âˆž. The
way we sidestep this impossibility result is by assuming more on the sequence of
examples â€“ the bound in Theorem 21.16 will be meaningful only if the cumulative
P
surrogate loss, t ft (w? ) is not excessively large.

21.5

Summary
In this chapter we have studied the online learning model. Many of the results
we derived for the PAC learning model have an analog in the online model. First,
we have shown that a combinatorial dimension, the Littlestone dimension, characterizes online learnability. To show this, we introduced the SOA algorithm (for
the realizable case) and the Weighted-Majority algorithm (for the unrealizable
case). We have also studied online convex optimization and have shown that
online gradient descent is a successful online learner whenever the loss function
is convex and Lipschitz. Finally, we presented the online Perceptron algorithm
as a combination of online gradient descent and the concept of surrogate convex
loss functions.

21.6 Bibliographic Remarks

21.6

305

Bibliographic Remarks
The Standard Optimal Algorithm was derived by the seminal work of Littlestone (1988). A generalization to the nonrealizable case, as well as other
variants like margin-based Littlestoneâ€™s dimension, were derived in (Ben-David
et al. 2009). Characterizations of online learnability beyond classification have
been obtained in (Abernethy, Bartlett, Rakhlin & Tewari 2008, Rakhlin, Sridharan & Tewari 2010, Daniely et al. 2011). The Weighted-Majority algorithm is
due to (Littlestone & Warmuth 1994) and (Vovk 1990).
The term â€œonline convex programmingâ€ was introduced by Zinkevich (2003)
but this setting was introduced some years earlier by Gordon (1999). The Perceptron dates back to Rosenblatt (Rosenblatt 1958). An analysis for the realizable case (with margin assumptions) appears in (Agmon 1954, Minsky &
Papert 1969). Freund and Schapire (Freund & Schapire 1999) presented an analysis for the unrealizable case with a squared-hinge-loss based on a reduction to
the realizable case. A direct analysis for the unrealizable case with the hinge-loss
was given by Gentile (Gentile 2003).
For additional information we refer the reader to Cesa-Bianchi & Lugosi (2006)
and Shalev-Shwartz (2011).

21.7

Exercises
1. Find a hypothesis class H and a sequence of examples on which Consistent
makes |H| âˆ’ 1 mistakes.
2. Find a hypothesis class H and a sequence of examples on which the mistake
bound of the Halving algorithm is tight.
3. Let d â‰¥ 2, X = {1, . . . , d} and let H = {hj : j âˆˆ [d]}, where hj (x) = 1[x=j] .
Calculate MHalving (H) (i.e., derive lower and upper bounds on MHalving (H),
and prove that they are equal).
4. The Doubling Trick:
In Theorem 21.15, the parameter Î· depends on the time horizon T . In this
exercise we show how to get rid of this dependence by a simple trick.
âˆš
Consider an algorithm that enjoys a regret bound of the form Î± T , but
its parameters require the knowledge of T . The doubling trick, described in
the following, enables us to convert such an algorithm into an algorithm that
does not need to know the time horizon. The idea is to divide the time into
periods of increasing size and run the original algorithm on each period.
The Doubling Trick
input: algorithm A whose parameters depend on the time horizon
for m = 0, 1, 2, . . .
run A on the 2m rounds t = 2m , . . . , 2m+1 âˆ’ 1

306

Online Learning

âˆš
Show that if the regret of A on each period of 2m rounds is at most Î± 2m ,
then the total regret is at most
âˆš
âˆš
2
âˆš
Î± T.
2âˆ’1
5. Online-to-batch Conversions: In this exercise we demonstrate how a successful online learning algorithm can be used to derive a successful PAC
learner as well.
Consider a PAC learning problem for binary classification parameterized
by an instance domain, X , and a hypothesis class, H. Suppose that there exists
an online learning algorithm, A, which enjoys a mistake bound MA (H) < âˆž.
Consider running this algorithm on a sequence of T examples which are sampled i.i.d. from a distribution D over the instance space X , and are labeled by
some h? âˆˆ H. Suppose that for every round t, the prediction of the algorithm
is based on a hypothesis ht : X â†’ {0, 1}. Show that
MA (H)
,
T
where the expectation is over the random choice of the instances as well as a
random choice of r according to the uniform distribution over [T ].
Hint: Use similar arguments to the ones appearing in the proof of Theorem 14.8.
E[LD (hr )] â‰¤

22 Clustering

Clustering is one of the most widely used techniques for exploratory data analysis. Across all disciplines, from social sciences to biology to computer science,
people try to get a first intuition about their data by identifying meaningful
groups among the data points. For example, computational biologists cluster
genes on the basis of similarities in their expression in different experiments; retailers cluster customers, on the basis of their customer profiles, for the purpose
of targeted marketing; and astronomers cluster stars on the basis of their spacial
proximity.
The first point that one should clarify is, naturally, what is clustering? Intuitively, clustering is the task of grouping a set of objects such that similar
objects end up in the same group and dissimilar objects are separated into different groups. Clearly, this description is quite imprecise and possibly ambiguous.
Quite surprisingly, it is not at all clear how to come up with a more rigorous
definition.
There are several sources for this difficulty. One basic problem is that the
two objectives mentioned in the earlier statement may in many cases contradict
each other. Mathematically speaking, similarity (or proximity) is not a transitive relation, while cluster sharing is an equivalence relation and, in particular,
it is a transitive relation. More concretely, it may be the case that there is a
long sequence of objects, x1 , . . . , xm such that each xi is very similar to its two
neighbors, xiâˆ’1 and xi+1 , but x1 and xm are very dissimilar. If we wish to make
sure that whenever two elements are similar they share the same cluster, then
we must put all of the elements of the sequence in the same cluster. However,
in that case, we end up with dissimilar elements (x1 and xm ) sharing a cluster,
thus violating the second requirement.
To illustrate this point further, suppose that we would like to cluster the points
in the following picture into two clusters.

A clustering algorithm that emphasizes not separating close-by points (e.g., the
Single Linkage algorithm that will be described in Section 22.1) will cluster this
input by separating it horizontally according to the two lines:
c 2014 by Shai Shalev-Shwartz and Shai Ben-David
Understanding Machine Learning, 
Published 2014 by Cambridge University Press.
Personal use only. Not for distribution. Do not post.
Please link to http://www.cs.huji.ac.il/~shais/UnderstandingMachineLearning

308

Clustering

In contrast, a clustering method that emphasizes not having far-away points
share the same cluster (e.g., the 2-means algorithm that will be described in
Section 22.1) will cluster the same input by dividing it vertically into the righthand half and the left-hand half:

Another basic problem is the lack of â€œground truthâ€ for clustering, which is a
common problem in unsupervised learning. So far in the book, we have mainly
dealt with supervised learning (e.g., the problem of learning a classifier from
labeled training data). The goal of supervised learning is clear â€“ we wish to
learn a classifier which will predict the labels of future examples as accurately
as possible. Furthermore, a supervised learner can estimate the success, or the
risk, of its hypotheses using the labeled training data by computing the empirical
loss. In contrast, clustering is an unsupervised learning problem; namely, there
are no labels that we try to predict. Instead, we wish to organize the data in
some meaningful way. As a result, there is no clear success evaluation procedure
for clustering. In fact, even on the basis of full knowledge of the underlying data
distribution, it is not clear what is the â€œcorrectâ€ clustering for that data or how
to evaluate a proposed clustering.
Consider, for example, the following set of points in R2 :

and suppose we are required to cluster them into two clusters. We have two
highly justifiable solutions:

Clustering

309

This phenomenon is not just artificial but occurs in real applications. A given
set of objects can be clustered in various different meaningful ways. This may
be due to having different implicit notions of distance (or similarity) between
objects, for example, clustering recordings of speech by the accent of the speaker
versus clustering them by content, clustering movie reviews by movie topic versus
clustering them by the review sentiment, clustering paintings by topic versus
clustering them by style, and so on.
To summarize, there may be several very different conceivable clustering solutions for a given data set. As a result, there is a wide variety of clustering
algorithms that, on some input data, will output very different clusterings.

A Clustering Model:
Clustering tasks can vary in terms of both the type of input they have and the
type of outcome they are expected to compute. For concreteness, we shall focus
on the following common setup:
Input â€” a set of elements, X , and a distance function over it. That is, a function
d : X Ã— X â†’ R+ that is symmetric, satisfies d(x, x) = 0 for all x âˆˆ X
and often also satisfies the triangle inequality. Alternatively, the function
could be a similarity function s : X Ã— X â†’ [0, 1] that is symmetric
and satisfies s(x, x) = 1 for all x âˆˆ X . Additionally, some clustering
algorithms also require an input parameter k (determining the number
of required clusters).
Output â€” a partition of the domain set X into subsets. That is, C = (C1 , . . . Ck )
Sk
where i=1 Ci = X and for all i 6= j, Ci âˆ© Cj = âˆ…. In some situations the
clustering is â€œsoft,â€ namely, the partition of X into the different clusters
is probabilistic where the output is a function assigning to each domain
point, x âˆˆ X , a vector (p1 (x), . . . , pk (x)), where pi (x) = P[x âˆˆ Ci ] is
the probability that x belongs to cluster Ci . Another possible output is
a clustering dendrogram (from Greek dendron = tree, gramma = drawing), which is a hierarchical tree of domain subsets, having the singleton
sets in its leaves, and the full domain as its root. We shall discuss this
formulation in more detail in the following.

310

Clustering

In the following we survey some of the most popular clustering methods. In
the last section of this chapter we return to the high level discussion of what is
clustering.

22.1

Linkage-Based Clustering Algorithms
Linkage-based clustering is probably the simplest and most straightforward paradigm
of clustering. These algorithms proceed in a sequence of rounds. They start from
the trivial clustering that has each data point as a single-point cluster. Then,
repeatedly, these algorithms merge the â€œclosestâ€ clusters of the previous clustering. Consequently, the number of clusters decreases with each such round. If kept
going, such algorithms would eventually result in the trivial clustering in which
all of the domain points share one large cluster. Two parameters, then, need to
be determined to define such an algorithm clearly. First, we have to decide how
to measure (or define) the distance between clusters, and, second, we have to
determine when to stop merging. Recall that the input to a clustering algorithm
is a between-points distance function, d. There are many ways of extending d to
a measure of distance between domain subsets (or clusters). The most common
ways are
1. Single Linkage clustering, in which the between-clusters distance is defined
by the minimum distance between members of the two clusters, namely,
def

D(A, B) = min{d(x, y) : x âˆˆ A, y âˆˆ B}
2. Average Linkage clustering, in which the distance between two clusters is
defined to be the average distance between a point in one of the clusters and
a point in the other, namely,
X
1
def
d(x, y)
D(A, B) =
|A||B|
xâˆˆA, yâˆˆB

3. Max Linkage clustering, in which the distance between two clusters is defined
as the maximum distance between their elements, namely,
def

D(A, B) = max{d(x, y) : x âˆˆ A, y âˆˆ B}.
The linkage-based clustering algorithms are agglomerative in the sense that they
start from data that is completely fragmented and keep building larger and
larger clusters as they proceed. Without employing a stopping rule, the outcome
of such an algorithm can be described by a clustering dendrogram: that is, a tree
of domain subsets, having the singleton sets in its leaves, and the full domain as
its root. For example, if the input is the elements X = {a, b, c, d, e} âŠ‚ R2 with
the Euclidean distance as depicted on the left, then the resulting dendrogram is
the one depicted on the right:

22.2 k-Means and Other Cost Minimization Clusterings

311

{a, b, c, d, e}
{b, c, d, e}

a
e

{b, c}

d
c
b

{a}

{b}

{c}

{d, e}
{d}

{e}

The single linkage algorithm is closely related to Kruskalâ€™s algorithm for finding
a minimal spanning tree on a weighted graph. Indeed, consider the full graph
whose vertices are elements of X and the weight of an edge (x, y) is the distance
d(x, y). Each merge of two clusters performed by the single linkage algorithm
corresponds to a choice of an edge in the aforementioned graph. It is also possible
to show that the set of edges the single linkage algorithm chooses along its run
forms a minimal spanning tree.
If one wishes to turn a dendrogram into a partition of the space (a clustering),
one needs to employ a stopping criterion. Common stopping criteria include
â€¢ Fixed number of clusters â€“ fix some parameter, k, and stop merging clusters
as soon as the number of clusters is k.
â€¢ Distance upper bound â€“ fix some r âˆˆ R+ . Stop merging as soon as all the
between-clusters distances are larger than r. We can also set r to be
Î± max{d(x, y) : x, y âˆˆ X } for some Î± < 1. In that case the stopping
criterion is called â€œscaled distance upper bound.â€

22.2

k-Means and Other Cost Minimization Clusterings
Another popular approach to clustering starts by defining a cost function over a
parameterized set of possible clusterings and the goal of the clustering algorithm
is to find a partitioning (clustering) of minimal cost. Under this paradigm, the
clustering task is turned into an optimization problem. The objective function
is a function from pairs of an input, (X , d), and a proposed clustering solution
C = (C1 , . . . , Ck ), to positive real numbers. Given such an objective function,
which we denote by G, the goal of a clustering algorithm is defined as finding, for
a given input (X , d), a clustering C so that G((X , d), C) is minimized. In order
to reach that goal, one has to apply some appropriate search algorithm.
As it turns out, most of the resulting optimization problems are NP-hard, and
some are even NP-hard to approximate. Consequently, when people talk about,
say, k-means clustering, they often refer to some particular common approximation algorithm rather than the cost function or the corresponding exact solution
of the minimization problem.
Many common objective functions require the number of clusters, k, as a

312

Clustering

parameter. In practice, it is often up to the user of the clustering algorithm to
choose the parameter k that is most suitable for the given clustering problem.
In the following we describe some of the most common objective functions.
â€¢ The k-means objective function is one of the most popular clustering
objectives. In k-means the data is partitioned into disjoint sets C1 , . . . , Ck
where each Ci is represented by a centroid Âµi . It is assumed that the input
set X is embedded in some larger metric space (X 0 , d) (so that X âŠ† X 0 )
and centroids are members of X 0 . The k-means objective function measures
the squared distance between each point in X to the centroid of its cluster.
The centroid of Ci is defined to be
X
d(x, Âµ)2 .
Âµi (Ci ) = argmin
ÂµâˆˆX 0

xâˆˆCi

Then, the k-means objective is
Gkâˆ’means ((X , d), (C1 , . . . , Ck )) =

k X
X

d(x, Âµi (Ci ))2 .

i=1 xâˆˆCi

This can also be rewritten as
Gkâˆ’means ((X , d), (C1 , . . . , Ck )) =

min

k X
X

Âµ1 ,...Âµk âˆˆX 0

d(x, Âµi )2 .

(22.1)

i=1 xâˆˆCi

The k-means objective function is relevant, for example, in digital communication tasks, where the members of X may be viewed as a collection
of signals that have to be transmitted. While X may be a very large set
of real valued vectors, digital transmission allows transmitting of only a
finite number of bits for each signal. One way to achieve good transmission under such constraints is to represent each member of X by a â€œcloseâ€
member of some finite set Âµ1 , . . . Âµk , and replace the transmission of any
x âˆˆ X by transmitting the index of the closest Âµi . The k-means objective
can be viewed as a measure of the distortion created by such a transmission
representation scheme.
â€¢ The k-medoids objective function is similar to the k-means objective,
except that it requires the cluster centroids to be members of the input
set. The objective function is defined by
GKâˆ’medoid ((X , d), (C1 , . . . , Ck )) =

min

Âµ1 ,...Âµk âˆˆX

k X
X

d(x, Âµi )2 .

i=1 xâˆˆCi

â€¢ The k-median objective function is quite similar to the k-medoids objective, except that the â€œdistortionâ€ between a data point and the centroid
of its cluster is measured by distance, rather than by the square of the
distance:
GKâˆ’median ((X , d), (C1 , . . . , Ck )) =

min

Âµ1 ,...Âµk âˆˆX

k X
X
i=1 xâˆˆCi

d(x, Âµi ).

22.2 k-Means and Other Cost Minimization Clusterings

313

An example where such an objective makes sense is the facility location
problem. Consider the task of locating k fire stations in a city. One can
model houses as data points and aim to place the stations so as to minimize
the average distance between a house and its closest fire station.
The previous examples can all be viewed as center-based objectives. The solution to such a clustering problem is determined by a set of cluster centers,
and the clustering assigns each instance to the center closest to it. More generally, center-based objective is determined by choosing some monotonic function
f : R+ â†’ R+ and then defining
Gf ((X , d), (C1 , . . . Ck )) =

min

k X
X

Âµ1 ,...Âµk âˆˆX 0

f (d(x, Âµi )),

i=1 xâˆˆCi

where X 0 is either X or some superset of X .
Some objective functions are not center based. For example, the sum of incluster distances (SOD)
GSOD ((X , d), (C1 , . . . Ck )) =

k
X
X

d(x, y)

i=1 x,yâˆˆCi

and the MinCut objective that we shall discuss in Section 22.3 are not centerbased objectives.

22.2.1

The k-Means Algorithm
The k-means objective function is quite popular in practical applications of clustering. However, it turns out that finding the optimal k-means solution is often computationally infeasible (the problem is NP-hard, and even NP-hard to
approximate to within some constant). As an alternative, the following simple
iterative algorithm is often used, so often that, in many cases, the term k-means
Clustering refers to the outcome of this algorithm rather than to the clustering that minimizes the k-means objective cost. We describe the algorithm with
respect to the Euclidean distance function d(x, y) = kx âˆ’ yk.
k-Means
input: X âŠ‚ Rn ; Number of clusters k
initialize: Randomly choose initial centroids Âµ1 , . . . , Âµk
repeat until convergence
âˆ€i âˆˆ [k] set Ci = {x âˆˆ X : i = argminj kx âˆ’ Âµj k}
(break ties in some arbitrary manner)
P
âˆ€i âˆˆ [k] update Âµi = |C1i | xâˆˆCi x
lemma 22.1 Each iteration of the k-means algorithm does not increase the
k-means objective function (as given in Equation (22.1)).

314

Clustering

Proof To simplify the notation, let us use the shorthand G(C1 , . . . , Ck ) for the
k-means objective, namely,

G(C1 , . . . , Ck ) =

min

Âµ1 ,...,Âµk âˆˆRn

k X
X

kx âˆ’ Âµi k2 .

(22.2)

i=1 xâˆˆCi

P
P
It is convenient to define Âµ(Ci ) = |C1i | xâˆˆCi x and note that Âµ(Ci ) = argminÂµâˆˆRn xâˆˆCi kxâˆ’
Âµk2 . Therefore, we can rewrite the k-means objective as

G(C1 , . . . , Ck ) =

k X
X

kx âˆ’ Âµ(Ci )k2 .

(22.3)

i=1 xâˆˆCi
(tâˆ’1)

(tâˆ’1)

Consider the update at iteration t of the k-means algorithm. Let C1
, . . . , Ck
(tâˆ’1)
(tâˆ’1)
(t)
(t)
be the previous partition, let Âµi
= Âµ(Ci
), and let C1 , . . . , Ck be the
new partition assigned at iteration t. Using the definition of the objective as
given in Equation (22.2) we clearly have that
(t)

(t)

G(C1 , . . . , Ck ) â‰¤

k
X
X

(tâˆ’1) 2

kx âˆ’ Âµi

k .

(22.4)

i=1 xâˆˆC (t)
i
(t)

(t)

In addition, the definition of the new partition (C1 , . . . , Ck ) implies that it
Pk P
(tâˆ’1) 2
minimizes the expression i=1 xâˆˆCi kx âˆ’ Âµi
k over all possible partitions
(C1 , . . . , Ck ). Hence,
k
X
X
i=1 xâˆˆC (t)
i

(tâˆ’1) 2

kx âˆ’ Âµi

k â‰¤

k
X

X

(tâˆ’1) 2

kx âˆ’ Âµi

k .

(22.5)

i=1 xâˆˆC (tâˆ’1)
i

Using Equation (22.3) we have that the right-hand side of Equation (22.5) equals
(tâˆ’1)
(tâˆ’1)
G(C1
, . . . , Ck
). Combining this with Equation (22.4) and Equation (22.5),
(t)
(t)
(tâˆ’1)
(tâˆ’1)
we obtain that G(C1 , . . . , Ck ) â‰¤ G(C1
, . . . , Ck
), which concludes our
proof.
While the preceding lemma tells us that the k-means objective is monotonically
nonincreasing, there is no guarantee on the number of iterations the k-means algorithm needs in order to reach convergence. Furthermore, there is no nontrivial
lower bound on the gap between the value of the k-means objective of the algorithmâ€™s output and the minimum possible value of that objective function. In
fact, k-means might converge to a point which is not even a local minimum (see
Exercise 2). To improve the results of k-means it is often recommended to repeat
the procedure several times with different randomly chosen initial centroids (e.g.,
we can choose the initial centroids to be random points from the data).

22.3 Spectral Clustering

22.3

315

Spectral Clustering
Often, a convenient way to represent the relationships between points in a data
set X = {x1 , . . . , xm } is by a similarity graph; each vertex represents a data
point xi , and every two vertices are connected by an edge whose weight is their
similarity, Wi,j = s(xi , xj ), where W âˆˆ Rm,m . For example, we can set Wi,j =
exp(âˆ’d(xi , xj )2 /Ïƒ 2 ), where d(Â·, Â·) is a distance function and Ïƒ is a parameter.
The clustering problem can now be formulated as follows: We want to find a
partition of the graph such that the edges between different groups have low
weights and the edges within a group have high weights.
In the clustering objectives described previously, the focus was on one side
of our intuitive definition of clustering â€“ making sure that points in the same
cluster are similar. We now present objectives that focus on the other requirement
â€“ points separated into different clusters should be nonsimilar.

22.3.1

Graph Cut
Given a graph represented by a similarity matrix W , the simplest and most
direct way to construct a partition of the graph is to solve the mincut problem,
which chooses a partition C1 , . . . , Ck that minimizes the objective
cut(C1 , . . . , Ck ) =

k
X

X

Wr,s .

i=1 râˆˆCi ,sâˆˆC
/ i

For k = 2, the mincut problem can be solved efficiently. However, in practice it
often does not lead to satisfactory partitions. The problem is that in many cases,
the solution of mincut simply separates one individual vertex from the rest of the
graph. Of course, this is not what we want to achieve in clustering, as clusters
should be reasonably large groups of points.
Several solutions to this problem have been suggested. The simplest solution
is to normalize the cut and define the normalized mincut objective as follows:
RatioCut(C1 , . . . , Ck ) =

k
X
1
|C
i|
i=1

X

Wr,s .

râˆˆCi ,sâˆˆC
/ i

The preceding objective assumes smaller values if the clusters are not too small.
Unfortunately, introducing this balancing makes the problem computationally
hard to solve. Spectral clustering is a way to relax the problem of minimizing
RatioCut.

22.3.2

Graph Laplacian and Relaxed Graph Cuts
The main mathematical object for spectral clustering is the graph Laplacian
matrix. There are several different definitions of graph Laplacian in the literature,
and in the following we describe one particular definition.

316

Clustering

definition 22.2 (Unnormalized Graph Laplacian) The unnormalized graph
Laplacian is the m Ã— m matrix L = D âˆ’ W where D is a diagonal matrix with
Pm
Di,i = j=1 Wi,j . The matrix D is called the degree matrix.
The following lemma underscores the relation between RatioCut and the Laplacian matrix.
lemma 22.3
such that

Let C1 , . . . , Ck be a clustering and let H âˆˆ Rm,k be the matrix

Hi,j = âˆš 1

|Cj |

1[iâˆˆCj ] .

Then, the columns of H are orthonormal to each other and
RatioCut(C1 , . . . , Ck ) = trace(H > L H).
Proof Let h1 , . . . , hk be the columns of H. The fact that these vectors are
orthonormal is immediate from the definition. Next, by standard algebraic maPk
nipulations, it can be shown that trace(H > L H) = i=1 h>
i Lhi and that for
any vector v we have
1
v Lv =
2
>

!
X
r

Dr,r vr2

âˆ’2

X

vr vs Wr,s +

r,s

X

Ds,s vs2

s

=

1X
Wr,s (vr âˆ’ vs )2 .
2 r,s

Applying this with v = hi and noting that (hi,r âˆ’ hi,s )2 is nonzero only if
r âˆˆ Ci , s âˆˆ
/ Ci or the other way around, we obtain that
h>
i Lhi =

1
|Ci |

X

Wr,s .

râˆˆCi ,sâˆˆC
/ i

Therefore, to minimize RatioCut we can search for a matrix
p H whose columns
are orthonormal and such that each Hi,j is either 0 or 1/ |Cj |. Unfortunately,
this is an integer programming problem which we cannot solve efficiently. Instead,
we relax the latter requirement and simply search an orthonormal matrix H âˆˆ
Rm,k that minimizes trace(H > L H). As we will see in the next chapter about
PCA (particularly, the proof of Theorem 23.2), the solution to this problem is
to set U to be the matrix whose columns are the eigenvectors corresponding to
the k minimal eigenvalues of L. The resulting algorithm is called Unnormalized
Spectral Clustering.

22.4 Information Bottleneck*

22.3.3

317

Unnormalized Spectral Clustering
Unnormalized Spectral Clustering
Input: W âˆˆ Rm,m ; Number of clusters k
Initialize: Compute the unnormalized graph Laplacian L
Let U âˆˆ Rm,k be the matrix whose columns are the eigenvectors of L
corresponding to the k smallest eigenvalues
Let v1 , . . . , vm be the rows of U
Cluster the points v1 , . . . , vm using k-means
Output: Clusters C1 , . . . , CK of the k-means algorithm
The spectral clustering algorithm starts with finding the matrix H of the k
eigenvectors corresponding to the smallest eigenvalues of the graph Laplacian
matrix. It then represents points according to the rows of H. It is due to the
properties of the graph Laplacians that this change of representation is useful.
In many situations, this change of representation enables the simple k-means
algorithm to detect the clusters seamlessly. Intuitively, if H is as defined in
Lemma 22.3 then each point in the new representation is an indicator vector
whose value is nonzero only on the element corresponding to the cluster it belongs
to.

22.4

Information Bottleneck*
The information bottleneck method is a clustering technique introduced by
Tishby, Pereira, and Bialek. It relies on notions from information theory. To
illustrate the method, consider the problem of clustering text documents where
each document is represented as a bag-of-words; namely, each document is a
vector x = {0, 1}n , where n is the size of the dictionary and xi = 1 iff the word
corresponding to index i appears in the document. Given a set of m documents,
we can interpret the bag-of-words representation of the m documents as a joint
probability over a random variable x, indicating the identity of a document (thus
taking values in [m]), and a random variable y, indicating the identity of a word
in the dictionary (thus taking values in [n]).
With this interpretation, the information bottleneck refers to the identity of
a clustering as another random variable, denoted C, that takes values in [k]
(where k will be set by the method as well). Once we have formulated x, y, C
as random variables, we can use tools from information theory to express a
clustering objective. In particular, the information bottleneck objective is
min I(x; C) âˆ’ Î²I(C; y) ,
p(C|x)

where I(Â·; Â·) is the mutual information between two random variables,1 Î² is a
1

That is, given a probability function, p over the pairs (x, C),

318

Clustering

parameter, and the minimization is over all possible probabilistic assignments of
points to clusters. Intuitively, we would like to achieve two contradictory goals.
On one hand, we would like the mutual information between the identity of
the document and the identity of the cluster to be as small as possible. This
reflects the fact that we would like a strong compression of the original data. On
the other hand, we would like high mutual information between the clustering
variable and the identity of the words, which reflects the goal that the â€œrelevantâ€
information about the document (as reflected by the words that appear in the
document) is retained. This generalizes the classical notion of minimal sufficient
statistics2 used in parametric statistics to arbitrary distributions.
Solving the optimization problem associated with the information bottleneck
principle is hard in the general case. Some of the proposed methods are similar
to the EM principle, which we will discuss in Chapter 24.

22.5

A High Level View of Clustering
So far, we have mainly listed various useful clustering tools. However, some fundamental questions remain unaddressed. First and foremost, what is clustering?
What is it that distinguishes a clustering algorithm from any arbitrary function
that takes an input space and outputs a partition of that space? Are there any
basic properties of clustering that are independent of any specific algorithm or
task?
One method for addressing such questions is via an axiomatic approach. There
have been several attempts to provide an axiomatic definition of clustering. Let
us demonstrate this approach by presenting the attempt made by Kleinberg
(2003).
Consider a clustering function, F , that takes as input any finite domain X
with a dissimilarity function d over its pairs and returns a partition of X .
Consider the following three properties of such a function:
Scale Invariance (SI) For any domain set X , dissimilarity function d, and
any Î± > 0, the following should hold: F (X , d) = F (X , Î±d) (where
def

(Î±d)(x, y) = Î± d(x, y)).
Richness (Ri) For any finite X and every partition C = (C1 , . . . Ck ) of X (into
nonempty subsets) there exists some dissimilarity function d over X such
that F (X , d) = C.

2



P P
p(a,b)
I(x; C) = a b p(a, b) log p(a)p(b) , where the sum is over all values x can take and all
values C can take.
A sufficient statistic is a function of the data which has the property of sufficiency with
respect to a statistical model and its associated unknown parameter, meaning that â€œno
other statistic which can be calculated from the same sample provides any additional
information as to the value of the parameter.â€ For example, if we assume that a variable is
distributed normally with a unit variance and an unknown expectation, then the average
function is a sufficient statistic.

22.5 A High Level View of Clustering

319

Consistency (Co) If d and d0 are dissimilarity functions over X , such that
for every x, y âˆˆ X , if x, y belong to the same cluster in F (X , d) then
d0 (x, y) â‰¤ d(x, y) and if x, y belong to different clusters in F (X , d) then
d0 (x, y) â‰¥ d(x, y), then F (X , d) = F (X , d0 ).
A moment of reflection reveals that the Scale Invariance is a very natural
requirement â€“ it would be odd to have the result of a clustering function depend
on the units used to measure between-point distances. The Richness requirement
basically states that the outcome of the clustering function is fully controlled by
the function d, which is also a very intuitive feature. The third requirement,
Consistency, is the only requirement that refers to the basic (informal) definition
of clustering â€“ we wish that similar points will be clustered together and that
dissimilar points will be separated to different clusters, and therefore, if points
that already share a cluster become more similar, and points that are already
separated become even less similar to each other, the clustering function should
have even stronger â€œsupportâ€ of its previous clustering decisions.
However, Kleinberg (2003) has shown the following â€œimpossibilityâ€ result:
theorem 22.4 There exists no function, F , that satisfies all the three properties: Scale Invariance, Richness, and Consistency.
Proof Assume, by way of contradiction, that some F does satisfy all three
properties. Pick some domain set X with at least three points. By Richness,
there must be some d1 such that F (X , d1 ) = {{x} : x âˆˆ X } and there also exists
some d2 such that F (X , d2 ) 6= F (X , d1 ).
Let Î± âˆˆ R+ be such that for every x, y âˆˆ X , Î±d2 (x, y) â‰¥ d1 (x, y). Let d3 =
Î±d2 . Consider F (X , d3 ). By the Scale Invariance property of F , we should have
F (X , d3 ) = F (X , d2 ). On the other hand, since all distinct x, y âˆˆ X reside in
different clusters w.r.t. F (X , d1 ), and d3 (x, y) â‰¥ d1 (x, y), the Consistency of F
implies that F (X , d3 ) = F (X , d1 ). This is a contradiction, since we chose d1 , d2
so that F (X , d2 ) 6= F (X , d1 ).
It is important to note that there is no single â€œbad propertyâ€ among the three
properties. For every pair of the the three axioms, there exist natural clustering
functions that satisfy the two properties in that pair (one can even construct such
examples just by varying the stopping criteria for the Single Linkage clustering
function). On the other hand, Kleinberg shows that any clustering algorithm
that minimizes any center-based objective function inevitably fails the consistency property (yet, the k-sum-of-in-cluster-distances minimization clustering
does satisfy Consistency).
The Kleinberg impossibility result can be easily circumvented by varying the
properties. For example, if one wishes to discuss clustering functions that have
a fixed number-of-clusters parameter, then it is natural to replace Richness by
k-Richness (namely, the requirement that every partition of the domain into k
subsets is attainable by the clustering function). k-Richness, Scale Invariance
and Consistency all hold for the k-means clustering and are therefore consistent.

320

Clustering

Alternatively, one can relax the Consistency property. For example, say that two
clusterings C = (C1 , . . . Ck ) and C 0 = (C10 , . . . Cl0 ) are compatible if for every
clusters Ci âˆˆ C and Cj0 âˆˆ C 0 , either Ci âŠ† Cj0 or Cj0 âŠ† Ci or Ci âˆ© Cj0 = âˆ… (it is
worthwhile noting that for every dendrogram, every two clusterings that are obtained by trimming that dendrogram are compatible). â€œRefinement Consistencyâ€
is the requirement that, under the assumptions of the Consistency property, the
new clustering F (X , d0 ) is compatible with the old clustering F (X , d). Many
common clustering functions satisfy this requirement as well as Scale Invariance
and Richness. Furthermore, one can come up with many other, different, properties of clustering functions that sound intuitive and desirable and are satisfied
by some common clustering functions.
There are many ways to interpret these results. We suggest to view it as indicating that there is no â€œidealâ€ clustering function. Every clustering function will
inevitably have some â€œundesirableâ€ properties. The choice of a clustering function for any given task must therefore take into account the specific properties
of that task. There is no generic clustering solution, just as there is no classification algorithm that will learn every learnable task (as the No-Free-Lunch
theorem shows). Clustering, just like classification prediction, must take into
account some prior knowledge about the specific task at hand.

22.6

Summary
Clustering is an unsupervised learning problem, in which we wish to partition
a set of points into â€œmeaningfulâ€ subsets. We presented several clustering approaches including linkage-based algorithms, the k-means family, spectral clustering, and the information bottleneck. We discussed the difficulty of formalizing
the intuitive meaning of clustering.

22.7

Bibliographic Remarks
The k-means algorithm is sometimes named Lloydâ€™s algorithm, after Stuart
Lloyd, who proposed the method in 1957. For a more complete overview of
spectral clustering we refer the reader to the excellent tutorial by Von Luxburg
(2007). The information bottleneck method was introduced by Tishby, Pereira
& Bialek (1999). For an additional discussion on the axiomatic approach see
Ackerman & Ben-David (2008).

22.8

Exercises
1. Suboptimality of k-Means: For every parameter t > 1, show that there
exists an instance of the k-means problem for which the k-means algorithm

22.8 Exercises

321

(might) find a solution whose k-means objective is at least t Â· OPT, where
OPT is the minimum k-means objective.
2. k-Means Might Not Necessarily Converge to a Local Minimum:
Show that the k-means algorithm might converge to a point which is not
a local minimum. Hint: Suppose that k = 2 and the sample points are
{1, 2, 3, 4} âŠ‚ R suppose we initialize the k-means with the centers {2, 4};
and suppose we break ties in the definition of Ci by assigning i to be the
smallest value in argminj kx âˆ’ Âµj k.
3. Given a metric space (X , d), where |X | < âˆž, and k âˆˆ N, we would like to find
a partition of X into C1 , . . . , Ck which minimizes the expression
Gkâˆ’diam ((X , d), (C1 , . . . , Ck )) = max diam(Cj ),
jâˆˆ[d]

where diam(Cj ) = maxx,x0 âˆˆCj d(x, x0 ) (we use the convention diam(Cj ) = 0
if |Cj | < 2).
Similarly to the k-means objective, it is NP-hard to minimize the kdiam objective. Fortunately, we have a very simple approximation algorithm:
Initially, we pick some x âˆˆ X and set Âµ1 = x. Then, the algorithm iteratively
sets
âˆ€j âˆˆ {2, . . . , k}, Âµj = argmax min d(x, Âµi ).
xâˆˆX

iâˆˆ[jâˆ’1]

Finally, we set
âˆ€i âˆˆ [k], Ci = {x âˆˆ X : i = argmin d(x, Âµj )}.
jâˆˆ[k]

Prove that the algorithm described is a 2-approximation algorithm. That
is, if we denote its output by CÌ‚1 , . . . , CÌ‚k , and denote the optimal solution by
C1âˆ— , . . . , Ckâˆ— , then,
Gkâˆ’diam ((X , d), (CÌ‚1 , . . . , CÌ‚k )) â‰¤ 2 Â· Gkâˆ’diam ((X , d), (C1âˆ— , . . . , Ckâˆ— )).
Hint: Consider the point Âµk+1 (in other words, the next center we would have
chosen, if we wanted k + 1 clusters). Let r = minjâˆˆ[k] d(Âµj , Âµk+1 ). Prove the
following inequalities
Gkâˆ’diam ((X , d), (CÌ‚1 , . . . , CÌ‚k )) â‰¤ 2r
Gkâˆ’diam ((X, d), (C1âˆ— , . . . , Ckâˆ— )) â‰¥ r.
4. Recall that a clustering function, F , is called Center-Based Clustering if, for
some monotonic function f : R+ â†’ R+ , on every given input (X , d), F (X , d)
is a clustering that minimizes the objective
Gf ((X , d), (C1 , . . . Ck )) =

min

Âµ1 ,...Âµk âˆˆX 0

where X 0 is either X or some superset of X .

k X
X
i=1 xâˆˆCi

f (d(x, Âµi )),

322

Clustering

Prove that for every k > 1 the k-diam clustering function defined in the
previous exercise is not a center-based clustering function.
Hint: Given a clustering input (X , d), with |X | > 2, consider the effect of
adding many close-by points to some (but not all) of the members of X , on
either the k-diam clustering or any given center-based clustering.
5. Recall that we discussed three clustering â€œpropertiesâ€: Scale Invariance, Richness, and Consistency. Consider the Single Linkage clustering algorithm.
1. Find which of the three properties is satisfied by Single Linkage with the
Fixed Number of Clusters (any fixed nonzero number) stopping rule.
2. Find which of the three properties is satisfied by Single Linkage with the
Distance Upper Bound (any fixed nonzero upper bound) stopping rule.
3. Show that for any pair of these properties there exists a stopping criterion
for Single Linkage clustering, under which these two axioms are satisfied.
6. Given some number k, let k-Richness be the following requirement:
For any finite X and every partition C = (C1 , . . . Ck ) of X (into nonempty subsets)
there exists some dissimilarity function d over X such that F (X , d) = C.

Prove that, for every number k, there exists a clustering function that
satisfies the three properties: Scale Invariance, k-Richness, and Consistency.

23 Dimensionality Reduction

Dimensionality reduction is the process of taking data in a high dimensional
space and mapping it into a new space whose dimensionality is much smaller.
This process is closely related to the concept of (lossy) compression in information theory. There are several reasons to reduce the dimensionality of the
data. First, high dimensional data impose computational challenges. Moreover,
in some situations high dimensionality might lead to poor generalization abilities of the learning algorithm (for example, in Nearest Neighbor classifiers the
sample complexity increases exponentially with the dimensionâ€”see Chapter 19).
Finally, dimensionality reduction can be used for interpretability of the data, for
finding meaningful structure of the data, and for illustration purposes.
In this chapter we describe popular methods for dimensionality reduction. In
those methods, the reduction is performed by applying a linear transformation
to the original data. That is, if the original data is in Rd and we want to embed
it into Rn (n < d) then we would like to find a matrix W âˆˆ Rn,d that induces
the mapping x 7â†’ W x. A natural criterion for choosing W is in a way that will
enable a reasonable recovery of the original x. It is not hard to show that in
general, exact recovery of x from W x is impossible (see Exercise 1).
The first method we describe is called Principal Component Analysis (PCA).
In PCA, both the compression and the recovery are performed by linear transformations and the method finds the linear transformations for which the differences
between the recovered vectors and the original vectors are minimal in the least
squared sense.
Next, we describe dimensionality reduction using random matrices W . We
derive an important lemma, often called the â€œJohnson-Lindenstrauss lemma,â€
which analyzes the distortion caused by such a random dimensionality reduction
technique.
Last, we show how one can reduce the dimension of all sparse vectors using
again a random matrix. This process is known as Compressed Sensing. In this
case, the recovery process is nonlinear but can still be implemented efficiently
using linear programming.
We conclude by underscoring the underlying â€œprior assumptionsâ€ behind PCA
and compressed sensing, which can help us understand the merits and pitfalls of
the two methods.
c 2014 by Shai Shalev-Shwartz and Shai Ben-David
Understanding Machine Learning, 
Published 2014 by Cambridge University Press.
Personal use only. Not for distribution. Do not post.
Please link to http://www.cs.huji.ac.il/~shais/UnderstandingMachineLearning

324

Dimensionality Reduction

23.1

Principal Component Analysis (PCA)
Let x1 , . . . , xm be m vectors in Rd . We would like to reduce the dimensionality of these vectors using a linear transformation. A matrix W âˆˆ Rn,d , where
n < d, induces a mapping x 7â†’ W x, where W x âˆˆ Rn is the lower dimensionality
representation of x. Then, a second matrix U âˆˆ Rd,n can be used to (approximately) recover each original vector x from its compressed version. That is, for
a compressed vector y = W x, where y is in the low dimensional space Rn , we
can construct xÌƒ = U y, so that xÌƒ is the recovered version of x and resides in the
original high dimensional space Rd .
In PCA, we find the compression matrix W and the recovering matrix U so
that the total squared distance between the original and recovered vectors is
minimal; namely, we aim at solving the problem
argmin

m
X

W âˆˆRn,d ,U âˆˆRd,n i=1

kxi âˆ’ U W xi k22 .

(23.1)

To solve this problem we first show that the optimal solution takes a specific
form.
lemma 23.1 Let (U, W ) be a solution to Equation (23.1). Then the columns of
U are orthonormal (namely, U > U is the identity matrix of Rn ) and W = U > .
Proof Fix any U, W and consider the mapping x 7â†’ U W x. The range of this
mapping, R = {U W x : x âˆˆ Rd }, is an n dimensional linear subspace of Rd . Let
V âˆˆ Rd,n be a matrix whose columns form an orthonormal basis of this subspace,
namely, the range of V is R and V > V = I. Therefore, each vector in R can be
written as V y where y âˆˆ Rn . For every x âˆˆ Rd and y âˆˆ Rn we have
kx âˆ’ V yk22 = kxk2 + y> V > V y âˆ’ 2y> V > x = kxk2 + kyk2 âˆ’ 2y> (V > x),
where we used the fact that V > V is the identity matrix of Rn . Minimizing the
preceding expression with respect to y by comparing the gradient with respect
to y to zero gives that y = V > x. Therefore, for each x we have that
V V > x = argmin kx âˆ’ xÌƒk22 .
xÌƒâˆˆR

In particular this holds for x1 , . . . , xm and therefore we can replace U, W by
V, V > and by that do not increase the objective
m
X

kxi âˆ’ U W xi k22 â‰¥

i=1

m
X

kxi âˆ’ V V > xi k22 .

i=1

Since this holds for every U, W the proof of the lemma follows.
On the basis of the preceding lemma, we can rewrite the optimization problem
given in Equation (23.1) as follows:
argmin

m
X

U âˆˆRd,n :U > U =I i=1

kxi âˆ’ U U > xi k22 .

(23.2)

23.1 Principal Component Analysis (PCA)

325

We further simplify the optimization problem by using the following elementary
algebraic manipulations. For every x âˆˆ Rd and a matrix U âˆˆ Rd,n such that
U > U = I we have
kx âˆ’ UU > xk2 = kxk2 âˆ’ 2x> UU > x + x> U U > UU > x
= kxk2 âˆ’ x> UU > x
= kxk2 âˆ’ trace(U > xx> U ),

(23.3)

where the trace of a matrix is the sum of its diagonal entries. Since the trace is
a linear operator, this allows us to rewrite Equation (23.2) as follows:
!
m
X
argmax trace U >
xi x>
.
(23.4)
i U
U âˆˆRd,n :U > U =I

i=1

Pm

>
i=1 xi xi .

Let A =
The matrix A is symmetric and therefore it can be
written using its spectral decomposition as A = VDV > , where D is diagonal and
V > V = VV > = I. Here, the elements on the diagonal of D are the eigenvalues of
A and the columns of V are the corresponding eigenvectors. We assume without
loss of generality that D1,1 â‰¥ D2,2 â‰¥ Â· Â· Â· â‰¥ Dd,d . Since A is positive semidefinite
it also holds that Dd,d â‰¥ 0. We claim that the solution to Equation (23.4) is
the matrix U whose columns are the n eigenvectors of A corresponding to the
largest n eigenvalues.
Pm
theorem 23.2 Let x1 , . . . , xm be arbitrary vectors in Rd , let A = i=1 xi x>
i ,
and let u1 , . . . , un be n eigenvectors of the matrix A corresponding to the largest
n eigenvalues of A. Then, the solution to the PCA optimization problem given
in Equation (23.1) is to set U to be the matrix whose columns are u1 , . . . , un
and to set W = U > .
Proof Let VDV > be the spectral decomposition of A. Fix some matrix U âˆˆ Rd,n
with orthonormal columns and let B = V > U . Then, VB = VV > U = U . It
follows that
U > AU = B > V > VDV > VB = B > DB,
and therefore
trace(U > AU ) =

d
X

Dj,j

j=1

n
X

2
Bj,i
.

i=1

Note that B > B = U > VV > U = U > U = I. Therefore, the columns of B are
Pd Pn
2
= n. In addition, let BÌƒ âˆˆ
also orthonormal, which implies that j=1 i=1 Bj,i
d,d
R
be a matrix such that its first n columns are the columns of B and in
Pd
2
addition BÌƒ > BÌƒ = I. Then, for every j we have i=1 BÌƒj,i
= 1, which implies that
Pn
2
B
â‰¤
1.
It
follows
that:
i=1 j,i
trace(U > AU ) â‰¤

max

Î²âˆˆ[0,1]d : kÎ²k1 â‰¤n

d
X
j=1

Dj,j Î²j .

326

Dimensionality Reduction

It is not hard to verify (see Exercise 2) that the right-hand side equals to
Pn
matrix U âˆˆ Rd,n with orj=1 Dj,j . We have therefore shown that for every
Pn
>
thonormal columns it holds that trace(U AU ) â‰¤ j=1 Dj,j . On the other hand,
if we set U to be the matrix whose columns are the n leading eigenvectors of A
Pn
we obtain that trace(U > AU ) = j=1 Dj,j , and this concludes our proof.
Remark 23.1 The proof of Theorem 23.2 also tells us that the value of the
Pn
objective of Equation (23.4) is i=1 Di,i . Combining this with Equation (23.3)
Pm
Pd
and noting that i=1 kxi k2 = trace(A) = i=1 Di,i we obtain that the optimal
Pd
objective value of Equation (23.1) is i=n+1 Di,i .
Remark 23.2 It is a common practice to â€œcenterâ€ the examples before applying
Pm
1
PCA. That is, we first calculate Âµ = m
i=1 xi and then apply PCA on the
vectors (x1 âˆ’ Âµ), . . . , (xm âˆ’ Âµ). This is also related to the interpretation of PCA
as variance maximization (see Exercise 4).

23.1.1

A More Efficient Solution for the Case d  m
In some situations the original dimensionality of the data is much larger than
the number of examples m. The computational complexity of calculating the
PCA solution as described previously is O(d3 ) (for calculating eigenvalues of A)
plus O(md2 ) (for constructing the matrix A). We now show a simple trick that
enables us to calculate the PCA solution more efficiently when d  m.
Pm
Recall that the matrix A is defined to be i=1 xi x>
i . It is convenient to rewrite
A = X > X where X âˆˆ Rm,d is a matrix whose ith row is x>
i . Consider the
matrix B = XX > . That is, B âˆˆ Rm,m is the matrix whose i, j element equals
hxi , xj i. Suppose that u is an eigenvector of B: That is, Bu = Î»u for some
Î» âˆˆ R. Multiplying the equality by X > and using the definition of B we obtain
X > XX > u = Î»X > u. But, using the definition of A, we get that A(X > u) =
X>u
Î»(X > u). Thus, kX
> uk is an eigenvector of A with eigenvalue of Î».
We can therefore calculate the PCA solution by calculating the eigenvalues of
B instead of A. The complexity is O(m3 ) (for calculating eigenvalues of B) and
m2 d (for constructing the matrix B).
Remark 23.3 The previous discussion also implies that to calculate the PCA
solution we only need to know how to calculate inner products between vectors.
This enables us to calculate PCA implicitly even when d is very large (or even
infinite) using kernels, which yields the kernel PCA algorithm.

23.1.2

Implementation and Demonstration
A pseudocode of PCA is given in the following.

23.1 Principal Component Analysis (PCA)

327

1.5

1

0.5

0

âˆ’0.5

âˆ’1

âˆ’1.5
âˆ’1.5

âˆ’1

âˆ’0.5

0

0.5

1

1.5

Figure 23.1 A set of vectors in R2 (blue xâ€™s) and their reconstruction after

dimensionality reduction to R1 using PCA (red circles).

PCA
input
A matrix of m examples X âˆˆ Rm,d
number of components n
if (m > d)
A = X >X
Let u1 , . . . , un be the eigenvectors of A with largest eigenvalues
else
B = XX >
Let v1 , . . . , vn be the eigenvectors of B with largest eigenvalues
for i = 1, . . . , n set ui = kX >1 vi k X > vi
output: u1 , . . . , un
To illustrate how PCA works, let us generate vectors in R2 that approximately
reside on a line, namely, on a one dimensional subspace of R2 . For example,
suppose that each example is of the form (x, x + y) where x is chosen uniformly
at random from [âˆ’1, 1] and y is sampled from a Gaussian distribution with mean
0 and standard deviation of 0.1. Suppose we apply PCA on this data. Then, the
eigenvector
âˆš
âˆš corresponding to the largest eigenvalue will be close to the vector
(1/ 2, 1/ 2). When projecting a point (x, x + y) on this principal component
âˆš . The reconstruction of the original vector will be
we will obtain the scalar 2x+y
2
((x + y/2), (x + y/2)). In Figure 23.1 we depict the original versus reconstructed
data.
Next, we demonstrate the effectiveness of PCA on a data set of faces. We
extracted images of faces from the Yale data set (Georghiades, Belhumeur &
Kriegman 2001). Each image contains 50Ã—50 = 2500 pixels; therefore the original
dimensionality is very high.

328

Dimensionality Reduction

o

x
+ +
++
+++

o oo oo o

xxx x xx
*

* **

**

Figure 23.2 Images of faces extracted from the Yale data set. Top-Left: the original

images in R50x50 . Top-Right: the images after dimensionality reduction to R10 and
reconstruction. Middle row: an enlarged version of one of the images before and after
PCA. Bottom: The images after dimensionality reduction to R2 . The different marks
indicate different individuals.

Some images of faces are depicted on the top-left side of Figure 23.2. Using
PCA, we reduced the dimensionality to R10 and reconstructed back to the original dimension, which is 502 . The resulting reconstructed images are depicted
on the top-right side of Figure 23.2. Finally, on the bottom of Figure 23.2 we
depict a 2 dimensional representation of the images. As can be seen, even from a
2 dimensional representation of the images we can still roughly separate different
individuals.

23.2 Random Projections

23.2

329

Random Projections
In this section we show that reducing the dimension by using a random linear
transformation leads to a simple compression scheme with a surprisingly low
distortion. The transformation x 7â†’ W x, when W is a random matrix, is often
referred to as a random projection. In particular, we provide a variant of a famous
lemma due to Johnson and Lindenstrauss, showing that random projections do
not distort Euclidean distances too much.
Let x1 , x2 be two vectors in Rd . A matrix W does not distort too much the
distance between x1 and x2 if the ratio
kW x1 âˆ’ W x2 k
kx1 âˆ’ x2 k
is close to 1. In other words, the distances between x1 and x2 before and after
the transformation are almost the same. To show that kW x1 âˆ’ W x2 k is not too
far away from kx1 âˆ’ x2 k it suffices to show that W does not distort the norm of
the difference vector x = x1 âˆ’ x2 . Therefore, from now on we focus on the ratio
kW xk
kxk .
We start with analyzing the distortion caused by applying a random projection
to a single vector.
lemma 23.3 Fix some x âˆˆ Rd . Let W âˆˆ Rn,d be a random matrix such that
each Wi,j is an independent normal random variable. Then, for every  âˆˆ (0, 3)
we have

" 
#
 k(1/âˆšn)W xk2

2


P 
âˆ’ 1 > 
â‰¤ 2 eâˆ’ n/6 .
2


kxk
Proof Without loss of generality we can assume that kxk2 = 1. Therefore, an
equivalent inequality is


2
P (1 âˆ’ )n â‰¤ kW xk2 â‰¤ (1 + )n â‰¥ 1 âˆ’ 2eâˆ’ n/6 .
Let wi be the ith row of W . The random variable hwi , xi is a weighted sum of
d independent normal random variables and therefore it is normally distributed
P
with zero mean and variance j x2j = kxk2 = 1. Therefore, the random variP
n
2
2
able kW xk2 =
i=1 (hwi , xi) has a Ï‡n distribution. The claim now follows
directly from a measure concentration property of Ï‡2 random variables stated in
Lemma B.12 given in Section B.7.
The Johnson-Lindenstrauss lemma follows from this using a simple union
bound argument.
lemma 23.4 (Johnson-Lindenstrauss Lemma) Let Q be a finite set of vectors
in Rd . Let Î´ âˆˆ (0, 1) and n be an integer such that
r
6 log(2|Q|/Î´)
=
â‰¤ 3.
n

330

Dimensionality Reduction

Then, with probability of at least 1âˆ’Î´ over a choice of a random matrix W âˆˆ Rn,d
such that each element of W is distributed normally with zero mean and variance
of 1/n we have



 kW xk2

sup 
âˆ’ 1 < .
2
kxk
xâˆˆQ
Proof Combining Lemma 23.3 and the union bound we have that for every
 âˆˆ (0, 3):




 kW xk2

2


P sup 
âˆ’ 1 >  â‰¤ 2 |Q| eâˆ’ n/6 .
2
kxk
xâˆˆQ
Let Î´ denote the right-hand side of the inequality; thus we obtain that
r
6 log(2|Q|/Î´)
=
.
n
Interestingly, the bound given in Lemma 23.4 does not depend on the original
dimension of x. In fact, the bound holds even if x is in an infinite dimensional
Hilbert space.

23.3

Compressed Sensing
Compressed sensing is a dimensionality reduction technique which utilizes a prior
assumption that the original vector is sparse in some basis. To motivate compressed sensing, consider a vector x âˆˆ Rd that has at most s nonzero elements.
That is,
def

kxk0 = |{i : xi 6= 0}| â‰¤ s.
Clearly, we can compress x by representing it using s (index,value) pairs. Furthermore, this compression is lossless â€“ we can reconstruct x exactly from the s
(index,value) pairs. Now, lets take one step forward and assume that x = U Î±,
where Î± is a sparse vector, kÎ±k0 â‰¤ s, and U is a fixed orthonormal matrix. That
is, x has a sparse representation in another basis. It turns out that many natural vectors are (at least approximately) sparse in some representation. In fact,
this assumption underlies many modern compression schemes. For example, the
JPEG-2000 format for image compression relies on the fact that natural images
are approximately sparse in a wavelet basis.
Can we still compress x into roughly s numbers? Well, one simple way to do
this is to multiply x by U > , which yields the sparse vector Î±, and then represent
Î± by its s (index,value) pairs. However, this requires us first to â€œsenseâ€ x, to
store it, and then to multiply it by U > . This raises a very natural question: Why
go to so much effort to acquire all the data when most of what we get will be
thrown away? Cannot we just directly measure the part that will not end up
being thrown away?

23.3 Compressed Sensing

331

Compressed sensing is a technique that simultaneously acquires and compresses the data. The key result is that a random linear transformation can
compress x without losing information. The number of measurements needed is
order of s log(d). That is, we roughly acquire only the important information
about the signal. As we will see later, the price we pay is a slower reconstruction
phase. In some situations, it makes sense to save time in compression even at
the price of a slower reconstruction. For example, a security camera should sense
and compress a large amount of images while most of the time we do not need to
decode the compressed data at all. Furthermore, in many practical applications,
compression by a linear transformation is advantageous because it can be performed efficiently in hardware. For example, a team led by Baraniuk and Kelly
has proposed a camera architecture that employs a digital micromirror array to
perform optical calculations of a linear transformation of an image. In this case,
obtaining each compressed measurement is as easy as obtaining a single raw
measurement. Another important application of compressed sensing is medical
imaging, in which requiring fewer measurements translates to less radiation for
the patient.
Informally, the main premise of compressed sensing is the following three â€œsurprisingâ€ results:
1. It is possible to reconstruct any sparse signal fully if it was compressed by
x 7â†’ W x, where W is a matrix which satisfies a condition called the Restricted Isoperimetric Property (RIP). A matrix that satisfies this property is
guaranteed to have a low distortion of the norm of any sparse representable
vector.
2. The reconstruction can be calculated in polynomial time by solving a linear
program.
3. A random n Ã— d matrix is likely to satisfy the RIP condition provided that n
is greater than an order of s log(d).
Formally,
definition 23.5 (RIP)
kxk0 â‰¤ s we have

A matrix W âˆˆ Rn,d is (, s)-RIP if for all x 6= 0 s.t.



 kW xk22


 kxk2 âˆ’ 1 â‰¤ .
2

The first theorem establishes that RIP matrices yield a lossless compression
scheme for sparse vectors. It also provides a (nonefficient) reconstruction scheme.
theorem 23.6 Let  < 1 and let W be a (, 2s)-RIP matrix. Let x be a vector
s.t. kxk0 â‰¤ s, let y = W x be the compression of x, and let
xÌƒ âˆˆ argmin kvk0
v:W v=y

be a reconstructed vector. Then, xÌƒ = x.

332

Dimensionality Reduction

Proof We assume, by way of contradiction, that xÌƒ 6= x. Since x satisfies the
constraints in the optimization problem that defines xÌƒ we clearly have that
kxÌƒk0 â‰¤ kxk0 â‰¤ s. Therefore, kx âˆ’ xÌƒk0 â‰¤ 2s and we can apply the RIP inequality on the vector x âˆ’ xÌƒ. But, since W (x âˆ’ xÌƒ) = 0 we get that |0 âˆ’ 1| â‰¤ ,
which leads to a contradiction.
The reconstruction scheme given in Theorem 23.6 seems to be nonefficient
because we need to minimize a combinatorial objective (the sparsity of v). Quite
surprisingly, it turns out that we can replace the combinatorial objective, kvk0 ,
with a convex objective, kvk1 , which leads to a linear programming problem that
can be solved efficiently. This is stated formally in the following theorem.
theorem 23.7 Assume that the conditions of Theorem 23.6 holds and that
 < 1+1âˆš2 . Then,
x = argmin kvk0 = argmin kvk1 .
v:W v=y

v:W v=y

In fact, we will prove a stronger result, which holds even if x is not a sparse
vector.
theorem 23.8 Let  < 1+1âˆš2 and let W be a (, 2s)-RIP matrix. Let x be an
arbitrary vector and denote
xs âˆˆ argmin kx âˆ’ vk1 .
v:kvk0 â‰¤s

That is, xs is the vector which equals x on the s largest elements of x and equals
0 elsewhere. Let y = W x be the compression of x and let
x? âˆˆ argmin kvk1
v:W v=y

be the reconstructed vector. Then,
kx? âˆ’ xk2 â‰¤ 2
where Ï =

âˆš

1 + Ï âˆ’1/2
s
kx âˆ’ xs k1 ,
1âˆ’Ï

2/(1 âˆ’ ).

Note that in the special case that x = xs we get an exact recovery, x? = x, so
Theorem 23.7 is a special case of Theorem 23.8. The proof of Theorem 23.8 is
given in Section 23.3.1.
Finally, the third result tells us that random matrices with n â‰¥ â„¦(s log(d)) are
likely to be RIP. In fact, the theorem shows that multiplying a random matrix
by an orthonormal matrix also provides an RIP matrix. This is important for
compressing signals of the form x = U Î± where x is not sparse but Î± is sparse.
In that case, if W is a random matrix and we compress using y = W x then this
is the same as compressing Î± by y = (W U )Î± and since W U is also RIP we can
reconstruct Î± (and thus also x) from y.

23.3 Compressed Sensing

333

theorem 23.9 Let U be an arbitrary fixed d Ã— d orthonormal matrix, let , Î´
be scalars in (0, 1), let s be an integer in [d], and let n be an integer that satisfies
n â‰¥ 100

s log(40d/(Î´ ))
.
2

Let W âˆˆ Rn,d be a matrix s.t. each element of W is distributed normally with
zero mean and variance of 1/n. Then, with proabability of at least 1 âˆ’ Î´ over the
choice of W , the matrix W U is (, s)-RIP.

23.3.1

Proofs*
Proof of Theorem 23.8
We follow a proof due to CandeÌ€s (2008).
Let h = x? âˆ’ x. Given a vector v and a set of indices I we denote by vI the
vector whose ith element is vi if i âˆˆ I and 0 otherwise.
The first trick we use is to partition the set of indices [d] = {1, . . . , d} into
disjoint sets of size s. That is, we will write [d] = T0 âˆªÂ· T1 âˆªÂ· T2 . . . Td/sâˆ’1 where
for all i, |Ti | = s, and we assume for simplicity that d/s is an integer. We define
the partition as follows. In T0 we put the s indices corresponding to the s largest
elements in absolute values of x (ties are broken arbitrarily). Let T0c = [d] \ T0 .
Next, T1 will be the s indices corresponding to the s largest elements in absolute
c
value of hT0c . Let T0,1 = T0 âˆª T1 and T0,1
= [d] \ T0,1 . Next, T2 will correspond to
c . And, we will construct T3 , T4 , . . .
the s largest elements in absolute value of hT0,1
in the same way.
To prove the theorem we first need the following lemma, which shows that
RIP also implies approximate orthogonality.
lemma 23.10 Let W be an (, 2s)-RIP matrix. Then, for any two disjoint sets
I, J, both of size at most s, and for any vector u we have that hW uI , W uJ i â‰¤
kuI k2 kuJ k2 .
Proof

W.l.o.g. assume kuI k2 = kuJ k2 = 1.
hW uI , W uJ i =

kW uI + W uJ k22 âˆ’ kW uI âˆ’ W uJ k22
.
4

But, since |J âˆª I| â‰¤ 2s we get from the RIP condition that kW uI + W uJ k22 â‰¤
(1 + )(kuI k22 + kuJ k22 ) = 2(1 + ) and that âˆ’kW uI âˆ’ W uJ k22 â‰¤ âˆ’(1 âˆ’ )(kuI k22 +
kuJ k22 ) = âˆ’2(1 âˆ’ ), which concludes our proof.
We are now ready to prove the theorem. Clearly,
c k2 â‰¤ khT
c
khk2 = khT0,1 + hT0,1
0,1 k2 + khT0,1 k2 .

To prove the theorem we will show the following two claims:
âˆ’1/2
c k2 â‰¤ khT k2 + 2s
Claim 1:. khT0,1
kx âˆ’ xs k1 .
0
2Ï âˆ’1/2
Claim 2:. khT0,1 k2 â‰¤ 1âˆ’Ï s
kx âˆ’ xs k1 .

(23.5)

334

Dimensionality Reduction

Combining these two claims with Equation (23.5) we get that
c k2 â‰¤ 2khT
khk2 â‰¤ khT0,1 k2 + khT0,1
k + 2sâˆ’1/2 kx âˆ’ xs k1
0,1 2


2Ï
+ 1 sâˆ’1/2 kx âˆ’ xs k1
â‰¤ 2 1âˆ’Ï

=2

1 + Ï âˆ’1/2
s
kx âˆ’ xs k1 ,
1âˆ’Ï

and this will conclude our proof.

Proving Claim 1:
To prove this claim we do not use the RIP condition at all but only use the fact
that x? minimizes the `1 norm. Take j > 1. For each i âˆˆ Tj and i0 âˆˆ Tjâˆ’1 we
have that |hi | â‰¤ |hi0 |. Therefore, khTj kâˆž â‰¤ khTjâˆ’1 k1 /s. Thus,
khTj k2 â‰¤ s1/2 khTj kâˆž â‰¤ sâˆ’1/2 khTjâˆ’1 k1 .
Summing this over j = 2, 3, . . . and using the triangle inequality we obtain that
X
c k2 â‰¤
khT0,1
khTj k2 â‰¤ sâˆ’1/2 khT0c k1
(23.6)
jâ‰¥2

Next, we show that khT0c k1 cannot be large. Indeed, from the definition of x?
we have that kxk1 â‰¥ kx? k1 = kx + hk1 . Thus, using the triangle inequality we
obtain that
X
X
kxk1 â‰¥ kx+hk1 =
|xi +hi |+
|xi +hi | â‰¥ kxT0 k1 âˆ’khT0 k1 +khT0c k1 âˆ’kxT0c k1
iâˆˆT0c

iâˆˆT0

(23.7)
and since kxT0c k1 = kx âˆ’ xs k1 = kxk1 âˆ’ kxT0 k1 we get that
khT0c k1 â‰¤ khT0 k1 + 2kxT0c k1 .

(23.8)

Combining this with Equation (23.6) we get that

âˆ’1/2
c k2 â‰¤ s
khT0,1
khT0 k1 + 2kxT0c k1 â‰¤ khT0 k2 + 2sâˆ’1/2 kxT0c k1 ,
which concludes the proof of claim 1.

Proving Claim 2:
For the second claim we use the RIP condition to get that
(1 âˆ’ )khT0,1 k22 â‰¤ kW hT0,1 k22 .
(23.9)
P
P
Since W hT0,1 = W h âˆ’ jâ‰¥2 W hTj = âˆ’ jâ‰¥2 W hTj we have that
X
X
kW hT0,1 k22 = âˆ’
hW hT0,1 , W hTj i = âˆ’
hW hT0 + W hT1 , W hTj i.
jâ‰¥2

jâ‰¥2

From the RIP condition on inner products we obtain that for all i âˆˆ {1, 2} and
j â‰¥ 2 we have
|hW hTi , W hTj i| â‰¤ khTi k2 khTj k2 .

23.3 Compressed Sensing

Since khT0 k2 + khT1 k2 â‰¤

335

âˆš

2khT0,1 k2 we therefore get that
X
âˆš
kW hT0,1 k22 â‰¤ 2khT0,1 k2
khTj k2 .
jâ‰¥2

Combining this with Equation (23.6) and Equation (23.9) we obtain
âˆš
(1 âˆ’ )khT0,1 k22 â‰¤ 2khT0,1 k2 sâˆ’1/2 khT0c k1 .
Rearranging the inequality gives
âˆš

khT0,1 k2 â‰¤

2 âˆ’1/2
s
khT0c k1 .
1âˆ’

Finally, using Equation (23.8) we get that
khT0,1 k2 â‰¤ Ïsâˆ’1/2 (khT0 k1 + 2kxT0c k1 ) â‰¤ ÏkhT0 k2 + 2Ïsâˆ’1/2 kxT0c k1 ,
but since khT0 k2 â‰¤ khT0,1 k2 this implies
khT0,1 k2 â‰¤

2Ï âˆ’1/2
s
kxT0c k1 ,
1âˆ’Ï

which concludes the proof of the second claim.

Proof of Theorem 23.9
To prove the theorem we follow an approach due to (Baraniuk, Davenport, DeVore & Wakin 2008). The idea is to combine the Johnson-Lindenstrauss (JL)
lemma with a simple covering argument.
We start with a covering property of the unit ball.
d
lemma 23.11 Let  âˆˆ (0, 1). There exists a finite set Q âŠ‚ Rd of size |Q| â‰¤ 3
such that
sup

min kx âˆ’ vk â‰¤ .

x:kxkâ‰¤1 vâˆˆQ

Proof

Let k be an integer and let
Q0 = {x âˆˆ Rd : âˆ€j âˆˆ [d], âˆƒi âˆˆ {âˆ’k, âˆ’k + 1, . . . , k} s.t. xj = ki }.

Clearly, |Q0 | = (2k + 1)d . We shall set Q = Q0 âˆ© B2 (1), where B2 (1) is the unit
`2 ball of Rd . Since the points in Q0 are distributed evenly on the unit `âˆž ball,
the size of Q is the size of Q0 times the ratio between the volumes of the unit `2
and `âˆž balls. The volume of the `âˆž ball is 2d and the volume of B2 (1) is
Ï€ d/2
.
Î“(1 + d/2)
For simplicity, assume that d is even and therefore
 d/2
Î“(1 + d/2) = (d/2)! â‰¥ d/2
,
e

336

Dimensionality Reduction

where in the last inequality we used Stirlingâ€™s approximation. Overall we obtained
that
|Q| â‰¤ (2k + 1)d (Ï€/e)d/2 (d/2)âˆ’d/2 2âˆ’d .

(23.10)

Now lets specify k. For each x âˆˆ B2 (1) let v âˆˆ Q be the vector whose ith element
is sign(xi ) b|xi | kc/k. Then, for each element we have that |xi âˆ’ vi | â‰¤ 1/k and
thus
âˆš
d
kx âˆ’ vk â‰¤
.
k
âˆš
To ensure that the right-hand side will be at most  we shall set k = d d/e.
Plugging this value into Equation (23.10) we conclude that
 q d
âˆš
d
Ï€
|Q| â‰¤ (3 d/(2))d (Ï€/e)d/2 (d/2)âˆ’d/2 = 3 2e
â‰¤ 3 .

Let x be a vector that can be written as x = U Î± with U being some orthonormal matrix and kÎ±k0 â‰¤ s. Combining the earlier covering property and the JL
lemma (Lemma 23.4) enables us to show that a random W will not distort any
such x.
lemma 23.12 Let U be an orthonormal d Ã— d matrix and let I âŠ‚ [d] be a set
of indices of size |I| = s. Let S be the span of {Ui : i âˆˆ I}, where Ui is the ith
column of U . Let Î´ âˆˆ (0, 1),  âˆˆ (0, 1), and n âˆˆ N such that
n â‰¥ 24

log(2/Î´) + s log(12/)
.
2

Then, with probability of at least 1âˆ’Î´ over a choice of a random matrix W âˆˆ Rn,d
such that each element of W is independently distributed according to N (0, 1/n),
we have


 kW xk

sup 
âˆ’ 1 < .
kxk
xâˆˆS
Proof It suffices to prove the lemma for all x âˆˆ S with kxk = 1. We can write
x = UI Î± where Î± âˆˆ Rs , kÎ±k2 = 1, and UI is the matrix whose columns are
{Ui : i âˆˆ I}. Using Lemma 23.11 we know that there exists a set Q of size
|Q| â‰¤ (12/)s such that
sup

min kÎ± âˆ’ vk â‰¤ (/4).

Î±:kÎ±k=1 vâˆˆQ

But since U is orthogonal we also have that
sup

min kUI Î± âˆ’ UI vk â‰¤ (/4).

Î±:kÎ±k=1 vâˆˆQ

Applying Lemma 23.4 on the set {UI v : v âˆˆ Q} we obtain that for n satisfying

23.3 Compressed Sensing

337

the condition given in the lemma, the following holds with probability of at least
1 âˆ’ Î´:



 kW UI vk2
 â‰¤ /2,
âˆ’
1
sup 

2
kUI vk
vâˆˆQ
This also implies that


 kW UI vk


âˆ’ 1 â‰¤ /2.
sup 
kUI vk
vâˆˆQ
Let a be the smallest number such that
âˆ€x âˆˆ S,

kW xk
â‰¤ 1 + a.
kxk

Clearly a < âˆž. Our goal is to show that a â‰¤ . This follows from the fact that
for any x âˆˆ S of unit norm there exists v âˆˆ Q such that kx âˆ’ UI vk â‰¤ /4 and
therefore
kW xk â‰¤ kW UI vk + kW (x âˆ’ UI v)k â‰¤ 1 + /2 + (1 + a)/4.
Thus,
âˆ€x âˆˆ S,

kW xk
â‰¤ 1 + (/2 + (1 + a)/4) .
kxk

But the definition of a implies that
a â‰¤ /2 + (1 + a)/4 â‡’ a â‰¤
This proves that for all x âˆˆ S we have
this as well since

kW xk
kxk

/2 + /4
â‰¤ .
1 âˆ’ /4

âˆ’ 1 â‰¤ . The other side follows from

kW xk â‰¥ kW UI vk âˆ’ kW (x âˆ’ UI v)k â‰¥ 1 âˆ’ /2 âˆ’ (1 + )/4 â‰¥ 1 âˆ’ .

The preceding lemma tells us that for x âˆˆ S of unit norm we have
(1 âˆ’ ) â‰¤ kW xk â‰¤ (1 + ),
which implies that
(1 âˆ’ 2 ) â‰¤ kW xk2 â‰¤ (1 + 3 ).
The proof of Theorem 23.9 follows from this by a union bound over all choices
of I.

338

Dimensionality Reduction

23.4

PCA or Compressed Sensing?
Suppose we would like to apply a dimensionality reduction technique to a given
set of examples. Which method should we use, PCA or compressed sensing? In
this section we tackle this question, by underscoring the underlying assumptions
behind the two methods.
It is helpful first to understand when each of the methods can guarantee perfect recovery. PCA guarantees perfect recovery whenever the set of examples is
contained in an n dimensional subspace of Rd . Compressed sensing guarantees
perfect recovery whenever the set of examples is sparse (in some basis). On the
basis of these observations, we can describe cases in which PCA will be better
than compressed sensing and vice versa.
As a first example, suppose that the examples are the vectors of the standard
basis of Rd , namely, e1 , . . . , ed , where each ei is the all zeros vector except 1 in the
ith coordinate. In this case, the examples are 1-sparse. Hence, compressed sensing
will yield a perfect recovery whenever n â‰¥ â„¦(log(d)). On the other hand, PCA
will lead to poor performance, since the data is far from being in an n dimensional
subspace, as long as n < d. Indeed, it is easy ro verify that in such a case, the
averaged recovery error of PCA (i.e., the objective of Equation (23.1) divided by
m) will be (d âˆ’ n)/d, which is larger than 1/2 whenever n â‰¤ d/2.
We next show a case where PCA is better than compressed sensing. Consider
m examples that are exactly on an n dimensional subspace. Clearly, in such a
case, PCA will lead to perfect recovery. As to compressed sensing, note that
the examples are n-sparse in any orthonormal basis whose first n vectors span
the subspace. Therefore, compressed sensing would also work if we will reduce
the dimension to â„¦(n log(d)). However, with exactly n dimensions, compressed
sensing might fail. PCA has also better resilience to certain types of noise. See
(Chang, Weiss & Freeman 2009) for a discussion.

23.5

Summary
We introduced two methods for dimensionality reduction using linear transformations: PCA and random projections. We have shown that PCA is optimal in
the sense of averaged squared reconstruction error, if we restrict the reconstruction procedure to be linear as well. However, if we allow nonlinear reconstruction,
PCA is not necessarily the optimal procedure. In particular, for sparse data, random projections can significantly outperform PCA. This fact is at the heart of
the compressed sensing method.

23.6 Bibliographic Remarks

23.6

339

Bibliographic Remarks
PCA is equivalent to best subspace approximation using singular value decomposition (SVD). The SVD method is described in Appendix C. SVD dates back
to Eugenio Beltrami (1873) and Camille Jordan (1874). It has been rediscovered
many times. In the statistical literature, it was introduced by Pearson (1901). Besides PCA and SVD, there are additional names that refer to the same idea and
are being used in different scientific communities. A few examples are the EckartYoung theorem (after Carl Eckart and Gale Young who analyzed the method in
1936), the Schmidt-Mirsky theorem, factor analysis, and the Hotelling transform.
Compressed sensing was introduced in Donoho (2006) and in (Candes & Tao
2005). See also Candes (2006).

23.7

Exercises
1. In this exercise we show that in the general case, exact recovery of a linear
compression scheme is impossible.
1. let A âˆˆ Rn,d be an arbitrary compression matrix where n â‰¤ d âˆ’ 1. Show
that there exists u, v âˆˆ Rn , u 6= v such that Au = Av.
2. Conclude that exact recovery of a linear compression scheme is impossible.
2. Let Î± âˆˆ Rd such that Î±1 â‰¥ Î±2 â‰¥ Â· Â· Â· â‰¥ Î±d â‰¥ 0. Show that
max

Î²âˆˆ[0,1]d :kÎ²k1 â‰¤n

d
X
j=1

Î±j Î²j

=

n
X

Î±j .

j=1

Hint: Take every vector Î² âˆˆ [0, 1]d such that kÎ²k1 â‰¤ n. Let i be the minimal
index for which Î²i < 1. If i = n + 1 we are done. Otherwise, show that we can
increase Î²i , while possibly decreasing Î²j for some j > i, and obtain a better
solution. This will imply that the optimal solution is to set Î²i = 1 for i â‰¤ n
and Î²i = 0 for i > n.
3. Kernel PCA: In this exercise we show how PCA can be used for constructing nonlinear dimensionality reduction on the basis of the kernel trick (see
Chapter 16).
Let X be some instance space and let S = {x1 , . . . , xm } be a set of points
in X . Consider a feature mapping Ïˆ : X â†’ V , where V is some Hilbert space
(possibly of infinite dimension). Let K : X Ã— X be a kernel function, that is,
k(x, x0 ) = hÏˆ(x), Ïˆ(x0 )i. Kernel PCA is the process of mapping the elements
in S into V using Ïˆ, and then applying PCA over {Ïˆ(x1 ), . . . , Ïˆ(xm )} into
Rn . The output of this process is the set of reduced elements.
Show how this process can be done in polynomial time in terms of m
and n, assuming that each evaluation of K(Â·, Â·) can be calculated in a constant time. In particular, if your implementation requires multiplication of
two matrices A and B, verify that their product can be computed. Similarly,

340

Dimensionality Reduction

if an eigenvalue decomposition of some matrix C is required, verify that this
decomposition can be computed.
4. An Interpretation of PCA as Variance Maximization:
Let x1 , . . . , xm be m vectors in Rd , and let x be a random vector distributed
according to the uniform distribution over x1 , . . . , xm . Assume that E[x] = 0.
1. Consider the problem of finding a unit vector, w âˆˆ Rd , such that the
random variable hw, xi has maximal variance. That is, we would like to
solve the problem
m

1 X
(hw, xi i)2 .
w:kwk=1 m i=1

argmax Var[hw, xi] = argmax
w:kwk=1

Show that the solution of the problem is to set w to be the first principle
vector of x1 , . . . , xm .
2. Let w1 be the first principal component as in the previous question. Now,
suppose we would like to find a second unit vector, w2 âˆˆ Rd , that maximizes the variance of hw2 , xi, but is also uncorrelated to hw1 , xi. That is,
we would like to solve:
argmax

Var[hw, xi].

w:kwk=1, E[(hw1 ,xi)(hw,xi)]=0

Show that the solution to this problem is to set w to be the second principal
component of x1 , . . . , xm .
Hint: Note that
E[(hw1 , xi)(hw, xi)] = w1> E[xx> ]w = mw1> Aw,
P
>
where A =
i xi xi . Since w is an eigenvector of A we have that the
constraint E[(hw1 , xi)(hw, xi)] = 0 is equivalent to the constraint
hw1 , wi = 0.
5. The Relation between SVD and PCA: Use the SVD theorem (Corollary C.6) for providing an alternative proof of Theorem 23.2.
6. Random Projections Preserve Inner Products: The Johnson-Lindenstrauss
lemma tells us that a random projection preserves distances between a finite
set of vectors. In this exercise you need to prove that if the set of vectors are
within the unit ball, then not only are the distances between any two vectors
preserved, but the inner product is also preserved.
Let Q be a finite set of vectors in Rd and assume that for every x âˆˆ Q we
have kxk â‰¤ 1.
1. Let Î´ âˆˆ (0, 1) and n be an integer such that
r
6 log(|Q|2 /Î´)
â‰¤ 3.
=
n
Prove that with probability of at least 1 âˆ’ Î´ over a choice of a random

23.7 Exercises

341

matrix W âˆˆ Rn,d , where each element of W is independently distributed
according to N (0, 1/n), we have
|hW u, W vi âˆ’ hu, vi| â‰¤ 
for every u, v âˆˆ Q.
(uâˆ’v)k
(u+v)k
and kWkuâˆ’vk
.
Hint: Use JL to bound both kWku+vk
d
2. (*) Let x1 , . . . , xm be a set of vectors in R of norm at most 1, and assume
that these vectors are linearly separable with margin of Î³. Assume that
d  1/Î³ 2 . Show that there exists a constant c > 0 such that if we randomly
project these vectors into Rn , for n = c/Î³ 2 , then with probability of at least
99% it holds that the projected vectors are linearly separable with margin
Î³/2.

24 Generative Models

We started this book with a distribution free learning framework; namely, we
did not impose any assumptions on the underlying distribution over the data.
Furthermore, we followed a discriminative approach in which our goal is not to
learn the underlying distribution but rather to learn an accurate predictor. In
this chapter we describe a generative approach, in which it is assumed that the
underlying distribution over the data has a specific parametric form and our goal
is to estimate the parameters of the model. This task is called parametric density
estimation.
The discriminative approach has the advantage of directly optimizing the
quantity of interest (the prediction accuracy) instead of learning the underlying distribution. This was phrased as follows by Vladimir Vapnik in his principle
for solving problems using a restricted amount of information:

When solving a given problem, try to avoid a more general problem as an intermediate
step.

Of course, if we succeed in learning the underlying distribution accurately,
we are considered to be â€œexpertsâ€ in the sense that we can predict by using
the Bayes optimal classifier. The problem is that it is usually more difficult to
learn the underlying distribution than to learn an accurate predictor. However,
in some situations, it is reasonable to adopt the generative learning approach.
For example, sometimes it is easier (computationally) to estimate the parameters
of the model than to learn a discriminative predictor. Additionally, in some cases
we do not have a specific task at hand but rather would like to model the data
either for making predictions at a later time without having to retrain a predictor
or for the sake of interpretability of the data.
We start with a popular statistical method for estimating the parameters of
the data, which is called the maximum likelihood principle. Next, we describe two
generative assumptions which greatly simplify the learning process. We also describe the EM algorithm for calculating the maximum likelihood in the presence
of latent variables. We conclude with a brief description of Bayesian reasoning.
c 2014 by Shai Shalev-Shwartz and Shai Ben-David
Understanding Machine Learning, 
Published 2014 by Cambridge University Press.
Personal use only. Not for distribution. Do not post.
Please link to http://www.cs.huji.ac.il/~shais/UnderstandingMachineLearning

24.1 Maximum Likelihood Estimator

24.1

343

Maximum Likelihood Estimator
Let us start with a simple example. A drug company developed a new drug to
treat some deadly disease. We would like to estimate the probability of survival
when using the drug. To do so, the drug company sampled a training set of m
people and gave them the drug. Let S = (x1 , . . . , xm ) denote the training set,
where for each i, xi = 1 if the ith person survived and xi = 0 otherwise. We can
model the underlying distribution using a single parameter, Î¸ âˆˆ [0, 1], indicating
the probability of survival.
We now would like to estimate the parameter Î¸ on the basis of the training
set S. A natural idea is to use the average number of 1â€™s in S as an estimator.
That is,
m

Î¸Ì‚ =

1 X
xi .
m i=1

(24.1)

Clearly, ES [Î¸Ì‚] = Î¸. That is, Î¸Ì‚ is an unbiased estimator of Î¸. Furthermore, since Î¸Ì‚ is
the average of m i.i.d. binary random variables we can use Hoeffdingâ€™s inequality
to get that with probability of at least 1 âˆ’ Î´ over the choice of S we have that
r
log(2/Î´)
.
(24.2)
|Î¸Ì‚ âˆ’ Î¸| â‰¤
2m
Another interpretation of Î¸Ì‚ is as the Maximum Likelihood Estimator, as we
formally explain now. We first write the probability of generating the sample S:
P[S = (x1 , . . . , xm )] =

m
Y

Î¸xi (1 âˆ’ Î¸)1âˆ’xi = Î¸

P

i

xi

P

(1 âˆ’ Î¸)

i (1âˆ’xi )

.

i=1

We define the log likelihood of S, given the parameter Î¸, as the log of the preceding
expression:
X
X
L(S; Î¸) = log (P[S = (x1 , . . . , xm )]) = log(Î¸)
xi + log(1 âˆ’ Î¸)
(1 âˆ’ xi ).
i

i

The maximum likelihood estimator is the parameter that maximizes the likelihood
Î¸Ì‚ âˆˆ argmax L(S; Î¸).

(24.3)

Î¸

Next, we show that in our case, Equation (24.1) is a maximum likelihood estimator. To see this, we take the derivative of L(S; Î¸) with respect to Î¸ and equate
it to zero:
P
P
(1 âˆ’ xi )
i xi
âˆ’ i
= 0.
Î¸
1âˆ’Î¸
Solving the equation for Î¸ we obtain the estimator given in Equation (24.1).

344

Generative Models

24.1.1

Maximum Likelihood Estimation for Continuous Random Variables
Let X be a continuous random variable. Then, for most x âˆˆ R we have P[X =
x] = 0 and therefore the definition of likelihood as given before is trivialized. To
overcome this technical problem we define the likelihood as log of the density of
the probability of X at x. That is, given an i.i.d. training set S = (x1 , . . . , xm )
sampled according to a density distribution PÎ¸ we define the likelihood of S given
Î¸ as
!
m
m
Y
X
L(S; Î¸) = log
PÎ¸ (xi ) =
log(PÎ¸ (xi )).
i=1

i=1

As before, the maximum likelihood estimator is a maximizer of L(S; Î¸) with
respect to Î¸.
As an example, consider a Gaussian random variable, for which the density
function of X is parameterized by Î¸ = (Âµ, Ïƒ) and is defined as follows:


(x âˆ’ Âµ)2
1
âˆš
exp âˆ’
.
PÎ¸ (x) =
2Ïƒ 2
Ïƒ 2Ï€
We can rewrite the likelihood as
L(S; Î¸) = âˆ’

m
âˆš
1 X
(xi âˆ’ Âµ)2 âˆ’ m log(Ïƒ 2 Ï€).
2
2Ïƒ i=1

To find a parameter Î¸ = (Âµ, Ïƒ) that optimizes this we take the derivative of the
likelihood w.r.t. Âµ and w.r.t. Ïƒ and compare it to 0. We obtain the following two
equations:
m
d
1 X
L(S; Î¸) = 2
(xi âˆ’ Âµ) = 0
dÂµ
Ïƒ i=1
m
d
1 X
m
L(S; Î¸) = 3
(xi âˆ’ Âµ)2 âˆ’
=0
dÏƒ
Ïƒ i=1
Ïƒ

Solving the preceding equations we obtain the maximum likelihood estimates:
v
u
m
m
u1 X
1 X
xi
and
ÏƒÌ‚ = t
(xi âˆ’ ÂµÌ‚)2
ÂµÌ‚ =
m i=1
m i=1
Note that the maximum likelihood estimate is not always an unbiased estimator.
For example, while ÂµÌ‚ is unbiased, it is possible to show that the estimate ÏƒÌ‚ of
the variance is biased (Exercise 1).

Simplifying Notation
To simplify our notation, we use P[X = x] in this chapter to describe both the
probability that X = x (for discrete random variables) and the density of the
distribution at x (for continuous variables).

24.1 Maximum Likelihood Estimator

24.1.2

345

Maximum Likelihood and Empirical Risk Minimization
The maximum likelihood estimator shares some similarity with the Empirical
Risk Minimization (ERM) principle, which we studied extensively in previous
chapters. Recall that in the ERM principle we have a hypothesis class H and
we use the training set for choosing a hypothesis h âˆˆ H that minimizes the
empirical risk. We now show that the maximum likelihood estimator is an ERM
for a particular loss function.
Given a parameter Î¸ and an observation x, we define the loss of Î¸ on x as
`(Î¸, x) = âˆ’ log(PÎ¸ [x]).

(24.4)

That is, `(Î¸, x) is the negation of the log-likelihood of the observation x, assuming
the data is distributed according to PÎ¸ . This loss function is often referred to as
the log-loss. On the basis of this definition it is immediate that the maximum
likelihood principle is equivalent to minimizing the empirical risk with respect
to the loss function given in Equation (24.4). That is,
argmin
Î¸

m
X

(âˆ’ log(PÎ¸ [xi ])) = argmax

m
X

Î¸

i=1

log(PÎ¸ [xi ]).

i=1

Assuming that the data is distributed according to a distribution P (not necessarily of the parametric form we employ), the true risk of a parameter Î¸ becomes
X
E[`(Î¸, x)] = âˆ’
P[x] log(PÎ¸ [x])
x

x

=

X


P[x] log

x

|

{z

P[x]
PÎ¸ [x]

DRE [P||PÎ¸ ]


+

X


P[x] log

x

}

|

{z

H(P)


1
,
P[x]
}

(24.5)

where DRE is called the relative entropy, and H is called the entropy function. The relative entropy is a divergence measure between two probabilities.
For discrete variables, it is always nonnegative and is equal to 0 only if the two
distributions are the same. It follows that the true risk is minimal when PÎ¸ = P.
The expression given in Equation (24.5) underscores how our generative assumption affects our density estimation, even in the limit of infinite data. It
shows that if the underlying distribution is indeed of a parametric form, then by
choosing the correct parameter we can make the risk be the entropy of the distribution. However, if the distribution is not of the assumed parametric form, even
the best parameter leads to an inferior model and the suboptimality is measured
by the relative entropy divergence.

24.1.3

Generalization Analysis
How good is the maximum likelihood estimator when we learn from a finite
training set?

346

Generative Models

To answer this question we need to define how we assess the quality of an approximated solution of the density estimation problem. Unlike discriminative learning,
where there is a clear notion of â€œloss,â€ in generative learning there are various
ways to define the loss of a model. On the basis of the previous subsection, one
natural candidate is the expected log-loss as given in Equation (24.5).
In some situations, it is easy to prove that the maximum likelihood principle
guarantees low true risk as well. For example, consider the problem of estimating
the mean of a Gaussian variable of unit variance. We saw previously that the
P
1
?
maximum likelihood estimator is the average: ÂµÌ‚ = m
i xi . Let Âµ be the optimal
parameter. Then,


PÂµ? [x]
E ? [`(ÂµÌ‚, x) âˆ’ `(Âµ? , x)] =
E ? log
PÂµÌ‚ [x]
xâˆ¼N (Âµ ,1)
xâˆ¼N (Âµ ,1)


1
1
=
E?
âˆ’ (x âˆ’ Âµ? )2 + (x âˆ’ ÂµÌ‚)2
2
2
xâˆ¼N (Âµ ,1)
2
? 2
ÂµÌ‚
(Âµ )
=
âˆ’
+ (Âµ? âˆ’ ÂµÌ‚)
E
[x]
2
2
xâˆ¼N (Âµ? ,1)
ÂµÌ‚2
(Âµ? )2
=
âˆ’
+ (Âµ? âˆ’ ÂµÌ‚) Âµ?
2
2
1
= (ÂµÌ‚ âˆ’ Âµ? )2 .
(24.6)
2
Next, we note that ÂµÌ‚ is the average of m Gaussian variables and therefore it is
also distributed normally with mean Âµ? and variance Ïƒ ? /m. From this fact we
can derive bounds of the form: with probability of at least 1 âˆ’ Î´ we have that
|ÂµÌ‚ âˆ’ Âµ? | â‰¤  where  depends on Ïƒ ? /m and on Î´.
In some situations, the maximum likelihood estimator clearly overfits. For
example, consider a Bernoulli random variable X and let P[X = 1] = Î¸? . As
we saw previously, using Hoeffdingâ€™s inequality we can easily derive a guarantee
on |Î¸? âˆ’ Î¸Ì‚| that holds with high probability (see Equation (24.2)). However, if
our goal is to obtain a small value of the expected log-loss function as defined in
Equation (24.5) we might fail. For example, assume that Î¸? is nonzero but very
small. Then, the probability that no element of a sample of size m will be 1 is
?
(1 âˆ’ Î¸? )m , which is greater than eâˆ’2Î¸ m . It follows that whenever m â‰¤ log(2)
2Î¸ ? ,
the probability that the sample is all zeros is at least 50%, and in that case, the
maximum likelihood rule will set Î¸Ì‚ = 0. But the true risk of the estimate Î¸Ì‚ = 0
is
E [`(Î¸Ì‚, x)] = Î¸? `(Î¸Ì‚, 1) + (1 âˆ’ Î¸? )`(Î¸Ì‚, 0)

xâˆ¼Î¸ ?

= Î¸? log(1/Î¸Ì‚) + (1 âˆ’ Î¸? ) log(1/(1 âˆ’ Î¸Ì‚))
= Î¸? log(1/0) = âˆž.
This simple example shows that we should be careful in applying the maximum
likelihood principle.
To overcome overfitting, we can use the variety of tools we encountered pre-

24.2 Naive Bayes

347

viously in the book. A simple regularization technique is outlined in Exercise
2.

24.2

Naive Bayes
The Naive Bayes classifier is a classical demonstration of how generative assumptions and parameter estimations simplify the learning process. Consider
the problem of predicting a label y âˆˆ {0, 1} on the basis of a vector of features
x = (x1 , . . . , xd ), where we assume that each xi is in {0, 1}. Recall that the Bayes
optimal classifier is
hBayes (x) = argmax P[Y = y|X = x].
yâˆˆ{0,1}

To describe the probability function P[Y = y|X = x] we need 2d parameters,
each of which corresponds to P[Y = 1|X = x] for a certain value of x âˆˆ {0, 1}d .
This implies that the number of examples we need grows exponentially with the
number of features.
In the Naive Bayes approach we make the (rather naive) generative assumption
that given the label, the features are independent of each other. That is,
P[X = x|Y = y] =

d
Y

P[Xi = xi |Y = y].

i=1

With this assumption and using Bayesâ€™ rule, the Bayes optimal classifier can be
further simplified:
hBayes (x) = argmax P[Y = y|X = x]
yâˆˆ{0,1}

= argmax P[Y = y]P[X = x|Y = y]
yâˆˆ{0,1}

= argmax P[Y = y]
yâˆˆ{0,1}

d
Y

P[Xi = xi |Y = y].

(24.7)

i=1

That is, now the number of parameters we need to estimate is only 2d + 1.
Here, the generative assumption we made reduced significantly the number of
parameters we need to learn.
When we also estimate the parameters using the maximum likelihood principle, the resulting classifier is called the Naive Bayes classifier.

24.3

Linear Discriminant Analysis
Linear discriminant analysis (LDA) is another demonstration of how generative
assumptions simplify the learning process. As in the Naive Bayes classifier we
consider again the problem of predicting a label y âˆˆ {0, 1} on the basis of a

348

Generative Models

vector of features x = (x1 , . . . , xd ). But now the generative assumption is as
follows. First, we assume that P[Y = 1] = P[Y = 0] = 1/2. Second, we assume
that the conditional probability of X given Y is a Gaussian distribution. Finally,
the covariance matrix of the Gaussian distribution is the same for both values
of the label. Formally, let Âµ0 , Âµ1 âˆˆ Rd and let Î£ be a covariance matrix. Then,
the density distribution is given by


1
1
T âˆ’1
exp
âˆ’
P[X = x|Y = y] =
(x
âˆ’
Âµ
)
Î£
(x
âˆ’
Âµ
)
.
y
y
2
(2Ï€)d/2 |Î£|1/2
As we have shown in the previous section, using Bayesâ€™ rule we can write
hBayes (x) = argmax P[Y = y]P[X = x|Y = y].
yâˆˆ{0,1}

This means that we will predict hBayes (x) = 1 iff


P[Y = 1]P[X = x|Y = 1]
> 0.
log
P[Y = 0]P[X = x|Y = 0]
This ratio is often called the log-likelihood ratio.
In our case, the log-likelihood ratio becomes
1
2 (x

âˆ’ Âµ0 )T Î£âˆ’1 (x âˆ’ Âµ0 ) âˆ’ 21 (x âˆ’ Âµ1 )T Î£âˆ’1 (x âˆ’ Âµ1 )

We can rewrite this as hw, xi + b where
w = (Âµ1 âˆ’ Âµ0 )T Î£âˆ’1

and b =

1
2


ÂµT0 Î£âˆ’1 Âµ0 âˆ’ ÂµT1 Î£âˆ’1 Âµ1 .

(24.8)

As a result of the preceding derivation we obtain that under the aforementioned generative assumptions, the Bayes optimal classifier is a linear classifier.
Additionally, one may train the classifier by estimating the parameter Âµ0 , Âµ1
and Î£ from the data, using, for example, the maximum likelihood estimator.
With those estimators at hand, the values of w and b can be calculated as in
Equation (24.8).

24.4

Latent Variables and the EM Algorithm
In generative models we assume that the data is generated by sampling from
a specific parametric distribution over our instance space X . Sometimes, it is
convenient to express this distribution using latent random variables. A natural
example is a mixture of k Gaussian distributions. That is, X = Rd and we
assume that each x is generated as follows. First, we choose a random number in
{1, . . . , k}. Let Y be a random variable corresponding to this choice, and denote
P[Y = y] = cy . Second, we choose x on the basis of the value of Y according to
a Gaussian distribution


1
1
T âˆ’1
exp âˆ’ (x âˆ’ Âµy ) Î£y (x âˆ’ Âµy ) . (24.9)
P[X = x|Y = y] =
2
(2Ï€)d/2 |Î£y |1/2

24.4 Latent Variables and the EM Algorithm

349

Therefore, the density of X can be written as:
P[X = x] =

k
X

P[Y = y]P[X = x|Y = y]

y=1
k
X



1
1
T âˆ’1
exp âˆ’ (x âˆ’ Âµy ) Î£y (x âˆ’ Âµy ) .
=
cy
2
(2Ï€)d/2 |Î£y |1/2
y=1
Note that Y is a hidden variable that we do not observe in our data. Nevertheless, we introduce Y since it helps us describe a simple parametric form of the
probability of X.
More generally, let Î¸ be the parameters of the joint distribution of X and Y
(e.g., in the preceding example, Î¸ consists of cy , Âµy , and Î£y , for all y = 1, . . . , k).
Then, the log-likelihood of an observation x can be written as
!
k
X
log (PÎ¸ [X = x]) = log
PÎ¸ [X = x, Y = y] .
y=1

Given an i.i.d. sample, S = (x1 , . . . , xm ), we would like to find Î¸ that maximizes the log-likelihood of S,
L(Î¸) = log

m
Y

PÎ¸ [X = xi ]

i=1

=

m
X

log PÎ¸ [X = xi ]

i=1

=

m
X

log

k
X

!
PÎ¸ [X = xi , Y = y] .

y=1

i=1

The maximum-likelihood estimator is therefore the solution of the maximization
problem
!
m
k
X
X
argmax L(Î¸) = argmax
log
PÎ¸ [X = xi , Y = y] .
Î¸

Î¸

i=1

y=1

In many situations, the summation inside the log makes the preceding optimization problem computationally hard. The Expectation-Maximization (EM)
algorithm, due to Dempster, Laird, and Rubin, is an iterative procedure for
searching a (local) maximum of L(Î¸). While EM is not guaranteed to find the
global maximum, it often works reasonably well in practice.
EM is designed for those cases in which, had we known the values of the latent
variables Y , then the maximum likelihood optimization problem would have been
tractable. More precisely, define the following function over m Ã— k matrices and
the set of parameters Î¸:
F (Q, Î¸) =

m X
k
X
i=1 y=1

Qi,y log (PÎ¸ [X = xi , Y = y]) .

350

Generative Models

If each row of Q defines a probability over the ith latent variable given X = xi ,
then we can interpret F (Q, Î¸) as the expected log-likelihood of a training set
(x1 , y1 ), . . . , (xm , ym ), where the expectation is with respect to the choice of
each yi on the basis of the ith row of Q. In the definition of F , the summation is
outside the log, and we assume that this makes the optimization problem with
respect to Î¸ tractable:
assumption 24.1 For any matrix Q âˆˆ [0, 1]m,k , such that each row of Q sums
to 1, the optimization problem
argmax F (Q, Î¸)
Î¸

is tractable.
The intuitive idea of EM is that we have a â€œchicken and eggâ€ problem. On one
hand, had we known Q, then by our assumption, the optimization problem of
finding the best Î¸ is tractable. On the other hand, had we known the parameters
Î¸ we could have set Qi,y to be the probability of Y = y given that X = xi .
The EM algorithm therefore alternates between finding Î¸ given Q and finding Q
given Î¸. Formally, EM finds a sequence of solutions (Q(1) , Î¸ (1) ), (Q(2) , Î¸ (2) ), . . .
where at iteration t, we construct (Q(t+1) , Î¸ (t+1) ) by performing two steps.
â€¢ Expectation Step: Set
(t+1)

Qi,y

= PÎ¸(t) [Y = y|X = xi ].

(24.10)

This step is called the Expectation step, because it yields a new probability over the latent variables, which defines a new expected log-likelihood
function over Î¸.
â€¢ Maximization Step: Set Î¸ (t+1) to be the maximizer of the expected loglikelihood, where the expectation is according to Q(t+1) :
Î¸ (t+1) = argmax F (Q(t+1) , Î¸).

(24.11)

Î¸

By our assumption, it is possible to solve this optimization problem efficiently.
The initial values of Î¸ (1) and Q(1) are usually chosen at random and the
procedure terminates after the improvement in the likelihood value stops being
significant.

24.4.1

EM as an Alternate Maximization Algorithm
To analyze the EM algorithm, we first view it as an alternate maximization
algorithm. Define the following objective function
G(Q, Î¸) = F (Q, Î¸) âˆ’

m X
k
X
i=1 y=1

Qi,y log(Qi,y ).

24.4 Latent Variables and the EM Algorithm

351

The second term is the sum of the entropies of the rows of Q. Let
(
Q âˆˆ [0, 1]

Q=

m,k

k
X

: âˆ€i,

)
Qi,y = 1

y=1

be the set of matrices whose rows define probabilities over [k]. The following
lemma shows that EM performs alternate maximization iterations for maximizing G.

lemma 24.2

The EM procedure can be rewritten as:
Q(t+1) = argmax G(Q, Î¸ (t) )
QâˆˆQ

Î¸

(t+1)

= argmax G(Q(t+1) , Î¸) .
Î¸

Furthermore, G(Q(t+1) , Î¸ (t) ) = L(Î¸ (t) ).

Proof

Given Q(t+1) we clearly have that

argmax G(Q(t+1) , Î¸) = argmax F (Q(t+1) , Î¸).
Î¸

Î¸

Therefore, we only need to show that for any Î¸, the solution of argmaxQâˆˆQ G(Q, Î¸)
is to set Qi,y = PÎ¸ [Y = y|X = xi ]. Indeed, by Jensenâ€™s inequality, for any Q âˆˆ Q
we have that

PÎ¸ [X = xi , Y = y]
Qi,y

!

PÎ¸ [X = xi , Y = y]
â‰¤
log
Qi,y
Qi,y
y=1
i=1
!
m
k
X
X
=
log
PÎ¸ [X = xi , Y = y]

!!

G(Q, Î¸) =

k
m
X
X
i=1
m
X

=

i=1
m
X
i=1


Qi,y log

y=1
k
X

y=1

log (PÎ¸ [X = xi ]) = L(Î¸),

352

Generative Models

while for Qi,y = PÎ¸ [Y = y|X = xi ] we have
G(Q, Î¸) =

m
k
X
X
i=1

=


PÎ¸ [Y = y|X = xi ] log

y=1

m X
k
X

PÎ¸ [X = xi , Y = y]
PÎ¸ [Y = y|X = xi ]

!

PÎ¸ [Y = y|X = xi ] log (PÎ¸ [X = xi ])

i=1 y=1

=

=

m
X
i=1
m
X

log (PÎ¸ [X = xi ])

k
X

PÎ¸ [Y = y|X = xi ]

y=1

log (PÎ¸ [X = xi ]) = L(Î¸).

i=1

This shows that setting Qi,y = PÎ¸ [Y = y|X = xi ] maximizes G(Q, Î¸) over Q âˆˆ Q
and shows that G(Q(t+1) , Î¸ (t) ) = L(Î¸ (t) ).
The preceding lemma immediately implies:
theorem 24.3
for all t,

The EM procedure never decreases the log-likelihood; namely,
L(Î¸ (t+1) ) â‰¥ L(Î¸ (t) ).

Proof

By the lemma we have
L(Î¸ (t+1) ) = G(Q(t+2) , Î¸ (t+1) ) â‰¥ G(Q(t+1) , Î¸ (t) ) = L(Î¸ (t) ).

24.4.2

EM for Mixture of Gaussians (Soft k-Means)
Consider the case of a mixture of k Gaussians in which Î¸ is a triplet (c, {Âµ1 , . . . , Âµk }, {Î£1 , . . . , Î£k })
where PÎ¸ [Y = y] = cy and PÎ¸ [X = x|Y = y] is as given in Equation (24.9). For
simplicity, we assume that Î£1 = Î£2 = Â· Â· Â· = Î£k = I, where I is the identity
matrix. Specifying the EM algorithm for this case we obtain the following:
â€¢ Expectation step: For each i âˆˆ [m] and y âˆˆ [k] we have that
1
P (t) [Y = y] PÎ¸(t) [X = xi |Y = y]
Zi Î¸


1 (t)
1
2
=
cy exp âˆ’ kxi âˆ’ Âµ(t)
k
,
(24.12)
y
Zi
2
P
where Zi is a normalization factor which ensures that y PÎ¸(t) [Y = y|X =
xi ] sums to 1.
â€¢ Maximization step: We need to set Î¸ t+1 to be a maximizer of Equation (24.11),
PÎ¸(t) [Y = y|X = xi ] =

24.5 Bayesian Reasoning

353

which in our case amounts to maximizing the following expression w.r.t. c
and Âµ:


m X
k
X
1
2
(24.13)
PÎ¸(t) [Y = y|X = xi ] log(cy ) âˆ’ kxi âˆ’ Âµy k .
2
i=1 y=1
Comparing the derivative of Equation (24.13) w.r.t. Âµy to zero and rearranging terms we obtain:
Pm
i=1 PÎ¸ (t) [Y = y|X = xi ] xi
.
Âµy = P
m
i=1 PÎ¸ (t) [Y = y|X = xi ]
That is, Âµy is a weighted average of the xi where the weights are according
to the probabilities calculated in the E step. To find the optimal c we need
to be more careful since we must ensure that c is a probability vector. In
Exercise 3 we show that the solution is:
Pm
PÎ¸(t) [Y = y|X = xi ]
cy = Pk i=1
.
(24.14)
Pm
0
y 0 =1
i=1 PÎ¸ (t) [Y = y |X = xi ]
It is interesting to compare the preceding algorithm to the k-means algorithm
described in Chapter 22. In the k-means algorithm, we first assign each example
to a cluster according to the distance kxi âˆ’ Âµy k. Then, we update each center
Âµy according to the average of the examples assigned to this cluster. In the EM
approach, however, we determine the probability that each example belongs to
each cluster. Then, we update the centers on the basis of a weighted sum over
the entire sample. For this reason, the EM approach for k-means is sometimes
called â€œsoft k-means.â€

24.5

Bayesian Reasoning
The maximum likelihood estimator follows a frequentist approach. This means
that we refer to the parameter Î¸ as a fixed parameter and the only problem is
that we do not know its value. A different approach to parameter estimation
is called Bayesian reasoning. In the Bayesian approach, our uncertainty about
Î¸ is also modeled using probability theory. That is, we think of Î¸ as a random
variable as well and refer to the distribution P[Î¸] as a prior distribution. As its
name indicates, the prior distribution should be defined by the learner prior to
observing the data.
As an example, let us consider again the drug company which developed a
new drug. On the basis of past experience, the statisticians at the drug company
believe that whenever a drug has reached the level of clinic experiments on
people, it is likely to be effective. They model this prior belief by defining a
density distribution on Î¸ such that
(
0.8 if Î¸ > 0.5
P[Î¸] =
(24.15)
0.2 if Î¸ â‰¤ 0.5

354

Generative Models

As before, given a specific value of Î¸, it is assumed that the conditional probability, P[X = x|Î¸], is known. In the drug company example, X takes values in
{0, 1} and P[X = x|Î¸] = Î¸x (1 âˆ’ Î¸)1âˆ’x .
Once the prior distribution over Î¸ and the conditional distribution over X
given Î¸ are defined, we again have complete knowledge of the distribution over
X. This is because we can write the probability over X as a marginal probability
X
X
P[X = x] =
P[X = x, Î¸] =
P[Î¸]P[X = x|Î¸],
Î¸

Î¸

where the last equality follows from the definition of conditional probability. If
Î¸ is continuous we replace P[Î¸] with the density function and the sum becomes
an integral:
Z
P[X = x] = P[Î¸]P[X = x|Î¸] dÎ¸.
Î¸

Seemingly, once we know P[X = x], a training set S = (x1 , . . . , xm ) tells us
nothing as we are already experts who know the distribution over a new point
X. However, the Bayesian view introduces dependency between S and X. This is
because we now refer to Î¸ as a random variable. A new point X and the previous
points in S are independent only conditioned on Î¸. This is different from the
frequentist philosophy in which Î¸ is a parameter that we might not know, but
since it is just a parameter of the distribution, a new point X and previous points
S are always independent.
In the Bayesian framework, since X and S are not independent anymore, what
we would like to calculate is the probability of X given S, which by the chain
rule can be written as follows:
X
X
P[X = x|S] =
P[X = x|Î¸, S] P[Î¸|S] =
P[X = x|Î¸] P[Î¸|S].
Î¸

Î¸

The second inequality follows from the assumption that X and S are independent
when we condition on Î¸. Using Bayesâ€™ rule we have
P[Î¸|S] =

P[S|Î¸] P[Î¸]
,
P[S]

and together with the assumption that points are independent conditioned on Î¸,
we can write
m
P[S|Î¸] P[Î¸]
1 Y
P[Î¸|S] =
=
P[X = xi |Î¸] P[Î¸].
P[S]
P[S] i=1
We therefore obtain the following expression for Bayesian prediction:
P[X = x|S] =

m
Y
1 X
P[X = x|Î¸]
P[X = xi |Î¸] P[Î¸].
P[S]
i=1

(24.16)

Î¸

Getting back to our drug company example, we can rewrite P[X = x|S] as
Z
P
P
1
P[X = x|S] =
Î¸x+ i xi (1 âˆ’ Î¸)1âˆ’x+ i (1âˆ’xi ) P[Î¸] dÎ¸.
P [S]

24.6 Summary

355

It is interesting to note that when P[Î¸] is uniform we obtain that
Z
P
P
P[X = x|S] âˆ Î¸x+ i xi (1 âˆ’ Î¸)1âˆ’x+ i (1âˆ’xi ) dÎ¸.
Solving the preceding integral (using integration by parts) we obtain
P
( i xi ) + 1
.
P[X = 1|S] =
m+2
Recall that the prediction
according to the maximum likelihood principle in this
P
i xi
case is P[X = 1|Î¸Ì‚] = m . The Bayesian prediction with uniform prior is rather
similar to the maximum likelihood prediction, except it adds â€œpseudoexamplesâ€
to the training set, thus biasing the prediction toward the uniform prior.

Maximum A Posteriori
In many situations, it is difficult to find a closed form solution to the integral
given in Equation (24.16). Several numerical methods can be used to approximate this integral. Another popular solution is to find a single Î¸ which maximizes
P[Î¸|S]. The value of Î¸ which maximizes P[Î¸|S] is called the Maximum A Posteriori estimator. Once this value is found, we can calculate the probability that
X = x given the maximum a posteriori estimator and independently on S.

24.6

Summary
In the generative approach to machine learning we aim at modeling the distribution over the data. In particular, in parametric density estimation we further
assume that the underlying distribution over the data has a specific parametric form and our goal is to estimate the parameters of the model. We have
described several principles for parameter estimation, including maximum likelihood, Bayesian estimation, and maximum a posteriori. We have also described
several specific algorithms for implementing the maximum likelihood under different assumptions on the underlying data distribution, in particular, Naive
Bayes, LDA, and EM.

24.7

Bibliographic Remarks
The maximum likelihood principle was studied by Ronald Fisher in the beginning
of the 20th century. Bayesian statistics follow Bayesâ€™ rule, which is named after
the 18th century English mathematician Thomas Bayes.
There are many excellent books on the generative and Bayesian approaches
to machine learning. See, for example, (Bishop 2006, Koller & Friedman 2009,
MacKay 2003, Murphy 2012, Barber 2012).

356

Generative Models

24.8

Exercises
1. Prove that the maximum likelihood estimator of the variance of a Gaussian
variable is biased.
2. Regularization for Maximum Likelihood: Consider the following regularized
loss minimization:
m
1 X
1
log(1/PÎ¸ [xi ]) +
(log(1/Î¸) + log(1/(1 âˆ’ Î¸))) .
m i=1
m
â€¢ Show that the preceding objective is equivalent to the usual empirical error
had we added two pseudoexamples to the training set. Conclude that
the regularized maximum likelihood estimator would be
!
m
X
1
1+
xi .
Î¸Ì‚ =
m+2
i=1
â€¢ Derive a high probability bound on |Î¸Ì‚ âˆ’Î¸? |. Hint: Rewrite this as |Î¸Ì‚ âˆ’E[Î¸Ì‚]+
E[Î¸Ì‚] âˆ’ Î¸? | and then use the triangle inequality and Hoeffding inequality.
1
to
â€¢ Use this to bound the true risk. Hint: Use the fact that now Î¸Ì‚ â‰¥ m+2
?
relate |Î¸Ì‚ âˆ’ Î¸ | to the relative entropy.
3. â€¢ Consider a general optimization problem of the form:
max
c

k
X

Î½y log(cy )

s.t.

cy > 0,

X

cy = 1 ,

y

y=1

where Î½ âˆˆ Rk+ is a vector of nonnegative weights. Verify that the M step
of soft k-means involves solving such an optimization problem.
â€¢ Let c? = P 1 Î½y Î½. Show that c? is a probability vector.
y
â€¢ Show that the optimization problem is equivalent to the problem:
X
min DRE (c? ||c) s.t. cy > 0,
cy = 1 .
c

y

â€¢ Using properties of the relative entropy, conclude that c? is the solution to
the optimization problem.

25 Feature Selection and Generation

In the beginning of the book, we discussed the abstract model of learning, in
which the prior knowledge utilized by the learner is fully encoded by the choice
of the hypothesis class. However, there is another modeling choice, which we
have so far ignored: How do we represent the instance space X ? For example, in
the papayas learning problem, we proposed the hypothesis class of rectangles in
the softness-color two dimensional plane. That is, our first modeling choice was
to represent a papaya as a two dimensional point corresponding to its softness
and color. Only after that did we choose the hypothesis class of rectangles as a
class of mappings from the plane into the label set. The transformation from the
real world object â€œpapayaâ€ into the scalar representing its softness or its color
is called a feature function or a feature for short; namely, any measurement of
the real world object can be regarded as a feature. If X is a subset of a vector
space, each x âˆˆ X is sometimes referred to as a feature vector. It is important to
understand that the way we encode real world objects as an instance space X is
by itself prior knowledge about the problem.
Furthermore, even when we already have an instance space X which is represented as a subset of a vector space, we might still want to change it into a
different representation and apply a hypothesis class on top of it. That is, we
may define a hypothesis class on X by composing some class H on top of a
feature function which maps X into some other vector space X 0 . We have already encountered examples of such compositions â€“ in Chapter 15 we saw that
kernel-based SVM learns a composition of the class of halfspaces over a feature
mapping Ïˆ that maps each original instance in X into some Hilbert space. And,
indeed, the choice of Ïˆ is another form of prior knowledge we impose on the
problem.
In this chapter we study several methods for constructing a good feature set.
We start with the problem of feature selection, in which we have a large pool
of features and our goal is to select a small number of features that will be
used by our predictor. Next, we discuss feature manipulations and normalization.
These include simple transformations that we apply on our original features. Such
transformations may decrease the sample complexity of our learning algorithm,
its bias, or its computational complexity. Last, we discuss several approaches for
feature learning. In these methods, we try to automate the process of feature
construction.
c 2014 by Shai Shalev-Shwartz and Shai Ben-David
Understanding Machine Learning, 
Published 2014 by Cambridge University Press.
Personal use only. Not for distribution. Do not post.
Please link to http://www.cs.huji.ac.il/~shais/UnderstandingMachineLearning

358

Feature Selection and Generation

We emphasize that while there are some common techniques for feature learning one may want to try, the No-Free-Lunch theorem implies that there is no ultimate feature learner. Any feature learning algorithm might fail on some problem.
In other words, the success of each feature learner relies (sometimes implicitly)
on some form of prior assumption on the data distribution. Furthermore, the
relative quality of features highly depends on the learning algorithm we are later
going to apply using these features. This is illustrated in the following example.
Example 25.1 Consider a regression problem in which X = R2 , Y = R, and
the loss function is the squared loss. Suppose that the underlying distribution
is such that an example (x, y) is generated as follows: First, we sample x1 from
the uniform distribution over [âˆ’1, 1]. Then, we deterministically set y = x1 2 .
Finally, the second feature is set to be x2 = y + z, where z is sampled from the
uniform distribution over [âˆ’0.01, 0.01]. Suppose we would like to choose a single
feature. Intuitively, the first feature should be preferred over the second feature
as the target can be perfectly predicted based on the first feature alone, while it
cannot be perfectly predicted based on the second feature. Indeed, choosing the
first feature would be the right choice if we are later going to apply polynomial
regression of degree at least 2. However, if the learner is going to be a linear
regressor, then we should prefer the second feature over the first one, since the
optimal linear predictor based on the first feature will have a larger risk than
the optimal linear predictor based on the second feature.

25.1

Feature Selection
Throughout this section we assume that X = Rd . That is, each instance is represented as a vector of d features. Our goal is to learn a predictor that only relies
on k  d features. Predictors that use only a small subset of features require a
smaller memory footprint and can be applied faster. Furthermore, in applications
such as medical diagnostics, obtaining each possible â€œfeatureâ€ (e.g., test result)
can be costly; therefore, a predictor that uses only a small number of features
is desirable even at the cost of a small degradation in performance, relative to
a predictor that uses more features. Finally, constraining the hypothesis class to
use a small subset of features can reduce its estimation error and thus prevent
overfitting.
Ideally, we could have tried all subsets of k out of d features and choose the
subset which leads to the best performing predictor. However, such an exhaustive
search is usually computationally intractable. In the following we describe three
computationally feasible approaches for feature selection. While these methods
cannot guarantee finding the optimal subset, they often work reasonably well in
practice. Some of the methods come with formal guarantees on the quality of the
selected subsets under certain assumptions. We do not discuss these guarantees
here.

25.1 Feature Selection

25.1.1

359

Filters
Maybe the simplest approach for feature selection is the filter method, in which
we assess individual features, independently of other features, according to some
quality measure. We can then select the k features that achieve the highest score
(alternatively, decide also on the number of features to select according to the
value of their scores).
Many quality measures for features have been proposed in the literature.
Maybe the most straightforward approach is to set the score of a feature according to the error rate of a predictor that is trained solely by that feature.
To illustrate this, consider a linear regression problem with the squared loss.
Let v = (x1,j , . . . , xm,j ) âˆˆ Rm be a vector designating the values of the jth
feature on a training set of m examples and let y = (y1 , . . . , ym ) âˆˆ Rm be the
values of the target on the same m examples. The empirical squared loss of an
ERM linear predictor that uses only the jth feature would be
min

a,bâˆˆR

1
kav + b âˆ’ yk2 ,
m

where the meaning of adding a scalar b to a vector v is adding b to all coordinates
Pm
1
of v. To solve this problem, let vÌ„ = m
i=1 vi be the averaged value of the
P
m
1
feature and let yÌ„ = m
y
be
the
averaged
value of the target. Clearly (see
i
i=1
Exercise 1),
1
1
kav + b âˆ’ yk2 = min ka(v âˆ’ vÌ„) + b âˆ’ (y âˆ’ yÌ„)k2 .
a,bâˆˆR m
a,bâˆˆR m
min

(25.1)

Taking the derivative of the right-hand side objective with respect to b and
comparing it to zero we obtain that b = 0. Similarly, solving for a (once we know
that b = 0) yields a = hv âˆ’ vÌ„, y âˆ’ yÌ„i/kv âˆ’ vÌ„k2 . Plugging this value back into the
objective we obtain the value
ky âˆ’ yÌ„k2 âˆ’

(hv âˆ’ vÌ„, y âˆ’ yÌ„i)2
.
kv âˆ’ vÌ„k2

Ranking the features according to the minimal loss they achieve is equivalent
to ranking them according to the absolute value of the following score (where
now a higher score yields a better feature):
1
hv âˆ’ vÌ„, y âˆ’ yÌ„i
hv âˆ’ vÌ„, y âˆ’ yÌ„i
q
= q m
.
kv âˆ’ vÌ„k ky âˆ’ yÌ„k
1
1
2
2
m kv âˆ’ vÌ„k
m ky âˆ’ yÌ„k

(25.2)

The preceding expression is known as Pearsonâ€™s correlation coefficient. The numerator is the empirical estimate of the covariance of the jth feature and the
target value, E[(v âˆ’ E v)(y âˆ’ E y)], while the denominator is the squared root of
the empirical estimate for the variance of the jth feature, E[(v âˆ’ E v)2 ], times
the variance of the target. Pearsonâ€™s coefficient ranges from âˆ’1 to 1, where if
the Pearsonâ€™s coefficient is either 1 or âˆ’1, there is a linear mapping from v to y
with zero empirical risk.

360

Feature Selection and Generation

If Pearsonâ€™s coefficient equals zero it means that the optimal linear function
from v to y is the all-zeros function, which means that v alone is useless for
predicting y. However, this does not mean that v is a bad feature, as it might
be the case that together with other features v can perfectly predict y. Indeed,
consider a simple example in which the target is generated by the function y =
x1 + 2x2 . Assume also that x1 is generated from the uniform distribution over
{Â±1}, and x2 = âˆ’ 21 x1 + 12 z, where z is also generated i.i.d. from the uniform
distribution over {Â±1}. Then, E[x1 ] = E[x2 ] = E[y] = 0, and we also have
E[yx1 ] = E[x21 ] + 2 E[x2 x1 ] = E[x21 ] âˆ’ E[x21 ] + E[zx1 ] = 0.
Therefore, for a large enough training set, the first feature is likely to have a
Pearsonâ€™s correlation coefficient that is close to zero, and hence it will most
probably not be selected. However, no function can predict the target value well
without knowing the first feature.
There are many other score functions that can be used by a filter method.
Notable examples are estimators of the mutual information or the area under
the receiver operating characteristic (ROC) curve. All of these score functions
suffer from similar problems to the one illustrated previously. We refer the reader
to Guyon & Elisseeff (2003).

25.1.2

Greedy Selection Approaches
Greedy selection is another popular approach for feature selection. Unlike filter
methods, greedy selection approaches are coupled with the underlying learning
algorithm. The simplest instance of greedy selection is forward greedy selection.
We start with an empty set of features, and then we gradually add one feature
at a time to the set of selected features. Given that our current set of selected
features is I, we go over all i âˆˆ
/ I, and apply the learning algorithm on the set
of features I âˆª {i}. Each such application yields a different predictor, and we
choose to add the feature that yields the predictor with the smallest risk (on
the training set or on a validation set). This process continues until we either
select k features, where k is a predefined budget of allowed features, or achieve
an accurate enough predictor.
Example 25.2 (Orthogonal Matching Pursuit) To illustrate the forward
greedy selection approach, we specify it to the problem of linear regression with
the squared loss. Let X âˆˆ Rm,d be a matrix whose rows are the m training
instances. Let y âˆˆ Rm be the vector of the m labels. For every i âˆˆ [d], let Xi
be the ith column of X. Given a set I âŠ‚ [d] we denote by XI the matrix whose
columns are {Xi : i âˆˆ I}.
The forward greedy selection method starts with I0 = âˆ…. At iteration t, we
look for the feature index jt , which is in
argmin mint kXItâˆ’1 âˆª{j} w âˆ’ yk2 .
j

wâˆˆR

25.1 Feature Selection

361

Then, we update It = Itâˆ’1 âˆª {jt }.
We now describe a more efficient implementation of the forward greedy selection approach for linear regression which is called Orthogonal Matching Pursuit
(OMP). The idea is to keep an orthogonal basis of the features aggregated so
far. Let Vt be a matrix whose columns form an orthonormal basis of the columns
of XIt .
Clearly,
min kXIt w âˆ’ yk2 = mint kVt Î¸ âˆ’ yk2 .
w

Î¸âˆˆR

We will maintain a vector Î¸ t which minimizes the right-hand side of the equation.
Initially, we set I0 = âˆ…, V0 = âˆ…, and Î¸ 1 to be the empty vector. At round t, for
>
every j, we decompose Xj = vj + uj where vj = Vtâˆ’1 Vtâˆ’1
Xj is the projection
of Xj onto the subspace spanned by Vtâˆ’1 and uj is the part of Xj orthogonal to
Vtâˆ’1 (see Appendix C). Then,
min kVtâˆ’1 Î¸ + Î±uj âˆ’ yk2
Î¸,Î±


= min kVtâˆ’1 Î¸ âˆ’ yk2 + Î±2 kuj k2 + 2Î±huj , Vtâˆ’1 Î¸ âˆ’ yi
Î¸,Î±


= min kVtâˆ’1 Î¸ âˆ’ yk2 + Î±2 kuj k2 + 2Î±huj , âˆ’yi
Î¸,Î±




= min kVtâˆ’1 Î¸ âˆ’ yk2 + min Î±2 kuj k2 âˆ’ 2Î±huj , yi
Î±
Î¸




2
= kVtâˆ’1 Î¸ tâˆ’1 âˆ’ yk + min Î±2 kuj k2 âˆ’ 2Î±huj , yi
Î±

(huj , yi)2
.
= kVtâˆ’1 Î¸ tâˆ’1 âˆ’ yk2 âˆ’
kuj k2
It follows that we should select the feature
jt = argmax
j

(huj , yi)2
.
kuj k2

The rest of the update is to set

Vt = Vtâˆ’1 ,

ujt
kujt k2


,



hujt , yi
Î¸ t = Î¸ tâˆ’1 ;
.
kujt k2

The OMP procedure maintains an orthonormal basis of the selected features,
where in the preceding description, the orthonormalization property is obtained
by a procedure similar to Gram-Schmidt orthonormalization. In practice, the
Gram-Schmidt procedure is often numerically unstable. In the pseudocode that
follows we use SVD (see Section C.4) at the end of each round to obtain an
orthonormal basis in a numerically stable manner.

362

Feature Selection and Generation

Orthogonal Matching Pursuit (OMP)
input:
data matrix X âˆˆ Rm,d , labels vector y âˆˆ Rm ,
budget of features T
initialize: I1 = âˆ…
for t = 1, . . . , T
use SVD to find an orthonormal basis V âˆˆ Rm,tâˆ’1 of XIt
(for t = 1 set V to be the all zeros matrix)
foreach j âˆˆ [d] \ It let uj = Xj âˆ’ V V > Xj
let jt = argmaxj âˆˆI
/ t :kuj k>0
update It+1 = It âˆª {jt }
output IT +1

(huj ,yi)2
kuj k2

More Efficient Greedy Selection Criteria
Let R(w) be the empirical risk of a vector w. At each round of the forward
greedy selection method, and for every possible j, we should minimize R(w)
over the vectors w whose support is Itâˆ’1 âˆª {j}. This might be time consuming.
A simpler approach is to choose jt that minimizes
argmin min R(wtâˆ’1 + Î·ej ),
j

Î·âˆˆR

where ej is the all zeros vector except 1 in the jth element. That is, we keep
the weights of the previously chosen coordinates intact and only optimize over
the new variable. Therefore, for each j we need to solve an optimization problem
over a single variable, which is a much easier task than optimizing over t.
An even simpler approach is to upper bound R(w) using a â€œsimpleâ€ function
and then choose the feature which leads to the largest decrease in this upper
bound. For example, if R is a Î²-smooth function (see Equation (12.5) in Chapter 12), then
R(w + Î·ej ) â‰¤ R(w) + Î·

âˆ‚R(w)
+ Î²Î· 2 /2.
âˆ‚wj

1
Minimizing the right-hand side over Î· yields Î· = âˆ’ âˆ‚R(w)
âˆ‚wj Â· Î² and plugging this
value into the above yields

2
1 âˆ‚R(w)
R(w + Î·ej ) â‰¤ R(w) âˆ’
.
2Î²
âˆ‚wj

This value is minimized if the partial derivative of R(w) with respect to wj is
maximal. We can therefore choose jt to be the index of the largest coordinate of
the gradient of R(w) at w.
Remark 25.3 (AdaBoost as a Forward Greedy Selection Procedure) It is possible to interpret the AdaBoost algorithm from Chapter 10 as a forward greedy

25.1 Feature Selection

selection procedure with respect to the function
ï£«
ï£«
ï£¶ï£¶
m
d
X
X
R(w) = log ï£­
exp ï£­âˆ’yi
wj hj (xi )ï£¸ï£¸ .
i=1

363

(25.3)

j=1

See Exercise 3.

Backward Elimination
Another popular greedy selection approach is backward elimination. Here, we
start with the full set of features, and then we gradually remove one feature at a
time from the set of features. Given that our current set of selected features is I,
we go over all i âˆˆ I, and apply the learning algorithm on the set of features I \{i}.
Each such application yields a different predictor, and we choose to remove the
feature i for which the predictor obtained from I \ {i} has the smallest risk (on
the training set or on a validation set).
Naturally, there are many possible variants of the backward elimination idea.
It is also possible to combine forward and backward greedy steps.

25.1.3

Sparsity-Inducing Norms
The problem of minimizing the empirical risk subject to a budget of k features
can be written as
min LS (w)
w

s.t.

kwk0 â‰¤ k,

where1
kwk0 = |{i : wi 6= 0}|.
In other words, we want w to be sparse, which implies that we only need to
measure the features corresponding to nonzero elements of w.
Solving this optimization problem is computationally hard (Natarajan 1995,
Davis, Mallat & Avellaneda 1997). A possible relaxation is to replace the nonPd
convex function kwk0 with the `1 norm, kwk1 =
i=1 |wi |, and to solve the
problem
min LS (w)
w

s.t. kwk1 â‰¤ k1 ,

(25.4)

where k1 is a parameter. Since the `1 norm is a convex function, this problem
can be solved efficiently as long as the loss function is convex. A related problem
is minimizing the sum of LS (w) plus an `1 norm regularization term,
min (LS (w) + Î»kwk1 ) ,
w

(25.5)

where Î» is a regularization parameter. Since for any k1 there exists a Î» such that
1

The function k Â· k0 is often referred to as the `0 norm. Despite the use of the â€œnormâ€
notation, k Â· k0 is not really a norm; for example, it does not satisfy the positive
homogeneity property of norms, kawk0 6= |a| kwk0 .

364

Feature Selection and Generation

Equation (25.4) and Equation (25.5) lead to the same solution, the two problems
are in some sense equivalent.
The `1 regularization often induces sparse solutions. To illustrate this, let us
start with the simple optimization problem


1 2
min
w âˆ’ xw + Î»|w| .
(25.6)
wâˆˆR 2
It is easy to verify (see Exercise 2) that the solution to this problem is the â€œsoft
thresholdingâ€ operator
w = sign(x) [|x| âˆ’ Î»]+ ,

(25.7)

def

where [a]+ = max{a, 0}. That is, as long as the absolute value of x is smaller
than Î», the optimal solution will be zero.
Next, consider a one dimensional regression problem with respect to the squared
loss:
!
m
1 X
2
(xi w âˆ’ yi ) + Î»|w| .
argmin
2m i=1
wâˆˆRm
We can rewrite the problem as
argmin
wâˆˆRm

1
2

!
1
m

X

x2i

2

w âˆ’

i

1
m

m
X

!
xi yi

!
w + Î»|w| .

i=1

For simplicity let us assume that
then the optimal solution is

1
m

P

i

x2i = 1, and denote hx, yi =

Pm

i=1

xi yi ;

w = sign(hx, yi) [|hx, yi|/m âˆ’ Î»]+ .
That is, the solution will be zero unless the correlation between the feature x
and the labels vector y is larger than Î».
Remark 25.4 Unlike the `1 norm, the `2 norm does not induce sparse solutions.
Indeed, consider the problem above with an `2 regularization, namely,
!
m
1 X
(xi w âˆ’ yi )2 + Î»w2 .
argmin
2m i=1
wâˆˆRm
Then, the optimal solution is
w=

hx, yi/m
.
kxk2 /m + 2Î»

This solution will be nonzero even if the correlation between x and y is very small.
In contrast, as we have shown before, when using `1 regularization, w will be
nonzero only if the correlation between x and y is larger than the regularization
parameter Î».

25.2 Feature Manipulation and Normalization

365

Adding `1 regularization to a linear regression problem with the squared loss
yields the LASSO algorithm, defined as


1
2
argmin
kXw âˆ’ yk + Î»kwk1 .
(25.8)
2m
w
Under some assumptions on the distribution and the regularization parameter
Î», the LASSO will find sparse solutions (see, for example, (Zhao & Yu 2006)
and the references therein). Another advantage of the `1 norm is that a vector
with low `1 norm can be â€œsparsifiedâ€ (see, for example, (Shalev-Shwartz, Zhang
& Srebro 2010) and the references therein).

25.2

Feature Manipulation and Normalization
Feature manipulations or normalization include simple transformations that we
apply on each of our original features. Such transformations may decrease the
approximation or estimation errors of our hypothesis class or can yield a faster
algorithm. Similarly to the problem of feature selection, here again there are no
absolute â€œgoodâ€ and â€œbadâ€ transformations, but rather each transformation that
we apply should be related to the learning algorithm we are going to apply on
the resulting feature vector as well as to our prior assumptions on the problem.
To motivate normalization, consider a linear regression problem with the
squared loss. Let X âˆˆ Rm,d be a matrix whose rows are the instance vectors
and let y âˆˆ Rm be a vector of target values. Recall that ridge regression returns
the vector


1
kXw âˆ’ yk2 + Î»kwk2 = (2Î»mI + X > X)âˆ’1 X > y.
argmin
m
w
Suppose that d = 2 and the underlying data distribution is as follows. First we
sample y uniformly at random from {Â±1}. Then, we set x1 to be y + 0.5Î±, where
Î± is sampled uniformly at random from {Â±1}, and we set x2 to be 0.0001y. Note
that the optimal weight vector is w? = [0; 10000], and LD (w? ) = 0. However,
the objective of ridge regression at w? is Î»108 . In contrast, the objective of ridge
regression at w = [1; 0] is likely to be close to 0.25 + Î». It follows that whenever
âˆ’8
, the objective of ridge regression is smaller at the
Î» > 100.25
8 âˆ’1 â‰ˆ 0.25 Ã— 10
suboptimal solution w = [1; 0]. Since Î» typically should be at least 1/m (see
the analysis in Chapter 13), it follows that in the aforementioned example, if the
number of examples is smaller than 108 then we are likely to output a suboptimal
solution.
The crux of the preceding example is that the two features have completely
different scales. Feature normalization can overcome this problem. There are
many ways to perform feature normalization, and one of the simplest approaches
is simply to make sure that each feature receives values between âˆ’1 and 1. In
the preceding example, if we divide each feature by the maximal value it attains

366

Feature Selection and Generation

and x2 = y. Then, for Î» â‰¤ 10âˆ’3 the solution of
we will obtain that x1 = y+0.5Î±
1.5
ridge regression is quite close to w? .
Moreover, the generalization bounds we have derived in Chapter 13 for regularized loss minimization depend on the norm of the optimal vector w? and
on the maximal norm of the instance vectors.2 Therefore, in the aforementioned
example, before we normalize the features we have that kw? k2 = 108 , while after we normalize the features we have that kw? k2 = 1. The maximal norm of
the instance vector remains roughly the same; hence the normalization greatly
improves the estimation error.
Feature normalization can also improve the runtime of the learning algorithm.
For example, in Section 14.5.3 we have shown how to use the Stochastic Gradient
Descent (SGD) optimization algorithm for solving the regularized loss minimization problem. The number of iterations required by SGD to converge also depends
on the norm of w? and on the maximal norm of kxk. Therefore, as before, using
normalization can greatly decrease the runtime of SGD.
Next, we demonstrate in the following how a simple transformation on features,
such as clipping, can sometime decrease the approximation error of our hypothesis class. Consider again linear regression with the squared loss. Let a > 1 be
a large number, suppose that the target y is chosen uniformly at random from
{Â±1}, and then the single feature x is set to be y with probability (1 âˆ’ 1/a)
and set to be ay with probability 1/a. That is, most of the time our feature is
bounded but with a very small probability it gets a very high value. Then, for
any w, the expected squared loss of w is
1
LD (w) = E (wx âˆ’ y)2
2


1 1
1 1
= 1âˆ’
(wy âˆ’ y)2 +
(awy âˆ’ y)2 .
a 2
a 2
Solving for w we obtain that w? = a22aâˆ’1
+aâˆ’1 , which goes to zero as a goes to infinity. Therefore, the objective at w? goes to 0.5 as a goes to infinity. For example,
for a = 100 we will obtain LD (w? ) â‰¥ 0.48. Next, suppose we apply a â€œclippingâ€
transformation; that is, we use the transformation x 7â†’ sign(x) min{1, |x|}. Then,
following this transformation, w? becomes 1 and LD (w? ) = 0. This simple example shows that a simple transformation can have a significant influence on the
approximation error.
Of course, it is not hard to think of examples in which the same feature transformation actually hurts performance and increases the approximation error.
This is not surprising, as we have already argued that feature transformations
2

More precisely, the bounds we derived in Chapter 13 for regularized loss minimization
depend on kw? k2 and on either the Lipschitzness or the smoothness of the loss function.
For linear predictors and loss functions of the form `(w, (x, y)) = Ï†(hw, xi, y), where Ï† is
convex and either 1-Lipschitz or 1-smooth with respect to its first argument, we have that
` is either kxk-Lipschitz or kxk2 -smooth. For example, for the squared loss,
Ï†(a, y) = 21 (a âˆ’ y)2 , and `(w, (x, y)) = 21 (hw, xi âˆ’ y)2 is kxk2 -smooth with respect to its
first argument.

25.2 Feature Manipulation and Normalization

367

should rely on our prior assumptions on the problem. In the aforementioned example, a prior assumption that may lead us to use the â€œclippingâ€ transformation
is that features that get values larger than a predefined threshold value give us no
additional useful information, and therefore we can clip them to the predefined
threshold.

25.2.1

Examples of Feature Transformations
We now list several common techniques for feature transformations. Usually, it
is helpful to combine some of these transformations (e.g., centering + scaling).
In the following, we denote by f = (f1 , . . . , fm ) âˆˆ Rm the value of the feature f
Pm
1
over the m training examples. Also, we denote by fÂ¯ = m
i=1 fi the empirical
mean of the feature over all examples.

Centering:
This transformation makes the feature have zero mean, by setting fi â† fi âˆ’ fÂ¯.

Unit Range:
This transformation makes the range of each feature be [0, 1]. Formally, let
fi âˆ’fmin
fmax = maxi fi and fmin = mini fi . Then, we set fi â† fmax
âˆ’fmin . Similarly,
we can make the range of each feature be [âˆ’1, 1] by the transformation fi â†
fi âˆ’fmin
2 fmax
âˆ’fmin âˆ’ 1. Of course, it is easy to make the range [0, b] or [âˆ’b, b], where b is
a user-specified parameter.

Standardization:
This transformation makes all features have a zero mean and unit variance.
Pm
1
Â¯2
Formally, let Î½ = m
i=1 (fi âˆ’ f ) be the empirical variance of the feature.
Â¯
fâˆš
i âˆ’f
Then, we set fi â† Î½ .

Clipping:
This transformation clips high or low values of the feature. For example, fi â†
sign(fi ) max{b, |fi |}, where b is a user-specified parameter.

Sigmoidal Transformation:
As its name indicates, this transformation applies a sigmoid function on the
1
feature. For example, fi â† 1+exp(b
fi ) , where b is a user-specified parameter.
This transformation can be thought of as a â€œsoftâ€ version of clipping: It has a
small effect on values close to zero and behaves similarly to clipping on values
far away from zero.

368

Feature Selection and Generation

Logarithmic Transformation:
The transformation is fi â† log(b+fi ), where b is a user-specified parameter. This
is widely used when the feature is a â€œcountingâ€ feature. For example, suppose
that the feature represents the number of appearances of a certain word in a
text document. Then, the difference between zero occurrences of the word and
a single occurrence is much more important than the difference between 1000
occurrences and 1001 occurrences.
Remark 25.5 In the aforementioned transformations, each feature is transformed on the basis of the values it obtains on the training set, independently
of other featuresâ€™ values. In some situations we would like to set the parameter
of the transformation on the basis of other features as well. A notable example
is a transformation in which one applies a scaling to the features so that the
empirical average of some norm of the instances becomes 1.

25.3

Feature Learning
So far we have discussed feature selection and manipulations. In these cases, we
start with a predefined vector space Rd , representing our features. Then, we select
a subset of features (feature selection) or transform individual features (feature
transformation). In this section we describe feature learning, in which we start
with some instance space, X , and would like to learn a function, Ïˆ : X â†’ Rd ,
which maps instances in X into a representation as d-dimensional feature vectors.
The idea of feature learning is to automate the process of finding a good representation of the input space. As mentioned before, the No-Free-Lunch theorem
tells us that we must incorporate some prior knowledge on the data distribution
in order to build a good feature representation. In this section we present a few
feature learning approaches and demonstrate conditions on the underlying data
distribution in which these methods can be useful.
Throughout the book we have already seen several useful feature constructions. For example, in the context of polynomial regression, we have mapped the
original instances into the vector space of all their monomials (see Section 9.2.2
in Chapter 9). After performing this mapping, we trained a linear predictor on
top of the constructed features. Automation of this process would be to learn
a transformation Ïˆ : X â†’ Rd , such that the composition of the class of linear
predictors on top of Ïˆ yields a good hypothesis class for the task at hand.
In the following we describe a technique of feature construction called dictionary learning.

25.3.1

Dictionary Learning Using Auto-Encoders
The motivation of dictionary learning stems from a commonly used representation of documents as a â€œbag-of-wordsâ€: Given a dictionary of words D =
{w1 , . . . , wk }, where each wi is a string representing a word in the dictionary,

25.3 Feature Learning

369

and given a document, (p1 , . . . , pd ), where each pi is a word in the document,
we represent the document as a vector x âˆˆ {0, 1}k , where xi is 1 if wi = pj for
some j âˆˆ [d], and xi = 0 otherwise. It was empirically observed in many text
processing tasks that linear predictors are quite powerful when applied on this
representation. Intuitively, we can think of each word as a feature that measures
some aspect of the document. Given labeled examples (e.g., topics of the documents), a learning algorithm searches for a linear predictor that weights these
features so that a right combination of appearances of words is indicative of the
label.
While in text processing there is a natural meaning to words and to the dictionary, in other applications we do not have such an intuitive representation
of an instance. For example, consider the computer vision application of object
recognition. Here, the instance is an image and the goal is to recognize which
object appears in the image. Applying a linear predictor on the pixel-based representation of the image does not yield a good classifier. What we would like
to have is a mapping Ïˆ that would take the pixel-based representation of the
image and would output a bag of â€œvisual words,â€ representing the content of the
image. For example, a â€œvisual wordâ€ can be â€œthere is an eye in the image.â€ If
we had such representation, we could have applied a linear predictor on top of
this representation to train a classifier for, say, face recognition. Our question is,
therefore, how can we learn a dictionary of â€œvisual wordsâ€ such that a bag-ofwords representation of an image would be helpful for predicting which object
appears in the image?
A first naive approach for dictionary learning relies on a clustering algorithm
(see Chapter 22). Suppose that we learn a function c : X â†’ {1, . . . , k}, where
c(x) is the cluster to which x belongs. Then, we can think of the clusters as
â€œwords,â€ and of instances as â€œdocuments,â€ where a document x is mapped to
the vector Ïˆ(x) âˆˆ {0, 1}k , where Ïˆ(x)i is 1 if and only if x belongs to the ith
cluster. Now, it is straightforward to see that applying a linear predictor on Ïˆ(x)
is equivalent to assigning the same target value to all instances that belong to
the same cluster. Furthermore, if the clustering is based on distances from a
class center (e.g., k-means), then a linear predictor on Ïˆ(x) yields a piece-wise
constant predictor on x.
Both the k-means and PCA approaches can be regarded as special cases of a
more general approach for dictionary learning which is called auto-encoders. In an
auto-encoder we learn a pair of functions: an â€œencoderâ€ function, Ïˆ : Rd â†’ Rk ,
and a â€œdecoderâ€ function, Ï† : Rk â†’ Rd . The goal of the learning process is to
P
find a pair of functions such that the reconstruction error, i kxi âˆ’ Ï†(Ïˆ(xi ))k2 ,
is small. Of course, we can trivially set k = d and both Ïˆ, Ï† to be the identity
mapping, which yields a perfect reconstruction. We therefore must restrict Ïˆ and
Ï† in some way. In PCA, we constrain k < d and further restrict Ïˆ and Ï† to be
linear functions. In k-means, k is not restricted to be smaller than d, but now
Ïˆ and Ï† rely on k centroids, Âµ1 , . . . , Âµk , and Ïˆ(x) returns an indicator vector

370

Feature Selection and Generation

in {0, 1}k that indicates the closest centroid to x, while Ï† takes as input an
indicator vector and returns the centroid representing this vector.
An important property of the k-means construction, which is key in allowing
k to be larger than d, is that Ïˆ maps instances into sparse vectors. In fact, in
k-means only a single coordinate of Ïˆ(x) is nonzero. An immediate extension of
the k-means construction is therefore to restrict the range of Ïˆ to be vectors with
at most s nonzero elements, where s is a small integer. In particular, let Ïˆ and Ï†
be functions that depend on Âµ1 , . . . , Âµk . The function Ïˆ maps an instance vector
x to a vector Ïˆ(x) âˆˆ Rk , where Ïˆ(x) should have at most s nonzero elements.
Pk
The function Ï†(v) is defined to be i=1 vi Âµi . As before, our goal is to have a
small reconstruction error, and therefore we can define
Ïˆ(x) = argmin kx âˆ’ Ï†(v)k2 s.t. kvk0 â‰¤ s,
v

where kvk0 = |{j : vj 6= 0}|. Note that when s = 1 and we further restrict kvk1 =
1 then we obtain the k-means encoding function; that is, Ïˆ(x) is the indicator
vector of the centroid closest to x. For larger values of s, the optimization problem
in the preceding definition of Ïˆ becomes computationally difficult. Therefore, in
practice, we sometime use `1 regularization instead of the sparsity constraint and
define Ïˆ to be


Ïˆ(x) = argmin kx âˆ’ Ï†(v)k2 + Î»kvk1 ,
v

where Î» > 0 is a regularization parameter. Anyway, the dictionary learning
problem is now to find the vectors Âµ1 , . . . , Âµk such that the reconstruction erPm
ror, i=1 kxi âˆ’ Ï†(Ïˆ(x))k2 , is as small as possible. Even if Ïˆ is defined using
the `1 regularization, this is still a computationally hard problem (similar to
the k-means problem). However, several heuristic search algorithms may give
reasonably good solutions. These algorithms are beyond the scope of this book.

25.4

Summary
Many machine learning algorithms take the feature representation of instances
for granted. Yet the choice of representation requires careful attention. We discussed approaches for feature selection, introducing filters, greedy selection algorithms, and sparsity-inducing norms. Next we presented several examples for
feature transformations and demonstrated their usefulness. Last, we discussed
feature learning, and in particular dictionary learning. We have shown that feature selection, manipulation, and learning all depend on some prior knowledge
on the data.

25.5 Bibliographic Remarks

25.5

371

Bibliographic Remarks
Guyon & Elisseeff (2003) surveyed several feature selection procedures, including
many types of filters.
Forward greedy selection procedures for minimizing a convex objective subject to a polyhedron constraint date back to the Frank-Wolfe algorithm (Frank
& Wolfe 1956). The relation to boosting has been studied by several authors,
including, (Warmuth, Liao & Ratsch 2006, Warmuth, Glocer & Vishwanathan
2008, Shalev-Shwartz & Singer 2008). Matching pursuit has been studied in the
signal processing community (Mallat & Zhang 1993). Several papers analyzed
greedy selection methods under various conditions. See, for example, ShalevShwartz, Zhang & Srebro (2010) and the references therein.
The use of the `1 -norm as a surrogate for sparsity has a long history (e.g. Tibshirani (1996) and the references therein), and much work has been done on understanding the relationship between the `1 -norm and sparsity. It is also closely
related to compressed sensing (see Chapter 23). The ability to sparsify low `1
norm predictors dates back to Maurey (Pisier 1980-1981). In Section 26.4 we
also show that low `1 norm can be used to bound the estimation error of our
predictor.
Feature learning and dictionary learning have been extensively studied recently
in the context of deep neural networks. See, for example, (Lecun & Bengio 1995,
Hinton et al. 2006, Ranzato et al. 2007, Collobert & Weston 2008, Lee et al.
2009, Le et al. 2012, Bengio 2009) and the references therein.

25.6

Exercises
1. Prove the equality given in Equation (25.1). Hint: Let aâˆ— , bâˆ— be minimizers of
the left-hand side. Find a, b such that the objective value of the right-hand
side is smaller than that of the left-hand side. Do the same for the other
direction.
2. Show that Equation (25.7) is the solution of Equation (25.6).
3. AdaBoost as a Forward Greedy Selection Algorithm: Recall the AdaBoost algorithm from Chapter 10. In this section we give another interpretation of AdaBoost as a forward greedy selection algorithm.
â€¢ Given a set of m instances x1 , . . . , xm , and a hypothesis class H of finite
VC dimension, show that there exist d and h1 , . . . , hd such that for every
h âˆˆ H there exists i âˆˆ [d] with hi (xj ) = h(xj ) for every j âˆˆ [m].
â€¢ Let R(w) be as defined in Equation (25.3). Given some w, define fw to be
the function
fw (Â·) =

d
X
i=1

wi hi (Â·).

372

Feature Selection and Generation

Let D be the distribution over [m] defined by
exp(âˆ’yi fw (xi ))
,
Z
where Z is a normalization factor that ensures that D is a probability
vector. Show that
m
X
âˆ‚R(w)
=âˆ’
Di yi hj (xi ).
wj
i=1
Pm
Furthermore, denoting j = i=1 Di 1[hj (xi )6=yi ] , show that
Di =

âˆ‚R(w)
= 2j âˆ’ 1.
wj




Conclude that if j â‰¤ 1/2 âˆ’ Î³ then  âˆ‚R(w)
wj  â‰¥ Î³/2.
(t+1)
â€¢ Show that
) âˆ’ R(w(t) ) â‰¤
p the update of AdaBoost guarantees R(w
log( 1 âˆ’ 4Î³ 2 ). Hint: Use the proof of Theorem 10.2.

Part IV
Advanced Theory

26 Rademacher Complexities

In Chapter 4 we have shown that uniform convergence is a sufficient condition
for learnability. In this chapter we study the Rademacher complexity, which
measures the rate of uniform convergence. We will provide generalization bounds
based on this measure.

26.1

The Rademacher Complexity
Recall the definition of an -representative sample from Chapter 4, repeated here
for convenience.
definition 26.1 (-Representative Sample) A training set S is called -representative
(w.r.t. domain Z, hypothesis class H, loss function `, and distribution D) if
sup |LD (h) âˆ’ LS (h)| â‰¤ .
hâˆˆH

We have shown that if S is an /2 representative sample then the ERM rule
is -consistent, namely, LD (ERMH (S)) â‰¤ minhâˆˆH LD (h) + .
To simplify our notation, let us denote
def

def

F = ` â—¦ H = {z 7â†’ `(h, z) : h âˆˆ H},
and given f âˆˆ F, we define
m

LD (f ) = E [f (z)] ,
zâˆ¼D

1 X
LS (f ) =
f (zi ).
m i=1

We define the representativeness of S with respect to F as the largest gap between the true error of a function f and its empirical error, namely,

def
RepD (F, S) = sup LD (f ) âˆ’ LS (f ) .
(26.1)
f âˆˆF

Now, suppose we would like to estimate the representativeness of S using the
sample S only. One simple idea is to split S into two disjoint sets, S = S1 âˆª S2 ;
refer to S1 as a validation set and to S2 as a training set. We can then estimate
the representativeness of S by

sup LS1 (f ) âˆ’ LS2 (f ) .
(26.2)
f âˆˆF

c 2014 by Shai Shalev-Shwartz and Shai Ben-David
Understanding Machine Learning, 
Published 2014 by Cambridge University Press.
Personal use only. Not for distribution. Do not post.
Please link to http://www.cs.huji.ac.il/~shais/UnderstandingMachineLearning

376

Rademacher Complexities

This can be written more compactly by defining Ïƒ = (Ïƒ1 , . . . , Ïƒm ) âˆˆ {Â±1}m to
be a vector such that S1 = {zi : Ïƒi = 1} and S2 = {zi : Ïƒi = âˆ’1}. Then, if we
further assume that |S1 | = |S2 | then Equation (26.2) can be rewritten as
m
X
2
sup
Ïƒi f (zi ).
m f âˆˆF i=1

(26.3)

The Rademacher complexity measure captures this idea by considering the expectation of the above with respect to a random choice of Ïƒ. Formally, let F â—¦ S
be the set of all possible evaluations a function f âˆˆ F can achieve on a sample
S, namely,
F â—¦ S = {(f (z1 ), . . . , f (zm )) : f âˆˆ F}.
Let the variables in Ïƒ be distributed i.i.d. according to P[Ïƒi = 1] = P[Ïƒi = âˆ’1] =
1
2 . Then, the Rademacher complexity of F with respect to S is defined as follows:
#
"
m
X
def 1
Ïƒi f (zi ) .
(26.4)
E
sup
R(F â—¦ S) =
m Ïƒâˆ¼{Â±1}m f âˆˆF i=1
More generally, given a set of vectors, A âŠ‚ Rm , we define
#
"
m
X
def 1
Ïƒi ai .
R(A) =
E sup
m Ïƒ aâˆˆA i=1

(26.5)

The following lemma bounds the expected value of the representativeness of
S by twice the expected Rademacher complexity.
lemma 26.2
E

Sâˆ¼D m

[ RepD (F, S)] â‰¤ 2

E

Sâˆ¼D m

R(F â—¦ S).

0
} be another i.i.d. sample. Clearly, for all f âˆˆ F,
Proof Let S 0 = {z10 , . . . , zm
LD (f ) = ES 0 [LS 0 (f )]. Therefore, for every f âˆˆ F we have

LD (f ) âˆ’ LS (f ) = E0 [LS 0 (f )] âˆ’ LS (f ) = E0 [LS 0 (f ) âˆ’ LS (f )].
S

S

Taking supremum over f âˆˆ F of both sides, and using the fact that the supremum
of expectation is smaller than expectation of the supremum we obtain

sup LD (f ) âˆ’ LS (f ) = sup E0 [LS 0 (f ) âˆ’ LS (f )]
S

f âˆˆF

f âˆˆF

"
â‰¤ E0

#
sup LS 0 (f ) âˆ’ LS (f )

S



.

f âˆˆF

Taking expectation over S on both sides we obtain
"
#
"
#


E sup LD (f ) âˆ’ LS (f ) â‰¤ E 0 sup LS 0 (f ) âˆ’ LS (f )
S

f âˆˆF

S,S

1
=
m

f âˆˆF

"
E

S,S 0

#
m
X
0
sup
(f (zi ) âˆ’ f (zi )) .

f âˆˆF

i=1

(26.6)

26.1 The Rademacher Complexity

377

Next, we note that for each j, zj and zj0 are i.i.d. variables. Therefore, we can
replace them without affecting the expectation:
ï£®
ï£«
ï£¶ï£¹
X
E 0 ï£° sup ï£­(f (zj0 ) âˆ’ f (zj )) +
(f (zi0 ) âˆ’ f (zi ))ï£¸ï£» =
S,S

f âˆˆF

ï£®

i6=j

ï£«

ï£¶ï£¹
X
E 0 ï£° sup ï£­(f (zj ) âˆ’ f (zj0 )) +
(f (zi0 ) âˆ’ f (zi ))ï£¸ï£» .

S,S

f âˆˆF

(26.7)

i6=j

Let Ïƒj be a random variable such that P[Ïƒj = 1] = P[Ïƒj = âˆ’1] = 1/2. From
Equation (26.7) we obtain that
ï£®
ï£«
ï£¶ï£¹
X
E0 ï£° sup ï£­Ïƒj (f (zj0 ) âˆ’ f (zj )) +
(f (zi0 ) âˆ’ f (zi ))ï£¸ ï£»
S,S ,Ïƒj

f âˆˆF

i6=j

1
1
(l.h.s. of Equation (26.7)) + (r.h.s. of Equation (26.7))
2 ï£®
2
ï£«
ï£¶ï£¹
X
= E 0 ï£° sup ï£­(f (zj0 ) âˆ’ f (zj )) +
(f (zi0 ) âˆ’ f (zi ))ï£¸ ï£» .
=

S,S

f âˆˆF

(26.8)

i6=j

Repeating this for all j we obtain that
#
"
#
"
m
m
X
X
0
0
Ïƒi (f (zi ) âˆ’ f (zi )) . (26.9)
sup
(f (zi ) âˆ’ f (zi )) = E0
E 0 sup
S,S

S,S ,Ïƒ

f âˆˆF i=1

f âˆˆF i=1

Finally,
sup

X

f âˆˆF

Ïƒi (f (zi0 ) âˆ’ f (zi )) â‰¤ sup

X

f âˆˆF

i

Ïƒi f (zi0 ) + sup

X

f âˆˆF

i

âˆ’Ïƒi f (zi )

i

and since the probability of Ïƒ is the same as the probability of âˆ’Ïƒ, the right-hand
side of Equation (26.9) can be bounded by
"
#
X
X
0
E0
sup
Ïƒi f (zi ) + sup
Ïƒi f (zi )
S,S ,Ïƒ

f âˆˆF

f âˆˆF

i

i

0

= m E0 [R(F â—¦ S )] + m E[R(F â—¦ S)] = 2m E[R(F â—¦ S)].
S

S

S

The lemma immediately yields that, in expectation, the ERM rule finds a
hypothesis which is close to the optimal hypothesis in H.
theorem 26.3
E

Sâˆ¼D m

We have

[LD (ERMH (S)) âˆ’ LS (ERMH (S))] â‰¤ 2

E

Sâˆ¼D m

R(` â—¦ H â—¦ S).

Furthermore, for any h? âˆˆ H
E

Sâˆ¼D m

[LD (ERMH (S)) âˆ’ LD (h? )] â‰¤ 2

E

Sâˆ¼D m

R(` â—¦ H â—¦ S).

378

Rademacher Complexities

Furthermore, if h? = argminh LD (h) then for each Î´ âˆˆ (0, 1) with probability of
at least 1 âˆ’ Î´ over the choice of S we have
LD (ERMH (S)) âˆ’ LD (h? ) â‰¤

2 ES 0 âˆ¼Dm R(` â—¦ H â—¦ S 0 )
.
Î´

Proof The first inequality follows directly from Lemma 26.2. The second inequality follows because for any fixed h? ,
LD (h? ) = E[LS (h? )] â‰¥ E[LS (ERMH (S))].
S

S

The third inequality follows from the previous inequality by relying on Markovâ€™s
inequality (note that the random variable LD (ERMH (S)) âˆ’ LD (h? ) is nonnegative).
Next, we derive bounds similar to the bounds in Theorem 26.3 with a better
dependence on the confidence parameter Î´. To do so, we first introduce the
following bounded differences concentration inequality.
lemma 26.4 (McDiarmidâ€™s Inequality) Let V be some set and let f : V m â†’ R
be a function of m variables such that for some c > 0, for all i âˆˆ [m] and for all
x1 , . . . , xm , x0i âˆˆ V we have
|f (x1 , . . . , xm ) âˆ’ f (x1 , . . . , xiâˆ’1 , x0i , xi+1 , . . . , xm )| â‰¤ c.
Let X1 , . . . , Xm be m independent random variables taking values in V . Then,
with probability of at least 1 âˆ’ Î´ we have
q

|f (X1 , . . . , Xm ) âˆ’ E[f (X1 , . . . , Xm )]| â‰¤ c ln 2Î´ m/2.
On the basis of the McDiarmid inequality we can derive generalization bounds
with a better dependence on the confidence parameter.
theorem 26.5
Then,

Assume that for all z and h âˆˆ H we have that |`(h, z)| â‰¤ c.

1. With probability of at least 1 âˆ’ Î´, for all h âˆˆ H,
r
LD (h) âˆ’ LS (h) â‰¤ 2

E

S 0 âˆ¼D m

0

R(` â—¦ H â—¦ S ) + c

2 ln(2/Î´)
.
m

In particular, this holds for h = ERMH (S).
2. With probability of at least 1 âˆ’ Î´, for all h âˆˆ H,
r
LD (h) âˆ’ LS (h) â‰¤ 2 R(` â—¦ H â—¦ S) + 4 c

2 ln(4/Î´)
.
m

In particular, this holds for h = ERMH (S).
3. For any h? , with probability of at least 1 âˆ’ Î´,
r
?

LD (ERMH (S)) âˆ’ LD (h ) â‰¤ 2 R(` â—¦ H â—¦ S) + 5 c

2 ln (8/Î´)
.
m

26.1 The Rademacher Complexity

379

Proof First note that the random variable RepD (F, S) = suphâˆˆH (LD (h) âˆ’ LS (h))
satisfies the bounded differences condition of Lemma 26.4 with a constant 2c/m.
Combining the bounds in Lemma 26.4 with Lemma 26.2 we obtain that with
probability of at least 1 âˆ’ Î´,
r
r
2 ln(2/Î´)
2 ln(2/Î´)
0
RepD (F, S) â‰¤ E RepD (F, S) + c
â‰¤ 2 E0 R(` â—¦ H â—¦ S ) + c
.
S
m
m
The first inequality of the theorem follows from the definition of RepD (F, S).
For the second inequality we note that the random variable R(` â—¦ H â—¦ S) also
satisfies the bounded differences condition of Lemma 26.4 with a constant 2c/m.
Therefore, the second inequality follows from the first inequality, Lemma 26.4,
and the union bound. Finally, for the last inequality, denote hS = ERMH (S)
and note that
LD (hS ) âˆ’ LD (h? )
= LD (hS ) âˆ’ LS (hS ) + LS (hS ) âˆ’ LS (h? ) + LS (h? ) âˆ’ LD (h? )
â‰¤ (LD (hS ) âˆ’ LS (hS )) + (LS (h? ) âˆ’ LD (h? )) .

(26.10)

The first summand on the right-hand side is bounded by the second inequality of
the theorem. For the second summand, we use the fact that h? does not depend
on S; hence by using Hoeffdingâ€™s inequality we obtain that with probaility of at
least 1 âˆ’ Î´/2,
r
ln(4/Î´)
?
?
.
(26.11)
LS (h ) âˆ’ LD (h ) â‰¤ c
2m
Combining this with the union bound we conclude our proof.
The preceding theorem tells us that if the quantity R(` â—¦ H â—¦ S) is small then it
is possible to learn the class H using the ERM rule. It is important to emphasize
that the last two bounds given in the theorem depend on the specific training
set S. That is, we use S both for learning a hypothesis from H as well as for
estimating the quality of it. This type of bound is called a data-dependent bound.

26.1.1

Rademacher Calculus
Let us now discuss some properties of the Rademacher complexity measure.
These properties will help us in deriving some simple bounds on R(` â—¦ H â—¦ S) for
specific cases of interest.
The following lemma is immediate from the definition.
lemma 26.6

For any A âŠ‚ Rm , scalar c âˆˆ R, and vector a0 âˆˆ Rm , we have
R({c a + a0 : a âˆˆ A}) â‰¤ |c| R(A).

The following lemma tells us that the convex hull of A has the same complexity
as A.

380

Rademacher Complexities

PN
lemma 26.7 Let A be a subset of Rm and let A0 = { j=1 Î±j a(j) : N âˆˆ
N, âˆ€j, a(j) âˆˆ A, Î±j â‰¥ 0, kÎ±k1 = 1}. Then, R(A0 ) = R(A).
Proof

The main idea follows from the fact that for any vector v we have
N
X

sup

Î±j vj = max vj .
j

Î±â‰¥0:kÎ±k1 =1 j=1

Therefore,
0

m R(A ) = E

sup

m
X

sup

Ïƒ Î±â‰¥0:kÎ±k =1 a(1) ,...,a(N )
1
i=1

=E

N
X

sup

Ïƒ Î±â‰¥0:kÎ±k =1
1
j=1

= E sup

m
X

Ïƒ aâˆˆA
i=1

Î±j sup
a(j)

m
X

Ïƒi

N
X

(j)

Î±j ai

j=1
(j)

Ïƒi ai

i=1

Ïƒi ai

= m R(A),
and we conclude our proof.
The next lemma, due to Massart, states that the Rademacher complexity of
a finite set grows logarithmically with the size of the set.
lemma 26.8 (Massart lemma) Let A = {a1 , . . . , aN } be a finite set of vectors
PN
in Rm . Define aÌ„ = N1 i=1 ai . Then,
p
2 log(N )
R(A) â‰¤ max ka âˆ’ aÌ„k
.
aâˆˆA
m
Proof Based on Lemma 26.6, we can assume without loss of generality that
aÌ„ = 0. Let Î» > 0 and let A0 = {Î»a1 , . . . , Î»aN }. We upper bound the Rademacher
complexity as follows:



 
mR(A0 ) = E max0 hÏƒ, ai = E log max0 ehÏƒ,ai
Ïƒ aâˆˆA
Ïƒ
aâˆˆA
"
!#
X
â‰¤ E log
ehÏƒ,ai
Ïƒ

aâˆˆA0

"
â‰¤ log E
Ïƒ

#!
X

m
XY

= log

ehÏƒ,ai

// Jensenâ€™s inequality

aâˆˆA0

aâˆˆA0 i=1

!
E [e

Ïƒi

Ïƒi ai

] ,

where the last equality occurs because the Rademacher variables are independent. Next, using Lemma A.6 we have that for all ai âˆˆ R,
E eÏƒi ai =

Ïƒi

exp(ai ) + exp(âˆ’ai )
â‰¤ exp(a2i /2),
2

26.1 The Rademacher Complexity

381

and therefore
0

mR(A ) â‰¤ log

m
XY


exp

aâˆˆA0 i=1

a2i
2

!

!
= log

X

2

exp kak /2



aâˆˆA0




â‰¤ log |A0 | max0 exp kak2 /2 = log(|A0 |) + max0 (kak2 /2).
aâˆˆA

aâˆˆA

Since R(A) = Î»1 R(A0 ) we obtain from the equation that
R(A) â‰¤
Setting Î» =
proof.

p

log(|A|) + Î»2 maxaâˆˆA (kak2 /2)
.
Î»m

2 log(|A|)/ maxaâˆˆA kak2 and rearranging terms we conclude our

The following lemma shows that composing A with a Lipschitz function does
not blow up the Rademacher complexity. The proof is due to Kakade and Tewari.
lemma 26.9 (Contraction lemma) For each i âˆˆ [m], let Ï†i : R â†’ R be a ÏLipschitz function, namely for all Î±, Î² âˆˆ R we have |Ï†i (Î±) âˆ’ Ï†i (Î²)| â‰¤ Ï |Î± âˆ’ Î²|.
For a âˆˆ Rm let Ï†(a) denote the vector (Ï†1 (a1 ), . . . , Ï†m (ym )). Let Ï† â—¦ A = {Ï†(a) :
a âˆˆ A}. Then,
R(Ï† â—¦ A) â‰¤ Ï R(A).
Proof For simplicity, we prove the lemma for the case Ï = 1. The case Ï 6=
1 will follow by defining Ï†0 = Ï1 Ï† and then using Lemma 26.6. Let Ai =
{(a1 , . . . , aiâˆ’1 , Ï†i (ai ), ai+1 , . . . , am ) : a âˆˆ A}. Clearly, it suffices to prove that
for any set A and all i we have R(Ai ) â‰¤ R(A). Without loss of generality we will
prove the latter claim for i = 1 and to simplify notation we omit the subscript
from Ï†1 . We have
"
#
m
X
Ïƒi ai
mR(A1 ) = E sup
Ïƒ

aâˆˆA1 i=1

"
= E sup Ïƒ1 Ï†(a1 ) +
Ïƒ

aâˆˆA

m
X

#
Ïƒi ai

i=2

"
!
!#
m
m
X
X
1
=
E
sup Ï†(a1 ) +
Ïƒi ai + sup âˆ’Ï†(a1 ) +
Ïƒi ai
2 Ïƒ2 ,...,Ïƒm aâˆˆA
aâˆˆA
i=2
i=2
"
!#
m
m
X
X
1
0
0
E
=
sup Ï†(a1 ) âˆ’ Ï†(a1 ) +
Ïƒi ai +
Ïƒi ai
2 Ïƒ2 ,...,Ïƒm a,a0 âˆˆA
i=2
i=2
"
!#
m
m
X
X
1
0
0
E
sup |a1 âˆ’ a1 | +
Ïƒi ai +
Ïƒi ai
,
(26.12)
â‰¤
2 Ïƒ2 ,...,Ïƒm a,a0 âˆˆA
i=2
i=2
where in the last inequality we used the assumption that Ï† is Lipschitz. Next,
we note that the absolute value on |a1 âˆ’ a01 | in the preceding expression can

382

Rademacher Complexities

be omitted since both a and a0 are from the same set A and the rest of the
expression in the supremum is not affected by replacing a and a0 . Therefore,
"
!#
m
m
X
X
1
0
0
mR(A1 ) â‰¤
E
sup a1 âˆ’ a1 +
Ïƒi ai +
Ïƒi ai
.
(26.13)
2 Ïƒ2 ,...,Ïƒm a,a0 âˆˆA
i=2
i=2
But, using the same equalities as in Equation (26.12), it is easy to see that the
right-hand side of Equation (26.13) exactly equals m R(A), which concludes our
proof.

26.2

Rademacher Complexity of Linear Classes
In this section we analyze the Rademacher complexity of linear classes. To simplify the derivation we first define the following two classes:
H1 = {x 7â†’ hw, xi : kwk1 â‰¤ 1}

H2 = {x 7â†’ hw, xi : kwk2 â‰¤ 1}. (26.14)

,

The following lemma bounds the Rademacher complexity of H2 . We allow
the xi to be vectors in any Hilbert space (even infinite dimensional), and the
bound does not depend on the dimensionality of the Hilbert space. This property
becomes useful when analyzing kernel methods.
lemma 26.10 Let S = (x1 , . . . , xm ) be vectors in a Hilbert space. Define: H2 â—¦
S = {(hw, x1 i, . . . , hw, xm i) : kwk2 â‰¤ 1}. Then,
maxi kxi k2
âˆš
.
m

R(H2 â—¦ S) â‰¤

Proof Using Cauchy-Schwartz inequality we know that for any vectors w, v we
have hw, vi â‰¤ kwk kvk. Therefore,
"
#
m
X
mR(H2 â—¦ S) = E sup
Ïƒi ai
(26.15)
Ïƒ

"
=E

aâˆˆH2 â—¦S i=1
m
X

sup

Ïƒ

Ïƒi hw, xi i

w:kwkâ‰¤1 i=1

"
sup hw,

=E
Ïƒ

w:kwkâ‰¤1

"
â‰¤E k
Ïƒ

#

m
X

m
X

#
Ïƒi x i i

i=1

#
Ïƒi xi k2 .

i=1

Next, using Jensenâ€™s inequality we have that
ï£®ï£«
ï£¹ ï£« ï£®
 #
m
2 ï£¶1/2
m
2 ï£¹ï£¶1/2
" m
X

X





ï£¯ï£­
 ï£¸ ï£º ï£­ ï£°X

Ïƒi xi  ï£»ï£¸ (26.16)
.
E 
Ïƒi x i  = E ï£° 
Ïƒi x i 
ï£»â‰¤ E 
Ïƒ 
Ïƒ
Ïƒ 




i=1

2

i=1

2

i=1

2

26.3 Generalization Bounds for SVM

383

Finally, since the variables Ïƒ1 , . . . , Ïƒm are independent we have
ï£®
ï£¹
" m
#
X
X
Ïƒi Ïƒj hxi , xj iï£»
E k
Ïƒi xi k22 = E ï£°
Ïƒ

Ïƒ

i=1

=

=

i,j

X
i6=j
m
X

hxi , xj i E [Ïƒi Ïƒj ] +
Ïƒ

m
X
 
hxi , xi i E Ïƒi2
Ïƒ

i=1

kxi k22 â‰¤ m max kxi k22 .
i

i=1

Combining this with Equation (26.15) and Equation (26.16) we conclude our
proof.
Next we bound the Rademacher complexity of H1 â—¦ S.
Let S = (x1 , . . . , xm ) be vectors in Rn . Then,
r
2 log(2n)
R(H1 â—¦ S) â‰¤ max kxi kâˆž
.
i
m
Proof Using Holderâ€™s inequality we know that for any vectors w, v we have
hw, vi â‰¤ kwk1 kvkâˆž . Therefore,
"
#
m
X
mR(H1 â—¦ S) = E sup
Ïƒi a i
lemma 26.11

Ïƒ

"

aâˆˆH1 â—¦S i=1
m
X

sup

=E
Ïƒ

Ïƒi hw, xi i

w:kwk1 â‰¤1 i=1

"
=E

sup

Ïƒ

hw,

w:kwk1 â‰¤1

"
â‰¤E k
Ïƒ

#

m
X

m
X

#
Ïƒi xi i

i=1

#
Ïƒi xi kâˆž .

(26.17)

i=1

âˆš
For each j âˆˆ [n], let vj = (x1,j , . . . , xm,j ) âˆˆ Rm . Note that kvj k2 â‰¤ m maxi kxi kâˆž .
Let V = {v1 , . . . , vn , âˆ’v1 , . . . , âˆ’vn }. The right-hand side of Equation (26.17) is
m R(V ). Using Massart lemma (Lemma 26.8) we have that
p
R(V ) â‰¤ max kxi kâˆž 2 log(2n)/m,
i

which concludes our proof.

26.3

Generalization Bounds for SVM
In this section we use Rademacher complexity to derive generalization bounds
for generalized linear predictors with Euclidean norm constraint. We will show
how this leads to generalization bounds for hard-SVM and soft-SVM.

384

Rademacher Complexities

We shall consider the following general constraint-based formulation. Let H =
{w : kwk2 â‰¤ B} be our hypothesis class, and let Z = X Ã— Y be the examples
domain. Assume that the loss function ` : H Ã— Z â†’ R is of the form
`(w, (x, y)) = Ï†(hw, xi, y),

(26.18)

where Ï† : R Ã— Y â†’ R is such that for all y âˆˆ Y, the scalar function a 7â†’ Ï†(a, y)
is Ï-Lipschitz. For example, the hinge-loss function, `(w, (x, y)) = max{0, 1 âˆ’
yhw, xi}, can be written as in Equation (26.18) using Ï†(a, y) = max{0, 1 âˆ’
ya}, and note that Ï† is 1-Lipschitz for all y âˆˆ {Â±1}. Another example is the
absolute loss function, `(w, (x, y)) = |hw, xi âˆ’ y|, which can be written as in
Equation (26.18) using Ï†(a, y) = |a âˆ’ y|, which is also 1-Lipschitz for all y âˆˆ R.
The following theorem bounds the generalization error of all predictors in H
using their empirical error.
theorem 26.12 Suppose that D is a distribution over X Ã— Y such that with
probability 1 we have that kxk2 â‰¤ R. Let H = {w : kwk2 â‰¤ B} and let
` : H Ã— Z â†’ R be a loss function of the form given in Equation (26.18)
such that for all y âˆˆ Y, a 7â†’ Ï†(a, y) is a Ï-Lipschitz function and such that
maxaâˆˆ[âˆ’BR,BR] |Ï†(a, y)| â‰¤ c. Then, for any Î´ âˆˆ (0, 1), with probability of at least
1 âˆ’ Î´ over the choice of an i.i.d. sample of size m,
r
2 ln(2/Î´)
2ÏBR
.
+c
âˆ€w âˆˆ H, LD (w) â‰¤ LS (w) + âˆš
m
m
Proof Let F = {(x, y) 7â†’ Ï†(hw, xi, y) : w âˆˆ H}. We will show that with
âˆš
probability 1, R(F â—¦ S) â‰¤ ÏBR/ m and then the theorem will follow from
Theorem 26.5. Indeed, the set F â—¦ S can be written as
F â—¦ S = {(Ï†(hw, x1 i, y1 ), . . . , Ï†(hw, xm i, ym )) : w âˆˆ H},
and the bound on R(F â—¦S) follows directly by combining Lemma 26.9, Lemma 26.10,
and the assumption that kxk2 â‰¤ R with probability 1.
We next derive a generalization bound for hard-SVM based on the previous
theorem. For simplicity, we do not allow a bias term and consider the hard-SVM
problem:
argmin kwk2

s.t.

âˆ€i, yi hw, xi i â‰¥ 1

(26.19)

w

theorem 26.13 Consider a distribution D over X Ã—{Â±1} such that there exists
some vector w? with P(x,y)âˆ¼D [yhw? , xi â‰¥ 1] = 1 and such that kxk2 â‰¤ R with
probability 1. Let wS be the output of Equation (26.19). Then, with probability
of at least 1 âˆ’ Î´ over the choice of S âˆ¼ Dm , we have that
r
2 R kw? k
2 ln(2/Î´)
?
P [y 6= sign(hwS , xi)] â‰¤ âˆš
+ (1 + R kw k)
.
m
m
(x,y)âˆ¼D

26.3 Generalization Bounds for SVM

385

Proof Throughout the proof, let the loss function be the ramp loss (see Section 15.2.3). Note that the range of the ramp loss is [0, 1] and that it is a
1-Lipschitz function. Since the ramp loss upper bounds the zero-one loss, we
have that
P

(x,y)âˆ¼D

[y 6= sign(hwS , xi)] â‰¤ LD (wS ).

Let B = kw? k2 and consider the set H = {w : kwk2 â‰¤ B}. By the definition of
hard-SVM and our assumption on the distribution, we have that wS âˆˆ H with
probability 1 and that LS (wS ) = 0. Therefore, using Theorem 26.12 we have
that
r
2 ln(2/Î´)
2BR
.
LD (wS ) â‰¤ LS (wS ) + âˆš +
m
m

Remark 26.1 Theorem 26.13 implies that the sample complexity of hard-SVM
2
? 2
k
grows like R kw
. Using a more delicate analysis and the separability assump2
tion, it is possible to improve the bound to an order of

R2 kw? k2
.

?

The bound in the preceding theorem depends on kw k, which is unknown.
In the following we derive a bound that depends on the norm of the output of
SVM; hence it can be calculated from the training set itself. The proof is similar
to the derivation of bounds for structure risk minimization (SRM).
theorem 26.14 Assume that the conditions of Theorem 26.13 hold. Then,
with probability of at least 1 âˆ’ Î´ over the choice of S âˆ¼ Dm , we have that
s
S k)
ln( 4 log2 (kw
)
4RkwS k
Î´
+
.
P [y 6= sign(hwS , xi)] â‰¤ âˆš
m
m
(x,y)âˆ¼D
Proof For any integer i, let Bi = 2i , Hi = {w : kwk â‰¤ Bi }, and let Î´i = 2iÎ´2 .
Fix i, then using Theorem 26.12 we have that with probability of at least 1 âˆ’ Î´i
r
2Bi R
2 ln(2/Î´i )
âˆ€w âˆˆ Hi , LD (w) â‰¤ LS (w) + âˆš
+
m
m
Pâˆž
Applying the union bound and using i=1 Î´i â‰¤ Î´ we obtain that with probability
of at least 1 âˆ’ Î´ this holds for all i. Therefore, for all w, if we let i = dlog2 (kwk)e
2
2
then w âˆˆ Hi , Bi â‰¤ 2kwk, and Î´2i = (2i)
â‰¤ (4 log2 (kwk))
. Therefore,
Î´
Î´
r
2Bi R
2 ln(2/Î´i )
LD (w) â‰¤ LS (w) + âˆš
+
m
m
r
4kwkR
4(ln(4 log2 (kwk)) + ln(1/Î´))
â‰¤ LS (w) + âˆš
+
.
m
m
In particular, it holds for wS , which concludes our proof.

386

Rademacher Complexities

Remark 26.2 Note that all the bounds we have derived do not depend on the
dimension of w. This property is utilized when learning SVM with kernels, where
the dimension of w can be extremely large.

26.4

Generalization Bounds for Predictors with Low `1 Norm
In the previous section we derived generalization bounds for linear predictors
with an `2 -norm constraint. In this section we consider the following general `1 norm constraint formulation. Let H = {w : kwk1 â‰¤ B} be our hypothesis class,
and let Z = X Ã— Y be the examples domain. Assume that the loss function,
` : H Ã— Z â†’ R, is of the same form as in Equation (26.18), with Ï† : R Ã— Y â†’ R
being Ï-Lipschitz w.r.t. its first argument. The following theorem bounds the
generalization error of all predictors in H using their empirical error.
theorem 26.15 Suppose that D is a distribution over X Ã— Y such that with
probability 1 we have that kxkâˆž â‰¤ R. Let H = {w âˆˆ Rd : kwk1 â‰¤ B} and
let ` : H Ã— Z â†’ R be a loss function of the form given in Equation (26.18)
such that for all y âˆˆ Y, a 7â†’ Ï†(a, y) is an Ï-Lipschitz function and such that
maxaâˆˆ[âˆ’BR,BR] |Ï†(a, y)| â‰¤ c. Then, for any Î´ âˆˆ (0, 1), with probability of at least
1 âˆ’ Î´ over the choice of an i.i.d. sample of size m,
r
r
2 log(2d)
2 ln(2/Î´)
+c
.
âˆ€w âˆˆ H, LD (w) â‰¤ LS (w) + 2ÏBR
m
m
Proof The proof is identical to the proof of Theorem 26.12, while relying on
Lemma 26.11 instead of relying on Lemma 26.10.
It is interesting to compare the two bounds given in Theorem 26.12 and Theorem 26.15. Apart from the extra log(d) factor that appears in Theorem 26.15,
both bounds look similar. However, the parameters B, R have different meanings
in the two bounds. In Theorem 26.12, the parameter B imposes an `2 constraint
on w and the parameter R captures a low `2 -norm assumption on the instances.
In contrast, in Theorem 26.15 the parameter B imposes an `1 constraint on w
(which is stronger than an `2 constraint) while the parameter R captures a low
`âˆž -norm assumption on the instance (which is weaker than a low `2 -norm assumption). Therefore, the choice of the constraint should depend on our prior
knowledge of the set of instances and on prior assumptions on good predictors.

26.5

Bibliographic Remarks
The use of Rademacher complexity for bounding the uniform convergence is
due to (Koltchinskii & Panchenko 2000, Bartlett & Mendelson 2001, Bartlett
& Mendelson 2002). For additional reading see, for example, (Bousquet 2002,
Boucheron, Bousquet & Lugosi 2005, Bartlett, Bousquet & Mendelson 2005).

26.5 Bibliographic Remarks

387

Our proof of the concentration lemma is due to Kakade and Tewari lecture
notes. Kakade, Sridharan & Tewari (2008) gave a unified framework for deriving
bounds on the Rademacher complexity of linear classes with respect to different
assumptions on the norms.

27 Covering Numbers

In this chapter we describe another way to measure the complexity of sets, which
is called covering numbers.

27.1

Covering
definition 27.1 (Covering) Let A âŠ‚ Rm be a set of vectors. We say that A
is r-covered by a set A0 , with respect to the Euclidean metric, if for all a âˆˆ A
there exists a0 âˆˆ A0 with ka âˆ’ a0 k â‰¤ r. We define by N (r, A) the cardinality of
the smallest A0 that r-covers A.
Example 27.1 (Subspace) Suppose that A âŠ‚ Rm , let c = maxaâˆˆA kak, âˆš
and assume that A lies in a d-dimensional subspace of Rm . Then, N (r, A) â‰¤ (2c d/r)d .
To see this, let v1 , . . . , vd be an orthonormal basis of the subspace. Then, any
Pd
a âˆˆ A can be written as a = i=1 Î±i vi with kÎ±kâˆž â‰¤ kÎ±k2 = kak2 â‰¤ c. Let
 âˆˆ R and consider the set
( d
)
X
0
0
0
A =
Î±i vi : âˆ€i, Î±i âˆˆ {âˆ’c, âˆ’c + , âˆ’c + 2, . . . , c} .
i=1

Pd

Î±i vi with kÎ±kâˆž â‰¤ c, there exists a0 âˆˆ A0 such that
X
X
ka âˆ’ a0 k2 = k
(Î±i0 âˆ’ Î±i )vi k2 â‰¤ 2
kvi k2 â‰¤ 2 d.

Given a âˆˆ A s.t. a =

i=1

i

i

âˆš
Choose  = r/ d; then ka âˆ’ a0 k â‰¤ r and therefore A0 is an r-cover of A. Hence,
âˆš !d
 d
2c
2c d
0
N (r, A) â‰¤ |A | =
=
.

r

27.1.1

Properties
The following lemma is immediate from the definition.
lemma 27.2

For any A âŠ‚ Rm , scalar c > 0, and vector a0 âˆˆ Rm , we have
âˆ€r > 0, N (r, {c a + a0 : a âˆˆ A}) â‰¤ N (cr, A).

c 2014 by Shai Shalev-Shwartz and Shai Ben-David
Understanding Machine Learning, 
Published 2014 by Cambridge University Press.
Personal use only. Not for distribution. Do not post.
Please link to http://www.cs.huji.ac.il/~shais/UnderstandingMachineLearning

27.2 From Covering to Rademacher Complexity via Chaining

389

Next, we derive a contraction principle.
lemma 27.3 For each i âˆˆ [m], let Ï†i : R â†’ R be a Ï-Lipschitz function;
namely, for all Î±, Î² âˆˆ R we have |Ï†i (Î±) âˆ’ Ï†i (Î²)| â‰¤ Ï |Î± âˆ’ Î²|. For a âˆˆ Rm let
Ï†(a) denote the vector (Ï†1 (a1 ), . . . , Ï†m (am )). Let Ï† â—¦ A = {Ï†(a) : a âˆˆ A}. Then,
N (Ï r, Ï† â—¦ A) â‰¤ N (r, A).
Proof Define B = Ï† â—¦ A. Let A0 be an r-cover of A and define B 0 = Ï† â—¦ A0 .
Then, for all a âˆˆ A there exists a0 âˆˆ A0 with ka âˆ’ a0 k â‰¤ r. So,
kÏ†(a) âˆ’ Ï†(a0 )k2 =

X

(Ï†i (ai ) âˆ’ Ï†i (a0i ))2 â‰¤ Ï2

i

X
(ai âˆ’ a0i )2 â‰¤ (Ïr)2 .
i

Hence, B 0 is an (Ï r)-cover of B.

27.2

From Covering to Rademacher Complexity via Chaining
The following lemma bounds the Rademacher complexity of A based on the
covering numbers N (r, A). This technique is called Chaining and is attributed
to Dudley.
lemma 27.4

Let c = minaÌ„ maxaâˆˆA ka âˆ’ aÌ„k. Then, for any integer M > 0,
M
q
6 c X âˆ’k
c 2âˆ’M
+
log(N (c 2âˆ’k , A)).
R(A) â‰¤ âˆš
2
m
m
k=1

Proof Let aÌ„ be a minimizer of the objective function given in the definition
of c. On the basis of Lemma 26.6, we can analyze the Rademacher complexity
assuming that aÌ„ = 0.
Consider the set B0 = {0} and note that it is a c-cover of A. Let B1 , . . . , BM
be sets such that each Bk corresponds to a minimal (c 2âˆ’k )-cover of A. Let
aâˆ— = argmaxaâˆˆA hÏƒ, ai (where if there is more than one maximizer, choose one
in an arbitrary way, and if a maximizer does not exist, choose aâˆ— such that
hÏƒ, aâˆ— i is close enough to the supremum). Note that aâˆ— is a function of Ïƒ. For
each k, let b(k) be the nearest neighbor of aâˆ— in Bk (hence b(k) is also a function
of Ïƒ). Using the triangle inequality,
kb(k) âˆ’ b(kâˆ’1) k â‰¤ kb(k) âˆ’ aâˆ— k + kaâˆ— âˆ’ b(kâˆ’1) k â‰¤ c (2âˆ’k + 2âˆ’(kâˆ’1) ) = 3 c 2âˆ’k .
For each k define the set
BÌ‚k = {(a âˆ’ a0 ) : a âˆˆ Bk , a0 âˆˆ Bkâˆ’1 , ka âˆ’ a0 k â‰¤ 3 c 2âˆ’k }.

390

Covering Numbers

We can now write
1
EhÏƒ, aâˆ— i
m
"
#
M
X
1
âˆ—
(M )
(k)
(kâˆ’1)
=
E hÏƒ, a âˆ’ b
i+
hÏƒ, b âˆ’ b
i
m
k=1
"
#
M
i X
1 h
1
âˆ—
(M )
E kÏƒk ka âˆ’ b
k +
E sup hÏƒ, ai .
â‰¤
m
m
aâˆˆBÌ‚k

R(A) =

k=1

âˆš

Since kÏƒk = m and kaâˆ— âˆ’ b(M ) k â‰¤ c 2âˆ’M , the first summand is at most
âˆšc 2âˆ’M . Additionally, by Massart lemma,
m
p
p
2 log(N (c 2âˆ’k , A)2 )
log(N (c 2âˆ’k , A))
1
âˆ’k
âˆ’k
E sup hÏƒ, ai â‰¤ 3 c 2
= 6c2
.
m aâˆˆBÌ‚k
m
m
Therefore,
M

c 2âˆ’M
6c X âˆ’k
2
R(A) â‰¤ âˆš
+
m
m

q

log(N (c2âˆ’k , A)).

k=1

As a corollary we obtain the following:
lemma 27.5

Assume that there are Î±, Î² > 0 such that for any k â‰¥ 1 we have
q
log(N (c2âˆ’k , A)) â‰¤ Î± + Î²k.

Then,
6c
(Î± + 2Î²) .
m
Proof The bound follows from Lemma 27.4 by taking M â†’ âˆž and noting that
Pâˆž âˆ’k
Pâˆž
= 1 and k=1 k2âˆ’k = 2.
k=1 2
R(A) â‰¤

Consider a set A which lies in a d dimensional subspace of Rm
 âˆš d
and such that c = maxaâˆˆA kak. We have shown that N (r, A) â‰¤ 2cr d . Therefore, for any k,
r
q

âˆš 
âˆ’k
log(N (c2 , A)) â‰¤ d log 2k+1 d
q
âˆš
âˆš
â‰¤ d log(2 d) + k d
q
âˆš
âˆš
â‰¤ d log(2 d) + d k.
Example 27.2

Hence Lemma 27.5 yields
q

âˆš
âˆš
6c
R(A) â‰¤
d log(2 d) + 2 d
= O
m

c

p

d log(d)
m

!
.

27.3 Bibliographic Remarks

27.3

391

Bibliographic Remarks
The chaining technique is due to Dudley (1987). For an extensive study of covering numbers as well as other complexity measures that can be used to bound the
rate of uniform convergence we refer the reader to (Anthony & Bartlet 1999).

28 Proof of the Fundamental Theorem
of Learning Theory

In this chapter we prove Theorem 6.8 from Chapter 6. We remind the reader
the conditions of the theorem, which will hold throughout this chapter: H is a
hypothesis class of functions from a domain X to {0, 1}, the loss function is the
0 âˆ’ 1 loss, and VCdim(H) = d < âˆž.
We shall prove the upper bound for both the realizable and agnostic cases
and shall prove the lower bound for the agnostic case. The lower bound for the
realizable case is left as an exercise.

28.1

The Upper Bound for the Agnostic Case
For the upper bound we need to prove that there exists C such that H is agnostic
PAC learnable with sample complexity
mH (, Î´) â‰¤ C

d + ln(1/Î´)
.
2

We will prove the slightly looser bound:
d log(d/) + ln(1/Î´)
.
(28.1)
2
The tighter bound in the theorem statement requires a more involved proof, in
which a more careful analysis of the Rademacher complexity using a technique
called â€œchainingâ€ should be used. This is beyond the scope of this book.
To prove Equation (28.1), it suffices to show that applying the ERM with a
sample size


8
32d
64d
+ 2 Â· (8d log(e/d) + 2 log(4/Î´))
m â‰¥ 4 2 Â· log
2



mH (, Î´) â‰¤ C

yields an , Î´-learner for H. We prove this result on the basis of Theorem 26.5.
Let (x1 , y1 ), . . . , (xm , ym ) be a classification training set. Recall that the SauerShelah lemma tells us that if VCdim(H) = d then
 e m d
|{(h(x1 ), . . . , h(xm )) : h âˆˆ H}| â‰¤
.
d
Denote A = {(1[h(x1 )6=y1 ] , . . . , 1[h(xm )6=ym ] ) : h âˆˆ H}. This clearly implies that
 e m d
|A| â‰¤
.
d
c 2014 by Shai Shalev-Shwartz and Shai Ben-David
Understanding Machine Learning, 
Published 2014 by Cambridge University Press.
Personal use only. Not for distribution. Do not post.
Please link to http://www.cs.huji.ac.il/~shais/UnderstandingMachineLearning

28.2 The Lower Bound for the Agnostic Case

393

Combining this with Lemma 26.8 we obtain the following bound on the Rademacher
complexity:
r
2d log(em/d)
R(A) â‰¤
.
m
Using Theorem 26.5 we obtain that with probability of at least 1 âˆ’ Î´, for every
h âˆˆ H we have that
r
r
8d log(em/d)
2 log(2/Î´)
LD (h) âˆ’ LS (h) â‰¤
+
.
m
m
Repeating the previous argument for minus the zero-one loss and applying the
union bound we obtain that with probability of at least 1 âˆ’ Î´, for every h âˆˆ H
it holds that
r
r
8d log(em/d)
2 log(4/Î´)
+
|LD (h) âˆ’ LS (h)| â‰¤
m
m
r
8d log(em/d) + 2 log(4/Î´)
â‰¤2
.
m
To ensure that this is smaller than  we need
mâ‰¥

4
Â· (8d log(m) + 8d log(e/d) + 2 log(4/Î´)) .
2

Using Lemma A.2, a sufficient condition for the inequality to hold is that


32d
64d
8
m â‰¥ 4 2 Â· log
+ 2 Â· (8d log(e/d) + 2 log(4/Î´)) .

2


28.2

The Lower Bound for the Agnostic Case
Here, we prove that there exists C such that H is agnostic PAC learnable with
sample complexity
mH (, Î´) â‰¥ C

d + ln(1/Î´)
.
2

We will prove the lower bound in two parts. First, we will show that m(, Î´) â‰¥
0.5 log(1/(4Î´))/2 , and second we will show that for every Î´ â‰¤ 1/8 we have that
m(, Î´) â‰¥ 8d/2 . These two bounds will conclude the proof.

28.2.1

Showing That m(, Î´) â‰¥ 0.5 log(1/(4Î´))/2
âˆš
We first show that for any  < 1/ 2 and any Î´ âˆˆ (0, 1), we have that m(, Î´) â‰¥
0.5 log(1/(4Î´))/2 . To do so, we show that for m â‰¤ 0.5 log(1/(4Î´))/2 , H is not
learnable.
Choose one example that is shattered by H. That is, let c be an example such

394

Proof of the Fundamental Theorem of Learning Theory

that there are h+ , hâˆ’ âˆˆ H for which h+ (c) = 1 and hâˆ’ (c) = âˆ’1. Define two
distributions, D+ and Dâˆ’ , such that for b âˆˆ {Â±1} we have

(
Db ({(x, y)}) =

1+yb
2

if x = c

0

otherwise.

That is, all the distribution mass is concentrated on two examples (c, 1) and
(c, âˆ’1), where the probability of (c, b) is 1+b
and the probability of (c, âˆ’b) is
2
1âˆ’b
.
2
Let A be an arbitrary algorithm. Any training set sampled from Db has the
form S = (c, y1 ), . . . , (c, ym ). Therefore, it is fully characterized by the vector
y = (y1 , . . . , ym ) âˆˆ {Â±1}m . Upon receiving a training set S, the algorithm A
returns a hypothesis h : X â†’ {Â±1}. Since the error of A w.r.t. Db only depends
on h(c), we can think of A as a mapping from {Â±1}m into {Â±1}. Therefore,
we denote by A(y) the value in {Â±1} corresponding to the prediction of h(c),
where h is the hypothesis that A outputs upon receiving the training set S =
(c, y1 ), . . . , (c, ym ).
Note that for any hypothesis h we have

LDb (h) =

1 âˆ’ h(c)b
.
2

In particular, the Bayes optimal hypothesis is hb and

1 âˆ’ A(y)b 1 âˆ’ 
LDb (A(y)) âˆ’ LDb (hb ) =
âˆ’
=
2
2

(

0

if A(y) 6= b
otherwise.

Fix A. For b âˆˆ {Â±1}, let Y b = {y âˆˆ {0, 1}m : A(y) 6= b}. The distribution Db
induces a probability Pb over {Â±1}m . Hence,

P [LDb (A(y)) âˆ’ LDb (hb ) = ] = Db (Y b ) =

X

Pb [y]1[A(y)6=b] .

y

Denote N + = {y : |{i : yi = 1}| â‰¥ m/2} and N âˆ’ = {Â±1}m \ N + . Note that for
any y âˆˆ N + we have P+ [y] â‰¥ Pâˆ’ [y] and for any y âˆˆ N âˆ’ we have Pâˆ’ [y] â‰¥ P+ [y].

28.2 The Lower Bound for the Agnostic Case

395

Therefore,
max P [LDb (A(y)) âˆ’ LDb (hb ) = ]
X
= max
Pb [y]1[A(y)6=b]

bâˆˆ{Â±1}

bâˆˆ{Â±1}

y

1X
1X
â‰¥
P+ [y]1[A(y)6=+] +
Pâˆ’ [y]1[A(y)6=âˆ’]
2 y
2 y
1 X
1 X
(P+ [y]1[A(y)6=+] + Pâˆ’ [y]1[A(y)6=âˆ’] ) +
(P+ [y]1[A(y)6=+] + Pâˆ’ [y]1[A(y)6=âˆ’] )
=
2
2
+
âˆ’
yâˆˆN

yâˆˆN

1 X
1 X
â‰¥
(Pâˆ’ [y]1[A(y)6=+] + Pâˆ’ [y]1[A(y)6=âˆ’] ) +
(P+ [y]1[A(y)6=+] + P+ [y]1[A(y)6=âˆ’] )
2
2
+
âˆ’
yâˆˆN

yâˆˆN

1 X
1 X
=
Pâˆ’ [y] +
P+ [y] .
2
2
+
âˆ’
yâˆˆN

yâˆˆN

P

P
Next note that yâˆˆN + Pâˆ’ [y] = yâˆˆN âˆ’ P+ [y], and both values are the probability that a Binomial (m, (1 âˆ’ )/2) random variable will have value greater
than m/2. Using Lemma B.11, this probability is lower bounded by


p
p
1
1
1 âˆ’ 1 âˆ’ exp(âˆ’m2 /(1 âˆ’ 2 )) â‰¥
1 âˆ’ 1 âˆ’ exp(âˆ’2m2 ) ,
2
2
where we used the assumption that 2 â‰¤ 1/2. It follows that if m â‰¤ 0.5 log(1/(4Î´))/2
then there exists b such that
P [LDb (A(y)) âˆ’ LDb (hb ) = ]


q
âˆš
1
â‰¥
1 âˆ’ 1 âˆ’ 4Î´ â‰¥ Î´,
2
where the last inequality follows by standard algebraic manipulations. This concludes our proof.

28.2.2

Showing That m(, 1/8) â‰¥ 8d/2
âˆš
We shall now prove that for every  <âˆš
1/(8 2) we have that m(, Î´) â‰¥ 8d
2 .
Let Ï = 8 and note that Ï âˆˆ (0, 1/ 2). We will construct a family of distributions as follows. First, let C = {c1 , . . . , cd } be a set of d instances which are
shattered by H. Second, for each vector (b1 , . . . , bd ) âˆˆ {Â±1}d , define a distribution Db such that
(
1 1+ybi Ï
Â· 2
if âˆƒi : x = ci
Db ({(x, y)}) = d
0
otherwise.
That is, to sample an example according to Db , we first sample an element ci âˆˆ C
uniformly at random, and then set the label to be bi with probability (1 + Ï)/2
or âˆ’bi with probability (1 âˆ’ Ï)/2.
It is easy to verify that the Bayes optimal predictor for Db is the hypothesis

396

Proof of the Fundamental Theorem of Learning Theory

h âˆˆ H such that h(ci ) = bi for all i âˆˆ [d], and its error is
any other function f : X â†’ {Â±1}, it is easy to verify that
LDb (f ) =

1âˆ’Ï
2 .

In addition, for

1 + Ï |{i âˆˆ [d] : f (ci ) 6= bi }| 1 âˆ’ Ï |{i âˆˆ [d] : f (ci ) = bi }|
Â·
+
Â·
.
2
d
2
d

Therefore,
LDb (f ) âˆ’ min LDb (h) = Ï Â·
hâˆˆH

|{i âˆˆ [d] : f (ci ) 6= bi }|
.
d

(28.2)

Next, fix some learning algorithm A. As in the proof of the No-Free-Lunch
theorem, we have that


max
E m LDb (A(S)) âˆ’ min LDb (h)
(28.3)
hâˆˆH
Db :bâˆˆ{Â±1}d Sâˆ¼Db


â‰¥
E
E m LDb (A(S)) âˆ’ min LDb (h)
(28.4)
hâˆˆH
Db :bâˆ¼U ({Â±1}d ) Sâˆ¼Db


|{i âˆˆ [d] : A(S)(ci ) 6= bi |
=
E
Em Ï Â·
(28.5)
d
Db :bâˆ¼U ({Â±1}d ) Sâˆ¼Db
d

=

ÏX
E
E 1[A(S)(ci )6=bi ] ,
d i=1 Db :bâˆ¼U ({Â±1}d ) Sâˆ¼Dbm

(28.6)

where the first equality follows from Equation (28.2). In addition, using the
definition of Db , to sample S âˆ¼ Db we can first sample (j1 , . . . , jm ) âˆ¼ U ([d])m , set
xr = cji , and finally sample yr such that P[yr = bji ] = (1 + Ï)/2. Let us simplify
the notation and use y âˆ¼ b to denote sampling according to P[y = b] = (1 + Ï)/2.
Therefore, the right-hand side of Equation (28.6) equals
d

ÏX
E
E
E
1[A(S)(ci )6=bi ] .
d i=1 jâˆ¼U ([d])m bâˆ¼U ({Â±1}d ) âˆ€r,yr âˆ¼bjr

(28.7)

We now proceed in two steps. First, we show that among all learning algorithms,
A, the one which minimizes Equation (28.7) (and hence also Equation (28.4))
is the Maximum-Likelihood learning rule, denoted AM L . Formally, for each i,
AM L (S)(ci ) is the majority vote among the set {yr : r âˆˆ [m], xr = ci }. Second,
we lower bound Equation (28.7) for AM L .
lemma 28.1 Among all algorithms, Equation (28.4) is minimized for A being
the Maximum-Likelihood algorithm, AM L , defined as
!
X
âˆ€i, AM L (S)(ci ) = sign
yr .
r:xr =ci

Proof Fix some j âˆˆ [d]m . Note that given j and y âˆˆ {Â±1}m , the training set
S is fully determined. Therefore, we can write A(j, y) instead of A(S). Let us
also fix i âˆˆ [d]. Denote bÂ¬i the sequence (b1 , . . . , biâˆ’1 , bi+1 , . . . , bm ). Also, for any

28.2 The Lower Bound for the Agnostic Case

397

y âˆˆ {Â±1}m , let y I denote the elements of y corresponding to indices for which
jr = i and let y Â¬I be the rest of the elements of y. We have
E

1[A(S)(ci )6=bi ]

E

bâˆ¼U ({Â±1}d ) âˆ€r,yr âˆ¼bjr

=

=

1
2

X

X

E

bi âˆˆ{Â±1}

bÂ¬i âˆ¼U ({Â±1}dâˆ’1 )

X

E

bÂ¬i âˆ¼U ({Â±1}dâˆ’1 )

y Â¬I

P [y|bÂ¬i , bi ]1[A(j,y)(ci )6=bi ]

y

ï£«
ï£¶
X
X
1
ï£­
P [y Â¬I |bÂ¬i ]
P [y I |bi ]1[A(j,y)(ci )6=bi ] ï£¸ .
2 I
y

bi âˆˆ{Â±1}

The sum within the parentheses is minimized when A(j, y)(ci ) is the maximizer
of P [y I |bi ] over bi âˆˆ {Â±1}, which is exactly the Maximum-Likelihood rule. Repeating the same argument for all i we conclude our proof.
Fix i. For every j, let ni (j) = {|t : jt = i|} be the number of instances in which
the instance is ci . For the Maximum-Likelihood rule, we have that the quantity
E

E

bâˆ¼U ({Â±1}d ) âˆ€r,yr âˆ¼bjr

1[AM L (S)(ci )6=bi ]

is exactly the probability that a binomial (ni (j), (1 âˆ’ Ï)/2) random variable will
be larger than ni (j)/2. Using Lemma B.11, and the assumption Ï2 â‰¤ 1/2, we
have that

p
1
P [B â‰¥ ni (j)/2] â‰¥
1 âˆ’ 1 âˆ’ eâˆ’2ni (j)Ï2 .
2
We have thus shown that
d

ÏX
E
E
1[A(S)(ci )6=bi ]
E
d i=1 jâˆ¼U ([d])m bâˆ¼U ({Â±1}d ) âˆ€r,yr âˆ¼bjr
d

â‰¥



p
Ï X
E m 1 âˆ’ 1 âˆ’ eâˆ’2Ï2 ni (j)
2d i=1 jâˆ¼U ([d])

d


p
Ï X
â‰¥
E m 1 âˆ’ 2Ï2 ni (j) ,
2d i=1 jâˆ¼U ([d])

where in the last inequality we used the inequality 1 âˆ’ eâˆ’a â‰¤ a.
Since the square root function is concave, we can apply Jensenâ€™s inequality to
obtain that the above is lower bounded by
!
d
r
Ï X
â‰¥
1 âˆ’ 2Ï2
E
ni (j)
2d i=1
jâˆ¼U ([d])m
d


p
Ï X
1 âˆ’ 2Ï2 m/d
2d i=1

p
Ï
=
1 âˆ’ 2Ï2 m/d .
2

=

398

Proof of the Fundamental Theorem of Learning Theory

As long as m < 8Ïd2 , this term would be larger than Ï/4.
In summary, we have shown that if m < 8Ïd2 then for any algorithm there
exists a distribution such that


E m LD (A(S)) âˆ’ min LD (h) â‰¥ Ï/4.
Sâˆ¼D

hâˆˆH

Finally, Let âˆ† = Ï1 (LD (A(S)) âˆ’ minhâˆˆH LD (h)) and note that âˆ† âˆˆ [0, 1] (see
Equation (28.5)). Therefore, using Lemma B.1, we get that




P[LD (A(S)) âˆ’ min LD (h) > ] = P âˆ† >
â‰¥ E[âˆ†] âˆ’
hâˆˆH
Ï
Ï
1

â‰¥ âˆ’ .
4 Ï
Choosing Ï = 8 we conclude that if m < 512d 2 , then with probability of at least
1/8 we will have LD (A(S)) âˆ’ minhâˆˆH LD (h) â‰¥ .

28.3

The Upper Bound for the Realizable Case
Here we prove that there exists C such that H is PAC learnable with sample
complexity
mH (, Î´) â‰¤ C

d ln(1/) + ln(1/Î´)
.


We do so by showing that for m â‰¥ C d ln(1/)+ln(1/Î´)
, H is learnable using the

ERM rule. We prove this claim based on the notion of -nets.
definition 28.2 (-net) Let X be a domain. S âŠ‚ X is an -net for H âŠ‚ 2X
with respect to a distribution D over X if
âˆ€h âˆˆ H : D(h) â‰¥  â‡’ h âˆ© S 6= âˆ….
theorem 28.3
and let

Let H âŠ‚ 2X with VCdim(H) = d. Fix  âˆˆ (0, 1), Î´ âˆˆ (0, 1/4)
8
mâ‰¥





2d log

16e




 
2
+ log
.
Î´

Then, with probability of at least 1 âˆ’ Î´ over a choice of S âˆ¼ Dm we have that S
is an -net for H.
Proof

Let
B = {S âŠ‚ X : |S| = m, âˆƒh âˆˆ H, D(h) â‰¥ , h âˆ© S = âˆ…}

be the set of sets which are not -nets. We need to bound P[S âˆˆ B]. Define
B 0 = {(S, T ) âŠ‚ X : |S| = |T | = m, âˆƒh âˆˆ H, D(h) â‰¥ , h âˆ© S = âˆ…, |T âˆ© h| >

m
2 }.

28.3 The Upper Bound for the Realizable Case

399

Claim 1
P[S âˆˆ B] â‰¤ 2 P[(S, T ) âˆˆ B 0 ].
Proof of Claim 1 : Since S and T are chosen independently we can write
h



i
P[(S, T ) âˆˆ B 0 ] =
E 2m 1[(S,T )âˆˆB 0 ] = E m
E m 1[(S,T )âˆˆB 0 ] .
Sâˆ¼D

(S,T )âˆ¼D

T âˆ¼D

Note that (S, T ) âˆˆ B 0 implies S âˆˆ B and therefore 1[(S,T )âˆˆB 0 ] = 1[(S,T )âˆˆB 0 ] 1[SâˆˆB] ,
which gives
P[(S, T ) âˆˆ B 0 ] =
=

E

E

E

1[SâˆˆB]

Sâˆ¼D m T âˆ¼D m
Sâˆ¼D m

1[(S,T )âˆˆB 0 ] 1[SâˆˆB]
E

T âˆ¼D m

1[(S,T )âˆˆB 0 ] .

Fix some S. Then, either 1[SâˆˆB] = 0 or S âˆˆ B and then âˆƒhS such that D(hS ) â‰¥ 
and |hS âˆ© S| = 0. It follows that a sufficient condition for (S, T ) âˆˆ B 0 is that
|T âˆ© hS | > m
2 . Therefore, whenever S âˆˆ B we have
E

T âˆ¼D m

1[(S,T )âˆˆB 0 ] â‰¥

P [|T âˆ© hS | >

T âˆ¼D m

m
2 ].

But, since we now assume S âˆˆ B we know that D(hS ) = Ï â‰¥ . Therefore,
|T âˆ© hS | is a binomial random variable with parameters Ï (probability of success
for a single try) and m (number of tries). Chernoffâ€™s inequality implies
P[|T âˆ©hS | â‰¤

Ïm
2 ]

â‰¤ e

2
âˆ’ mÏ (mÏâˆ’mÏ/2)2

= eâˆ’mÏ/2 â‰¤ eâˆ’m/2 â‰¤ eâˆ’d log(1/Î´)/2 = Î´ d/2 â‰¤ 1/2.

Thus,
P[|T âˆ© hS | >

m
2 ]

= 1 âˆ’ P[|T âˆ© hS | â‰¤

m
2 ]

â‰¥ 1 âˆ’ P[|T âˆ© hS | â‰¤

Ïm
2 ]

â‰¥ 1/2.

Combining all the preceding we conclude the proof of Claim 1.

Claim 2 (Symmetrization):
P[(S, T ) âˆˆ B 0 ] â‰¤ eâˆ’m/4 Ï„H (2m).
Proof of Claim 2 : To simplify notation, let Î± = m/2 and for a sequence A =
(x1 , . . . , x2m ) let A0 = (x1 , . . . , xm ). Using the definition of B 0 we get that
P[A âˆˆ B 0 ] =
â‰¤

E

max 1[D(h)â‰¥] 1[|hâˆ©A0 |=0] 1[|hâˆ©A|â‰¥Î±]

E

max 1[|hâˆ©A0 |=0] 1[|hâˆ©A|â‰¥Î±] .

Aâˆ¼D 2m hâˆˆH
Aâˆ¼D 2m hâˆˆH

Now, let us define by HA the effective number of different hypotheses on A,
namely, HA = {h âˆ© A : h âˆˆ H }. It follows that
P[A âˆˆ B 0 ] â‰¤
â‰¤

E

max 1[|hâˆ©A0 |=0] 1[|hâˆ©A|â‰¥Î±]
X
1[|hâˆ©A0 |=0] 1[|hâˆ©A|â‰¥Î±] .

Aâˆ¼D 2m hâˆˆHA

E

Aâˆ¼D 2m

hâˆˆHA

Let J = {j âŠ‚ [2m] : |j| = m}. For any j âˆˆ J and A = (x1 , . . . , x2m ) define
Aj = (xj1 , . . . , xjm ). Since the elements of A are chosen i.i.d., we have that
for any j âˆˆ J and any function f (A, A0 ) it holds that EAâˆ¼D2m [f (A, A0 )] =

400

Proof of the Fundamental Theorem of Learning Theory

EAâˆ¼D2m [f (A, Aj )]. Since this holds for any j it also holds for the expectation of
j chosen at random from J. In particular, it holds for the function f (A, A0 ) =
P
hâˆˆHA 1[|hâˆ©A0 |=0] 1[|hâˆ©A|â‰¥Î±] . We therefore obtain that
P[A âˆˆ B 0 ] â‰¤

X

E 2m E

jâˆ¼J

Aâˆ¼D

=

E 2m

Aâˆ¼D

1[|hâˆ©Aj |=0] 1[|hâˆ©A|â‰¥Î±]

hâˆˆHA

X
hâˆˆHA

1[|hâˆ©A|â‰¥Î±] E 1[|hâˆ©Aj |=0] .
jâˆ¼J

Now, fix some A s.t. |h âˆ© A| â‰¥ Î±. Then, Ej 1[|hâˆ©Aj |=0] is the probability that
when choosing m balls from a bag with at least Î± red balls, we will never choose
a red ball. This probability is at most
(1 âˆ’ Î±/(2m))m = (1 âˆ’ /4)m â‰¤ eâˆ’m/4 .
We therefore get that
P[A âˆˆ B 0 ] â‰¤

E 2m

Aâˆ¼D

X

eâˆ’m/4 â‰¤ eâˆ’m/4

hâˆˆHA

E

Aâˆ¼D 2m

|HA |.

Using the definition of the growth function we conclude the proof of Claim 2.
Completing the Proof: By Sauerâ€™s lemma we know that Ï„H (2m) â‰¤ (2em/d)d .
Combining this with the two claims we obtain that
P[S âˆˆ B] â‰¤ 2(2em/d)d eâˆ’m/4 .
We would like the right-hand side of the inequality to be at most Î´; that is,
2(2em/d)d eâˆ’m/4 â‰¤ Î´.
Rearranging, we obtain the requirement
mâ‰¥

4
4d
4
(d log(2em/d) + log(2/Î´)) =
log(m) + (d log(2e/d) + log(2/Î´).




Using Lemma A.2, a sufficient condition for the preceding to hold is that
 
16d
8d
8
mâ‰¥
log
+ (d log(2e/d) + log(2/Î´).



A sufficient condition for this is that
 
16d
8d
16
mâ‰¥
log
+ (d log(2e/d) +



 

16d
8d 2e
8
=
log
+ log(2/Î´)

d




 
8
16e
2
=
2d log
+ log
.


Î´
and this concludes our proof.

1
2

log(2/Î´)

28.3 The Upper Bound for the Realizable Case

28.3.1

401

From -Nets to PAC Learnability
theorem 28.4 Let H be a hypothesis class over X with VCdim(H) = d. Let
D be a distribution over X and let c âˆˆ H be a target hypothesis. Fix , Î´ âˆˆ (0, 1)
and let m be as defined in Theorem 28.3. Then, with probability of at least 1 âˆ’ Î´
over a choice of m i.i.d. instances from X with labels according to c we have that
any ERM hypothesis has a true error of at most .
a
a
Proof Define the class Hc = {c h : h âˆˆ H}, where c h = (h \ c) âˆª (c \ h). It is
easy to verify that if some A âŠ‚ X is shattered by H then it is also shattered by Hc
and vice versa. Hence, VCdim(H) = VCdim(Hc ). Therefore, using Theorem 28.3
we know that with probability of at least 1 âˆ’ Î´, the sample S is an -net for Hc .
a
Note that LD (h) = D(h c). Therefore, for any h âˆˆ H with LD (h) â‰¥  we have
a
that |(h c) âˆ© S| > 0, which implies that h cannot be an ERM hypothesis, which
concludes our proof.

29 Multiclass Learnability

In Chapter 17 we have introduced the problem of multiclass categorization, in
which the goal is to learn a predictor h : X â†’ [k]. In this chapter we address PAC
learnability of multiclass predictors with respect to the 0-1 loss. As in Chapter 6,
the main goal of this chapter is to:
â€¢ Characterize which classes of multiclass hypotheses are learnable in the (multiclass) PAC model.
â€¢ Quantify the sample complexity of such hypothesis classes.
In view of the fundamental theorem of learning theory (Theorem 6.8), it is natural to seek a generalization of the VC dimension to multiclass hypothesis classes.
In Section 29.1 we show such a generalization, called the Natarajan dimension,
and state a generalization of the fundamental theorem based on the Natarajan
dimension. Then, we demonstrate how to calculate the Natarajan dimension of
several important hypothesis classes.
Recall that the main message of the fundamental theorem of learning theory
is that a hypothesis class of binary classifiers is learnable (with respect to the
0-1 loss) if and only if it has the uniform convergence property, and then it
is learnable by any ERM learner. In Chapter 13, Exercise 2, we have shown
that this equivalence breaks down for a certain convex learning problem. The
last section of this chapter is devoted to showing that the equivalence between
learnability and uniform convergence breaks down even in multiclass problems
with the 0-1 loss, which are very similar to binary classification. Indeed, we
construct a hypothesis class which is learnable by a specific ERM learner, but
for which other ERM learners might fail and the uniform convergence property
does not hold.

29.1

The Natarajan Dimension
In this section we define the Natarajan dimension, which is a generalization of
the VC dimension to classes of multiclass predictors. Throughout this section,
let H be a hypothesis class of multiclass predictors; namely, each h âˆˆ H is a
function from X to [k].
c 2014 by Shai Shalev-Shwartz and Shai Ben-David
Understanding Machine Learning, 
Published 2014 by Cambridge University Press.
Personal use only. Not for distribution. Do not post.
Please link to http://www.cs.huji.ac.il/~shais/UnderstandingMachineLearning

29.2 The Multiclass Fundamental Theorem

403

To define the Natarajan dimension, we first generalize the definition of shattering.
definition 29.1 (Shattering (Multiclass Version)) We say that a set C âŠ‚ X
is shattered by H if there exist two functions f0 , f1 : C â†’ [k] such that
â€¢ For every x âˆˆ C, f0 (x) 6= f1 (x).
â€¢ For every B âŠ‚ C, there exists a function h âˆˆ H such that
âˆ€x âˆˆ B, h(x) = f0 (x) and âˆ€x âˆˆ C \ B, h(x) = f1 (x).
definition 29.2 (Natarajan Dimension) The Natarajan dimension of H, denoted Ndim(H), is the maximal size of a shattered set C âŠ‚ X .
It is not hard to see that in the case that there are exactly two classes,
Ndim(H) = VCdim(H). Therefore, the Natarajan dimension generalizes the VC
dimension. We next show that the Natarajan dimension allows us to generalize the fundamental theorem of statistical learning from binary classification to
multiclass classification.

29.2

The Multiclass Fundamental Theorem
theorem 29.3 (The Multiclass Fundamental Theorem) There exist absolute
constants C1 , C2 > 0 such that the following holds. For every hypothesis class H
of functions from X to [k], such that the Natarajan dimension of H is d, we have
1. H has the uniform convergence property with sample complexity
d log (k) + log(1/Î´)
d + log(1/Î´)
â‰¤ mUC
.
H (, Î´) â‰¤ C2
2
2
2. H is agnostic PAC learnable with sample complexity
C1

d + log(1/Î´)
d log (k) + log(1/Î´)
â‰¤ mH (, Î´) â‰¤ C2
.
2
2
3. H is PAC learnable (assuming realizability) with sample complexity

d log kd
+ log(1/Î´)
d + log(1/Î´)

C1
â‰¤ mH (, Î´) â‰¤ C2
.


C1

29.2.1

On the Proof of Theorem 29.3
The lower bounds in Theorem 29.3 can be deduced by a reduction from the
binary fundamental theorem (see Exercise 5).
The upper bounds in Theorem 29.3 can be proved along the same lines of the
proof of the fundamental theorem for binary classification, given in Chapter 28
(see Exercise 4). The sole ingredient of that proof that should be modified in a
nonstraightforward manner is Sauerâ€™s lemma. It applies only to binary classes
and therefore must be replaced. An appropriate substitute is Natarajanâ€™s lemma:

404

Multiclass Learnability

lemma 29.4 (Natarajan)

|H| â‰¤ |X |Ndim(H) Â· k 2Ndim(H) .

The proof of Natarajanâ€™s lemma shares the same spirit of the proof of Sauerâ€™s
lemma and is left as an exercise (see Exercise 3).

29.3

Calculating the Natarajan Dimension
In this section we show how to calculate (or estimate) the Natarajan dimension of several popular classes, some of which were studied in Chapter 17. As
these calculations indicate, the Natarajan dimension is often proportional to the
number of parameters required to define a hypothesis.

29.3.1

One-versus-All Based Classes
In Chapter 17 we have seen two reductions of multiclass categorization to binary classification: One-versus-All and All-Pairs. In this section we calculate the
Natarajan dimension of the One-versus-All method.
Recall that in One-versus-All we train, for each label, a binary classifier that
distinguishes between that label and the rest of the labels. This naturally suggests considering multiclass hypothesis classes of the following form. Let Hbin âŠ‚
k
{0, 1}X be a binary hypothesis class. For every hÌ„ = (h1 , . . . , hk ) âˆˆ (Hbin ) define
T (hÌ„) : X â†’ [k] by
T (hÌ„)(x) = argmax hi (x).
iâˆˆ[k]

If there are two labels that maximize hi (x), we choose the smaller one. Also, let
k

OvA,k
Hbin
= {T (hÌ„) : hÌ„ âˆˆ (Hbin ) }.
OvA,k
What â€œshouldâ€ be the Natarajan dimension of Hbin
? Intuitively, to specify a
hypothesis in Hbin we need d = VCdim(Hbin ) parameters. To specify a hypotheOvA,k
sis in Hbin
, we need to specify k hypotheses in Hbin . Therefore, kd parameters
should suffice. The following lemma establishes this intuition.

lemma 29.5

If d = VCdim(Hbin ) then
OvA,k
Ndim(Hbin
) â‰¤ 3kd log (kd) .

Proof Let C âŠ‚ X be a shattered set. By the definition of shattering (for multiclass hypotheses)

 
 OvA,k 
 Hbin
 â‰¥ 2|C| .
C

OvA,k
On the other hand, each hypothesis in Hbin
is determined by using k hypotheses from Hbin . Therefore,

 
 OvA,k 
 Hbin
 â‰¤ | (Hbin )C |k .
C

29.3 Calculating the Natarajan Dimension

405

By Sauerâ€™s lemma, | (Hbin )C | â‰¤ |C|d . We conclude that

 
 OvA,k 
2|C| â‰¤  Hbin
 â‰¤ |C|dk .
C

The proof follows by taking the logarithm and applying Lemma A.1.
OvA,k
How tight is Lemma 29.5? It is not hard to see that for some classes, Ndim(Hbin
)
can be much smaller than dk (see Exercise 1). However there are several natural
OvA,k
binary classes, Hbin (e.g., halfspaces), for which Ndim(Hbin
) = â„¦(dk) (see
Exercise 6).

29.3.2

General Multiclass-to-Binary Reductions
The same reasoning used to establish Lemma 29.5 can be used to upper bound
the Natarajan dimension of more general multiclass-to-binary reductions. These
reductions train several binary classifiers on the data. Then, given a new instance, they predict its label by using some rule that takes into account the
labels predicted by the binary classifiers. These reductions include One-versusAll and All-Pairs.
Suppose that such a method trains l binary classifiers from a binary class Hbin ,
and r : {0, 1}l â†’ [k] is the rule that determines the (multiclass) label according
to the predictions of the binary classifiers. The hypothesis class corresponding
l
to this method can be defined as follows. For every hÌ„ = (h1 , . . . , hl ) âˆˆ (Hbin )
define R(hÌ„) : X â†’ [k] by
R(hÌ„)(x) = r(h1 (x), . . . , hl (x)).
Finally, let
l

r
Hbin
= {R(hÌ„) : hÌ„ âˆˆ (Hbin ) }.

Similarly to Lemma 29.5 it can be proven that:
lemma 29.6

If d = VCdim(Hbin ) then
r
Ndim(Hbin
) â‰¤ 3 l d log (l d) .

The proof is left as Exercise 2.

29.3.3

Linear Multiclass Predictors
Next, we consider the class of linear multiclass predictors (see Section 17.2). Let
Î¨ : X Ã— [k] â†’ Rd be some class-sensitive feature mapping and let
(
)
HÎ¨ =

x 7â†’ argmaxhw, Î¨(x, i)i : w âˆˆ Rd

.

(29.1)

iâˆˆ[k]

Each hypothesis in HÎ¨ is determined by d parameters, namely, a vector w âˆˆ
Rd . Therefore, we would expect that the Natarajan dimension would be upper
bounded by d. Indeed:

406

Multiclass Learnability

theorem 29.7

Ndim(HÎ¨ ) â‰¤ d .

Proof Let C âŠ‚ X be a shattered set, and let f0 , f1 : C â†’ [k] be the two
functions that witness the shattering. We need to show that |C| â‰¤ d. For every
def

x âˆˆ C let Ï(x) = Î¨(x, f0 (x)) âˆ’ Î¨(x, f1 (x)). We claim that the set Ï(C) =
{Ï(x) : x âˆˆ C} consists of |C| elements (i.e., Ï is one to one) and is shattered
by the binary hypothesis class of homogeneous linear separators on Rd ,
H = {x 7â†’ sign(hw, xi) : w âˆˆ Rd }.
Since VCdim(H) = d, it will follow that |C| = |Ï(C)| â‰¤ d, as required.
To establish our claim it is enough to show that |HÏ(C) | = 2|C| . Indeed, given
a subset B âŠ‚ C, by the definition of shattering, there exists hB âˆˆ HÎ¨ for which
âˆ€x âˆˆ B, hB (x) = f0 (x)

and âˆ€x âˆˆ C \ B, hB (x) = f1 (x).

Let wB âˆˆ Rd be a vector that defines hB . We have that, for every x âˆˆ B,
hw, Î¨(x, f0 (x))i > hw, Î¨(x, f1 (x))i â‡’ hw, Ï(x)i > 0.
Similarly, for every x âˆˆ C \ B,
hw, Ï(x)i < 0.
It follows that the hypothesis gB âˆˆ H defined by the same w âˆˆ Rd label the
points in Ï(B) by 1 and the points in Ï(C \ B) by 0. Since this holds for every
B âŠ† C we obtain that |C| = |Ï(C)| and |HÏ(C) | = 2|C| , which concludes our
proof.
The theorem is tight in the sense that there are mappings Î¨ for which Ndim(HÎ¨ ) =
â„¦(d). For example, this is true for the multivector construction (see Section 17.2
and the Bibliographic Remarks at the end of this chapter). We therefore conclude:
corollary 29.8 Let X = Rn and let Î¨ : X Ã— [k] â†’ Rnk be the class sensitive
feature mapping for the multi-vector construction:
Î¨(x, y) = [ 0, . . . , 0 , x1 , . . . , xn , 0, . . . , 0 ].
| {z } | {z } | {z }
âˆˆR(yâˆ’1)n

âˆˆRn

âˆˆR(kâˆ’y)n

Let HÎ¨ be as defined in Equation (29.1). Then, the Natarajan dimension of HÎ¨
satisfies
(k âˆ’ 1)(n âˆ’ 1) â‰¤ Ndim(HÎ¨ ) â‰¤ kn.

29.4

On Good and Bad ERMs
In this section we present an example of a hypothesis class with the property
that not all ERMs for the class are equally successful. Furthermore, if we allow
an infinite number of labels, we will also obtain an example of a class that is

29.4 On Good and Bad ERMs

407

learnable by some ERM, but other ERMs will fail to learn it. Clearly, this also
implies that the class is learnable but it does not have the uniform convergence
property. For simplicity, we consider only the realizable case.
The class we consider is defined as follows. The instance space X will be any
finite or countable set. Let Pf (X ) be the collection of all finite and cofinite
subsets of X (that is, for each A âˆˆ Pf (X ), either A or X \ A must be finite).
Instead of [k], the label set is Y = Pf (X ) âˆª {âˆ—}, where âˆ— is some special label.
For every A âˆˆ Pf (X ) define hA : X â†’ Y by
(
A xâˆˆA
hA (x) =
âˆ— xâˆˆ
/A
Finally, the hypothesis class we take is
H = {hA : A âˆˆ Pf (X )}.
Let A be some ERM algorithm for H. Assume that A operates on a sample
labeled by hA âˆˆ H. Since hA is the only hypothesis in H that might return
the label A, if A observes the label A, it â€œknowsâ€ that the learned hypothesis
is hA , and, as an ERM, must return it (note that in this case the error of the
returned hypothesis is 0). Therefore, to specify an ERM, we should only specify
the hypothesis it returns upon receiving a sample of the form
S = {(x1 , âˆ—), . . . , (xm , âˆ—)}.
We consider two ERMs: The first, Agood , is defined by
Agood (S) = hâˆ… ;
that is, it outputs the hypothesis which predicts â€˜*â€™ for every x âˆˆ X . The second
ERM, Abad , is defined by
Abad (S) = h{x1 ,...xm }c .
The following claim shows that the sample complexity of Abad is about |X |-times
larger than the sample complexity of Agood . This establishes a gap between
different ERMs. If X is infinite, we even obtain a learnable class that is not
learnable by every ERM.
claim 29.9
1. Let , Î´ > 0, D a distribution
 over X and hA âˆˆ H. Let S be an i.i.d. sample
consisting of m â‰¥ 1 log 1Î´ examples, sampled according to D and labeled by
hA . Then, with probability of at least 1 âˆ’ Î´, the hypothesis returned by Agood
will have an error of at most .
2. There exists a constant a > 0 such that for every 0 <  < a there exists a
distribution D over X and hA âˆˆ H such that the following holds. The hypothesis returned by Abad upon receiving a sample of size m â‰¤ |X|âˆ’1
6 , sampled
1
according to D and labeled by hA , will have error â‰¥  with probability â‰¥ eâˆ’ 6 .

408

Multiclass Learnability

Proof Let D be a distribution over X and suppose that the correct labeling
is hA . For any sample, Agood returns either hâˆ… or hA . If it returns hA then its
true error is zero. Thus, it returns a hypothesis with error â‰¥  only if all the m
examples in the sample are from X \ A while the error of hâˆ… , LD (hâˆ… ) = PD [A],
is â‰¥ . Assume m â‰¥ 1 log( 1Î´ ); then the probability of the latter event is no more
than (1 âˆ’ )m â‰¤ eâˆ’m â‰¤ Î´. This establishes item 1.
Next we prove item 2. We restrict the proof to the case that |X | = d < âˆž.
The proof for infinite X is similar. Suppose that X = {x0 , . . . , xdâˆ’1 }.
Let a > 0 be small enough such that 1 âˆ’ 2 â‰¥ eâˆ’4 for every  < a and fix
some  < a. Define a distribution on X by setting P[x0 ] = 1 âˆ’ 2 and for all
2
. Suppose that the correct hypothesis is hâˆ… and let the
1 â‰¤ i â‰¤ d âˆ’ 1, P[xi ] = dâˆ’1
sample size be m. Clearly, the hypothesis returned by Abad will err on all the
examples from X which are not in the sample. By Chernoffâ€™s bound, if m â‰¤ dâˆ’1
6 ,
1
then with probability â‰¥ eâˆ’ 6 , the sample will include no more than dâˆ’1
examples
2
from X . Thus the returned hypothesis will have error â‰¥ .
The conclusion of the example presented is that in multiclass classification,
the sample complexity of different ERMs may differ. Are there â€œgoodâ€ ERMs
for every hypothesis class? The following conjecture asserts that the answer is
yes.
conjecture 29.10
X
H âŠ‚ [k] is

The realizable sample complexity of every hypothesis class

mH (, Î´) = OÌƒ

Ndim(H)



.

We emphasize that the OÌƒ notation may hide only poly-log factors of , Î´, and
Ndim(H), but no factor of k.

29.5

Bibliographic Remarks
The Natarajan dimension is due to Natarajan (1989). That paper also established
the Natarajan lemma and the generalization of the fundamental theorem. Generalizations and sharper versions of the Natarajan lemma are studied in Haussler
& Long (1995). Ben-David, Cesa-Bianchi, Haussler & Long (1995) defined a large
family of notions of dimensions, all of which generalize the VC dimension and
may be used to estimate the sample complexity of multiclass classification.
The calculation of the Natarajan dimension, presented here, together with
calculation of other classes, can be found in Daniely et al. (2012). The example
of good and bad ERMs, as well as conjecture 29.10, are from Daniely et al.
(2011).

29.6 Exercises

29.6

409

Exercises
1. Let d, k > 0. Show that there exists a binary hypothesis Hbin of VC dimension
OvA,k
d such that Ndim(Hbin
) = d.
2. Prove Lemma 29.6.
3. Prove Natarajanâ€™s lemma.
Hint: Fix some x0 âˆˆ X . For i, j âˆˆ [k], denote by Hij all the functions f :
X \ {x0 } â†’ [k] that can be extended to a function in H both by defining
P
f (x0 ) = i and by defining f (x0 ) = j. Show that |H| â‰¤ |HX \{x0 } | + i6=j |Hij |
and use induction.
4. Adapt the proof of the binary fundamental theorem and Natarajanâ€™s lemma
to prove that, for some universal constant C > 0 and for every hypothesis
class of Natarajan dimension d, the agnostic sample complexity of H is

+ log(1/Î´)
d log kd

.
mH (, Î´) â‰¤ C
2
5. Prove that, for some universal constant C > 0 and for every hypothesis class
of Natarajan dimension d, the agnostic sample complexity of H is
d + log(1/Î´)
.
2
Hint: Deduce it from the binary fundamental theorem.
6. Let H be the binary hypothesis class of (nonhomogenous) halfspaces in Rd .
The goal of this exercise is to prove that Ndim(HOvA,k ) â‰¥ (d âˆ’ 1) Â· (k âˆ’ 1).
1. Let Hdiscrete be the class of all functions f : [k âˆ’ 1] Ã— [d âˆ’ 1] â†’ {0, 1} for
which there exists some i0 such that, for every j âˆˆ [d âˆ’ 1]
mH (, Î´) â‰¥ C

âˆ€i < i0 , f (i, j) = 1 while âˆ€i > i0 , f (i, j) = 0.
OvA,k
Show that Ndim(Hdiscrete
) = (d âˆ’ 1) Â· (k âˆ’ 1).
2. Show that Hdiscrete can be realized by H. That is, show that there exists
a mapping Ïˆ : [k âˆ’ 1] Ã— [d âˆ’ 1] â†’ Rd such that

Hdiscrete âŠ‚ {h â—¦ Ïˆ : h âˆˆ H} .
Hint: You can take Ïˆ(i, j) to be the vector whose jth coordinate is 1, whose
last coordinate is i and the rest are zeros.
3. Conclude that Ndim(HOvA,k ) â‰¥ (d âˆ’ 1) Â· (k âˆ’ 1).

30 Compression Bounds

Throughout the book, we have tried to characterize the notion of learnability
using different approaches. At first we have shown that the uniform convergence property of a hypothesis class guarantees successful learning. Later on we
introduced the notion of stability and have shown that stable algorithms are
guaranteed to be good learners. Yet there are other properties which may be
sufficient for learning, and in this chapter and its sequel we will introduce two
approaches to this issue: compression bounds and the PAC-Bayes approach.
In this chapter we study compression bounds. Roughly speaking, we shall see
that if a learning algorithm can express the output hypothesis using a small subset of the training set, then the error of the hypothesis on the rest of the examples
estimates its true error. In other words, an algorithm that can â€œcompressâ€ its
output is a good learner.

30.1

Compression Bounds
To motivate the results, let us first consider the following learning protocol.
First, we sample a sequence of k examples denoted T . On the basis of these
examples, we construct a hypothesis denoted hT . Now we would like to estimate
the performance of hT so we sample a fresh sequence of m âˆ’ k examples, denoted
V , and calculate the error of hT on V . Since V and T are independent, we
immediately get the following from Bernsteinâ€™s inequality (see Lemma B.10).
lemma 30.1
"

Assume that the range of the loss function is [0, 1]. Then,
s
#
2LV (hT ) log(1/Î´) 4 log(1/Î´)
+
â‰¤ Î´.
P LD (hT ) âˆ’ LV (hT ) â‰¥
|V |
|V |

To derive this bound, all we needed was independence between T and V .
Therefore, we can redefine the protocol as follows. First, we agree on a sequence
of k indices I = (i1 , . . . , ik ) âˆˆ [m]k . Then, we sample a sequence of m examples
S = (z1 , . . . , zm ). Now, define T = SI = (zi1 , . . . , zik ) and define V to be the
rest of the examples in S. Note that this protocol is equivalent to the protocol
we defined before â€“ hence Lemma 30.1 still holds.
Applying a union bound over the choice of the sequence of indices we obtain
the following theorem.
c 2014 by Shai Shalev-Shwartz and Shai Ben-David
Understanding Machine Learning, 
Published 2014 by Cambridge University Press.
Personal use only. Not for distribution. Do not post.
Please link to http://www.cs.huji.ac.il/~shais/UnderstandingMachineLearning

30.1 Compression Bounds

411

theorem 30.2 Let k be an integer and let B : Z k â†’ H be a mapping from
sequences of k examples to the hypothesis class. Let m â‰¥ 2k be a training set
size and let A : Z m â†’ H be a learning rule that receives a training sequence S
of size m and returns a hypothesis such that A(S) = B(zi1 , . . . , zik ) for some
(i1 , . . . , ik ) âˆˆ [m]k . Let V = {zj : j âˆˆ
/ (i1 , . . . , ik )} be the set of examples which
were not selected for defining A(S). Then, with probability of at least 1 âˆ’ Î´ over
the choice of S we have
r
4k log(m/Î´) 8k log(m/Î´)
LD (A(S)) â‰¤ LV (A(S)) + LV (A(S))
+
.
m
m
Proof For any I âˆˆ [m]k let hI = B(zi1 , . . . , zik ). Let n = m âˆ’ k. Combining
Lemma 30.1 with the union bound we have
"
#
r
2LV (hI ) log(1/Î´) 4 log(1/Î´)
k
+
P âˆƒI âˆˆ [m] s.t. LD (hI ) âˆ’ LV (hI ) â‰¥
n
n
"
#
r
X
2LV (hI ) log(1/Î´) 4 log(1/Î´)
â‰¤
P LD (hI ) âˆ’ LV (hI ) â‰¥
+
n
n
k
Iâˆˆ[m]

â‰¤ mk Î´.
Denote Î´ 0 = mk Î´. Using the assumption k â‰¤ m/2, which implies that n =
m âˆ’ k â‰¥ m/2, the above implies that with probability of at least 1 âˆ’ Î´ 0 we have
that
r
4k log(m/Î´ 0 ) 8k log(m/Î´ 0 )
LD (A(S)) â‰¤ LV (A(S)) + LV (A(S))
+
,
m
m
which concludes our proof.
As a direct corollary we obtain:
corollary 30.3 Assuming the conditions of Theorem 30.2, and further assuming that LV (A(S)) = 0, then, with probability of at least 1 âˆ’ Î´ over the choice
of S we have
8k log(m/Î´)
.
LD (A(S)) â‰¤
m
These results motivate the following definition:
definition 30.4 (Compression Scheme) Let H be a hypothesis class of
functions from X to Y and let k be an integer. We say that H has a compression
scheme of size k if the following holds:
For all m there exists A : Z m â†’ [m]k and B : Z k â†’ H such that for all h âˆˆ H,
if we feed any training set of the form (x1 , h(x1 )), . . . , (xm , h(xm )) into A and
then feed (xi1 , h(xi1 )), . . . , (xik , h(xik )) into B, where (i1 , . . . , ik ) is the output
of A, then the output of B, denoted h0 , satisfies LS (h0 ) = 0.
It is possible to generalize the definition for unrealizable sequences as follows.

412

Compression Bounds

definition 30.5 (Compression Scheme for Unrealizable Sequences)
Let H be a hypothesis class of functions from X to Y and let k be an integer.
We say that H has a compression scheme of size k if the following holds:
For all m there exists A : Z m â†’ [m]k and B : Z k â†’ H such that for all h âˆˆ H,
if we feed any training set of the form (x1 , y1 ), . . . , (xm , ym ) into A and then
feed (xi1 , yi1 ), . . . , (xik , yik ) into B, where (i1 , . . . , ik ) is the output of A, then
the output of B, denoted h0 , satisfies LS (h0 ) â‰¤ LS (h).
The following lemma shows that the existence of a compression scheme for
the realizable case also implies the existence of a compression scheme for the
unrealizable case.
lemma 30.6 Let H be a hypothesis class for binary classification, and assume
it has a compression scheme of size k in the realizable case. Then, it has a
compression scheme of size k for the unrealizable case as well.
Proof Consider the following scheme: First, find an ERM hypothesis and denote
it by h. Then, discard all the examples on which h errs. Now, apply the realizable
compression scheme on the examples that have not been removed. The output of
the realizable compression scheme, denoted h0 , must be correct on the examples
that have not been removed. Since h errs on the removed examples it follows
that the error of h0 cannot be larger than the error of h; hence h0 is also an ERM
hypothesis.

30.2

Examples
In the examples that follows, we present compression schemes for several hypothesis classes for binary classification. In light of Lemma 30.6 we focus on the
realizable case. Therefore, to show that a certain hypothesis class has a compression scheme, it is necessary to show that there exist A, B, and k for which
LS (h0 ) = 0.

30.2.1

Axis Aligned Rectangles
Note that this is an uncountable infinite class. We show that there is a simple
compression scheme. Consider the algorithm A that works as follows: For each
dimension, choose the two positive examples with extremal values at this dimension. Define B to be the function that returns the minimal enclosing rectangle.
Then, for k = 2d, we have that in the realizable case, LS (B(A(S))) = 0.

30.2.2

Halfspaces
Let X = Rd and consider the class of homogenous halfspaces, {x 7â†’ sign(hw, xi) :
w âˆˆ Rd }.

30.2 Examples

413

A Compression Scheme:
W.l.o.g. assume all labels are positive (otherwise, replace xi by yi xi ). The compression scheme we propose is as follows. First, A finds the vector w which is
in the convex hull of {x1 , . . . , xm } and has minimal norm. Then, it represents it
as a convex combination of d points in the sample (it will be shown later that
this is always possible). The output of A are these d points. The algorithm B
receives these d points and set w to be the point in their convex hull of minimal
norm.
Next we prove that this indeed is a compression sceme. Since the data is
linearly separable, the convex hull of {x1 , . . . , xm } does not contain the origin.
Consider the point w in this convex hull closest to the origin. (This is a unique
point which is the Euclidean projection of the origin onto this convex hull.) We
claim that w separates the data.1 To see this, assume by contradiction that
2
hw, xi i â‰¤ 0 for some i. Take w0 = (1 âˆ’ Î±)w + Î±xi for Î± = kxi kkwk
2 +kwk2 âˆˆ (0, 1).
Then w0 is also in the convex hull and
kw0 k2 = (1 âˆ’ Î±)2 kwk2 + Î±2 kxi k2 + 2Î±(1 âˆ’ Î±)hw, xi i
â‰¤ (1 âˆ’ Î±)2 kwk2 + Î±2 kxi k2
kxi k4 kwk2 + kxi k2 kwk4
=
(kwk2 + kxi k2 )2
kxi k2 kwk2
=
kwk2 + kxi k2
1
= kwk2 Â·
2
kwk /kxi k2 + 1
< kwk2 ,
which leads to a contradiction.
We have thus shown that w is also an ERM. Finally, since w is in the convex
hull of the examples, we can apply Caratheodoryâ€™s theorem to obtain that w is
also in the convex hull of a subset of d + 1 points of the polygon. Furthermore,
the minimality of w implies that w must be on a face of the polygon and this
implies it can be represented as a convex combination of d points.
It remains to show that w is also the projection onto the polygon defined by the
d points. But this must be true: On one hand, the smaller polygon is a subset of
the larger one; hence the projection onto the smaller cannot be smaller in norm.
On the other hand, w itself is a valid solution. The uniqueness of projection
concludes our proof.

30.2.3

Separating Polynomials
Let X = Rd and consider the class x 7â†’ sign(p(x)) where p is a degree r polynomial.
1

It can be shown that w is the direction of the max-margin solution.

414

Compression Bounds

Note that p(x) can be rewritten as hw, Ïˆ(x)i where the elements of Ïˆ(x) are all
the monomials of x up to degree r. Therefore, the problem of constructing a compression scheme for p(x) reduces to the problem of constructing a compression
0
scheme for halfspaces in Rd where d0 = O(dr ).

30.2.4

Separation with Margin
Suppose that a training set is separated with margin Î³. The Perceptron algorithm
guarantees to make at most 1/Î³ 2 updates before converging to a solution that
makes no mistakes on the entire training set. Hence, we have a compression
scheme of size k â‰¤ 1/Î³ 2 .

30.3

Bibliographic Remarks
Compression schemes and their relation to learning were introduced by Littlestone & Warmuth (1986). As we have shown, if a class has a compression scheme
then it is learnable. For binary classification problems, it follows from the fundamental theorem of learning that the class has a finite VC dimension. The other
direction, namely, whether every hypothesis class of finite VC dimension has a
compression scheme of finite size, is an open problem posed by Manfred Warmuth and is still open (see also (Floyd 1989, Floyd & Warmuth 1995, Ben-David
& Litman 1998, Livni & Simon 2013).

31 PAC-Bayes

The Minimum Description Length (MDL) and Occamâ€™s razor principles allow a
potentially very large hypothesis class but define a hierarchy over hypotheses and
prefer to choose hypotheses that appear higher in the hierarchy. In this chapter
we describe the PAC-Bayesian approach that further generalizes this idea. In
the PAC-Bayesian approach, one expresses the prior knowledge by defining prior
distribution over the hypothesis class.

31.1

PAC-Bayes Bounds
As in the MDL paradigm, we define a hierarchy over hypotheses in our class H.
Now, the hierarchy takes the form of a prior distribution over H. That is, we
assign a probability (or density if H is continuous) P (h) â‰¥ 0 for each h âˆˆ H
and refer to P (h) as the prior score of h. Following the Bayesian reasoning
approach, the output of the learning algorithm is not necessarily a single hypothesis. Instead, the learning process defines a posterior probability over H,
which we denote by Q. In the context of a supervised learning problem, where
H contains functions from X to Y, one can think of Q as defining a randomized
prediction rule as follows. Whenever we get a new instance x, we randomly pick
a hypothesis h âˆˆ H according to Q and predict h(x). We define the loss of Q on
an example z to be
def

`(Q, z) = E [`(h, z)].
hâˆ¼Q

By the linearity of expectation, the generalization loss and training loss of Q can
be written as
def

LD (Q) = E [LD (h)]
hâˆ¼Q

def

and LS (Q) = E [LS (h)].
hâˆ¼Q

The following theorem tells us that the difference between the generalization
loss and the empirical loss of a posterior Q is bounded by an expression that
depends on the Kullback-Leibler divergence between Q and the prior distribution P . The Kullback-Leibler is a natural measure of the distance between two
distributions. The theorem suggests that if we would like to minimize the generalization loss of Q, we should jointly minimize both the empirical loss of Q
and the Kullback-Leibler distance between Q and the prior distribution. We will
c 2014 by Shai Shalev-Shwartz and Shai Ben-David
Understanding Machine Learning, 
Published 2014 by Cambridge University Press.
Personal use only. Not for distribution. Do not post.
Please link to http://www.cs.huji.ac.il/~shais/UnderstandingMachineLearning

416

PAC-Bayes

later show how in some cases this idea leads to the regularized risk minimization
principle.
theorem 31.1 Let D be an arbitrary distribution over an example domain Z.
Let H be a hypothesis class and let ` : H Ã— Z â†’ [0, 1] be a loss function. Let P be
a prior distribution over H and let Î´ âˆˆ (0, 1). Then, with probability of at least
1 âˆ’ Î´ over the choice of an i.i.d. training set S = {z1 , . . . , zm } sampled according
to D, for all distributions Q over H (even such that depend on S), we have
s
D(Q||P ) + ln m/Î´
LD (Q) â‰¤ LS (Q) +
,
2(m âˆ’ 1)
where
def

D(Q||P ) = E [ln(Q(h)/P (h))]
hâˆ¼Q

is the Kullback-Leibler divergence.
Proof

For any function f (S), using Markovâ€™s inequality:
P[f (S) â‰¥ ] = P[ef (S) â‰¥ e ] â‰¤
S

S

ES [ef (S) ]
.
e

(31.1)

Let âˆ†(h) = LD (h) âˆ’ LS (h). We will apply Equation (31.1) with the function


2
f (S) = sup 2(m âˆ’ 1) E (âˆ†(h)) âˆ’ D(Q||P ) .
Q

hâˆ¼Q

We now turn to bound ES [ef (S) ]. The main trick is to upper bound f (S) by
using an expression that does not depend on Q but rather depends on the prior
probability P . To do so, fix some S and note that from the definition of D(Q||P )
we get that for all Q,
2

2(m âˆ’ 1) E (âˆ†(h))2 âˆ’ D(Q||P ) = E [ln(e2(mâˆ’1)âˆ†(h) P (h)/Q(h))]
hâˆ¼Q

hâˆ¼Q

2

â‰¤ ln E [e2(mâˆ’1)âˆ†(h) P (h)/Q(h)]
hâˆ¼Q

2

= ln E [e2(mâˆ’1)âˆ†(h) ],
hâˆ¼P

(31.2)

where the inequality follows from Jensenâ€™s inequality and the concavity of the
log function. Therefore,
2

E[ef (S) ] â‰¤ E E [e2(mâˆ’1)âˆ†(h) ].
S

S hâˆ¼P

(31.3)

The advantage of the expression on the right-hand side stems from the fact that
we can switch the order of expectations (because P is a prior that does not
depend on S), which yields
2

E[ef (S) ] â‰¤ E E[e2(mâˆ’1)âˆ†(h) ].
S

hâˆ¼P S

(31.4)

31.2 Bibliographic Remarks

417

2

Next, we claim that for all h we have ES [e2(mâˆ’1)âˆ†(h) ] â‰¤ m. To do so, recall that
Hoeffdingâ€™s inequality tells us that
2

P[âˆ†(h) â‰¥ ] â‰¤ eâˆ’2m .
S

2

This implies that ES [e2(mâˆ’1)âˆ†(h) ] â‰¤ m (see Exercise 1). Combining this with
Equation (31.4) and plugging into Equation (31.1) we get
P[f (S) â‰¥ ] â‰¤
S

m
.
e

(31.5)

Denote the right-hand side of the above Î´, thus  = ln(m/Î´), and we therefore
obtain that with probability of at least 1 âˆ’ Î´ we have that for all Q
2(m âˆ’ 1) E (âˆ†(h))2 âˆ’ D(Q||P ) â‰¤  = ln(m/Î´).
hâˆ¼Q

Rearranging the inequality and using Jensenâ€™s inequality again (the function x2
is convex) we conclude that

2
ln(m/Î´) + D(Q||P )
E âˆ†(h) â‰¤ E (âˆ†(h))2 â‰¤
.
(31.6)
hâˆ¼Q
hâˆ¼Q
2(m âˆ’ 1)

Remark 31.1 (Regularization)
learning rule:

The PAC-Bayes bound leads to the following

Given a prior P , return a posterior Q that minimizes the function
s
D(Q||P ) + ln m/Î´
LS (Q) +
.
2(m âˆ’ 1)

(31.7)

This rule is similar to the regularized risk minimization principle. That is, we
jointly minimize the empirical loss of Q on the sample and the Kullback-Leibler
â€œdistanceâ€ between Q and P .

31.2

Bibliographic Remarks
PAC-Bayes bounds were first introduced by McAllester (1998). See also (McAllester
1999, McAllester 2003, Seeger 2003, Langford & Shawe-Taylor 2003, Langford
2006).

31.3

Exercises
2

1. Let X be a random variable that satisfies P[X â‰¥ ] â‰¤ eâˆ’2m . Prove that
2
E[e2(mâˆ’1)X ] â‰¤ m.

418

PAC-Bayes

2. â€¢ Suppose that H is a finite hypothesis class, set the prior to be uniform over
H, and set the posterior to be Q(hS ) = 1 for some hS and Q(h) = 0 for
all other h âˆˆ H. Show that
s
ln(|H|) + ln(m/Î´)
LD (hS ) â‰¤ LS (h) +
.
2(m âˆ’ 1)
Compare to the bounds we derived using uniform convergence.
â€¢ Derive a bound similar to the Occam bound given in Chapter 7 using the
PAC-Bayes bound

Appendix A Technical Lemmas

lemma A.1 Let a > 0. Then: x â‰¥ 2a log(a) â‡’ x â‰¥ a log(x). It follows that a
necessary condition for the inequality x < a log(x) to hold is that x < 2a log(a).
âˆš
Proof First note that for a âˆˆ (0, e ] the inequality x â‰¥ a log(x) holds unconâˆš
ditionally and therefore the claim is trivial. From now on, assume that a > e.
Consider the function f (x) = x âˆ’ a log(x). The derivative is f 0 (x) = 1 âˆ’ a/x.
Thus, for x > a the derivative is positive and the function increases. In addition,
f (2a log(a)) = 2a log(a) âˆ’ a log(2a log(a))
= 2a log(a) âˆ’ a log(a) âˆ’ a log(2 log(a))
= a log(a) âˆ’ a log(2 log(a)).
Since a âˆ’ 2 log(a) > 0 for all a > 0, the proof follows.
lemma A.2 Let a â‰¥ 1 and b > 0. Then: x â‰¥ 4a log(2a)+2b â‡’ x â‰¥ a log(x)+b.
Proof It suffices to prove that x â‰¥ 4a log(2a) + 2b implies that both x â‰¥
2a log(x) and x â‰¥ 2b. Since we assume a â‰¥ 1 we clearly have that x â‰¥ 2b.
In addition, since b > 0 we have that x â‰¥ 4a log(2a) which using Lemma A.1
implies that x â‰¥ 2a log(x). This concludes our proof.
lemma A.3 Let X be a random variable and x0 âˆˆ R be a scalar and assume
2
2
that there exists a > 0 such that for all t â‰¥ 0 we have P[|X âˆ’ x0 | > t] â‰¤ 2eâˆ’t /a .
Then, E[|X âˆ’ x0 |] â‰¤ 4 a.
Proof For all i = 0, 1, 2, . . . denote ti = a i. Since ti is monotonically increasing
Pâˆž
we have that E[|X âˆ’ x0 |] is at most i=1 ti P[|X âˆ’ x0 | > tiâˆ’1 ]. Combining this
Pâˆž
2
with the assumption in the lemma we get that E[|X âˆ’ x0 |] â‰¤ 2 a i=1 ieâˆ’(iâˆ’1) .
The proof now follows from the inequalities
Z âˆž
âˆž
5
X
X
2
2
2
ieâˆ’(iâˆ’1) â‰¤
ieâˆ’(iâˆ’1) +
xeâˆ’(xâˆ’1) dx < 1.8 + 10âˆ’7 < 2 .
i=1

i=1

5

lemma A.4 Let X be a random variable and x0 âˆˆ R be a scalar and assume
that there exists a > 0 and b â‰¥ e such that p
for all t â‰¥ 0 we have P[|X âˆ’ x0 | >
âˆ’t2 /a2
0
t] â‰¤ 2b e
. Then, E[|X âˆ’ x |] â‰¤ a(2 + log(b)).
c 2014 by Shai Shalev-Shwartz and Shai Ben-David
Understanding Machine Learning, 
Published 2014 by Cambridge University Press.
Personal use only. Not for distribution. Do not post.
Please link to http://www.cs.huji.ac.il/~shais/UnderstandingMachineLearning

420

Technical Lemmas

Proof For all i = 0, 1, 2, . . . denote ti = a (i+
increasing we have that

E[|X âˆ’ x0 |] â‰¤ a

p

log(b)). Since ti is monotonically

âˆž
X
p
log(b) +
ti P[|X âˆ’ x0 | > tiâˆ’1 ].
i=1

Using the assumption in the lemma we have
âˆž
X

ti P[|X âˆ’ x0 | > tiâˆ’1 ] â‰¤ 2 a b

i=1

âˆž
âˆš
X
p
2
(i + log(b))eâˆ’(iâˆ’1+ log(b))
i=1

Z
â‰¤ 2ab

âˆž

xe

âˆš

âˆ’(xâˆ’1)2

1+ log(b)
Z âˆž

dx

2

= 2ab âˆš
(y + 1)eâˆ’y dy
log(b)
Z âˆž
2
yeâˆ’y dy
â‰¤ 4ab âˆš
log(b)

h
i
2 âˆž
= 2 a b âˆ’eâˆ’y âˆš

log(b)

= 2 a b/b = 2 a.
Combining the preceding inequalities we conclude our proof.
Let m, d be two positive integers such that d â‰¤ m âˆ’ 2. Then,

lemma A.5

d  
X
m
k=0

k

â‰¤

 e m d
d

.

Proof We prove the claim by induction. For d = 1 the left-hand side equals
1 + m while the right-hand side equals em; hence the claim is true. Assume that
the claim holds for d and let us prove it for d + 1. By the induction assumption
we have
d+1  
X
m
k=0

k


m
â‰¤
+
d
d+1
!

d
 e m d
d
m(m âˆ’ 1)(m âˆ’ 2) Â· Â· Â· (m âˆ’ d)
=
1+
d
em
(d + 1)d!
!
 d
 em d
d
(m âˆ’ d)
â‰¤
1+
.
d
e
(d + 1)d!
 e m d



Technical Lemmas

421

Using Stirlingâ€™s approximation we further have that
!
 d
 e m d
d
(m âˆ’ d)
âˆš
1+
â‰¤
d
e
(d + 1) 2Ï€d(d/e)d

 e m d 
mâˆ’d
=
1+ âˆš
d
2Ï€d(d + 1)
 e m d d + 1 + (m âˆ’ d)/âˆš2Ï€d
Â·
=
d
d+1
 e m d d + 1 + (m âˆ’ d)/2
Â·
â‰¤
d
d+1
 e m d d/2 + 1 + m/2
Â·
=
d
d+1
 e m d
m
â‰¤
Â·
,
d
d+1
where in the last inequality we used the assumption that d â‰¤ m âˆ’ 2. On the
other hand,
d+1 

d

e m d em
d
em
Â·
=
Â·
d+1
d
d+1
d+1
 e m d em
1
=
Â·
Â·
d
d + 1 (1 + 1/d)d
 e m d em 1
Â·
â‰¥
Â·
d
d+1 e
 e m d
m
=
,
Â·
d
d+1
which proves our inductive argument.
lemma A.6

For all a âˆˆ R we have
2
ea + eâˆ’a
â‰¤ ea /2 .
2

Proof

Observe that
ea =

âˆž
X
an
.
n!
n=0

Therefore,
âˆž
X
a2n
ea + eâˆ’a
=
,
2
(2n)!
n=0

and
e

a2 /2

âˆž
X
a2n
=
.
2n n!
n=0

Observing that (2n)! â‰¥ 2n n! for every n â‰¥ 0 we conclude our proof.

Appendix B Measure Concentration

Let Z1 , . . . , Zm be an i.i.d. sequence of random variables and let Âµ be their mean.
The strong law of large numbers states that when m tends to infinity, the emPm
1
pirical average, m
i=1 Zi , converges to the expected value Âµ, with probability
1. Measure concentration inequalities quantify the deviation of the empirical
average from the expectation when m is finite.

B.1

Markovâ€™s Inequality
We start with an inequality which is called Markovâ€™s inequality. Let Z be a
nonnegative random variable. The expectation of Z can be written as follows:
Z âˆž
E[Z] =
P[Z â‰¥ x]dx.
(B.1)
x=0

Since P[Z â‰¥ x] is monotonically nonincreasing we obtain
Z a
Z a
âˆ€a â‰¥ 0, E[Z] â‰¥
P[Z â‰¥ x]dx â‰¥
P[Z â‰¥ a]dx = a P[Z â‰¥ a].
x=0

(B.2)

x=0

Rearranging the inequality yields Markovâ€™s inequality:
E[Z]
.
(B.3)
a
For random variables that take value in [0, 1], we can derive from Markovâ€™s
inequality the following.
âˆ€a â‰¥ 0, P[Z â‰¥ a] â‰¤

lemma B.1 Let Z be a random variable that takes values in [0, 1]. Assume that
E[Z] = Âµ. Then, for any a âˆˆ (0, 1),
Âµ âˆ’ (1 âˆ’ a)
.
a
This also implies that for every a âˆˆ (0, 1),
P[Z > 1 âˆ’ a] â‰¥

P[Z > a] â‰¥

Âµâˆ’a
â‰¥ Âµ âˆ’ a.
1âˆ’a

Proof Let Y = 1 âˆ’ Z. Then Y is a nonnegative random variable with E[Y ] =
1 âˆ’ E[Z] = 1 âˆ’ Âµ. Applying Markovâ€™s inequality on Y we obtain
P[Z â‰¤ 1 âˆ’ a] = P[1 âˆ’ Z â‰¥ a] = P[Y â‰¥ a] â‰¤

E[Y ]
1âˆ’Âµ
=
.
a
a

c 2014 by Shai Shalev-Shwartz and Shai Ben-David
Understanding Machine Learning, 
Published 2014 by Cambridge University Press.
Personal use only. Not for distribution. Do not post.
Please link to http://www.cs.huji.ac.il/~shais/UnderstandingMachineLearning

B.2 Chebyshevâ€™s Inequality

423

Therefore,
P[Z > 1 âˆ’ a] â‰¥ 1 âˆ’

B.2

1âˆ’Âµ
a+Âµâˆ’1
=
.
a
a

Chebyshevâ€™s Inequality
Applying Markovâ€™s inequality on the random variable (Z âˆ’ E[Z])2 we obtain
Chebyshevâ€™s inequality:
âˆ€a > 0,

P[|Z âˆ’ E[Z]| â‰¥ a] = P[(Z âˆ’ E[Z])2 â‰¥ a2 ] â‰¤

Var[Z]
,
a2

(B.4)

where Var[Z] = E[(Z âˆ’ E[Z])2 ] is the variance of Z.
Pm
1
Consider the random variable m
i=1 Zi . Since Z1 , . . . , Zm are i.i.d. it is easy
to verify that
#
"
m
Var[Z1 ]
1 X
Zi =
.
Var
m i=1
m
Applying Chebyshevâ€™s inequality, we obtain the following:
lemma B.2 Let Z1 , . . . , Zm be a sequence of i.i.d. random variables and assume
that E[Z1 ] = Âµ and Var[Z1 ] â‰¤ 1. Then, for any Î´ âˆˆ (0, 1), with probability of at
least 1 âˆ’ Î´ we have
 r

m

1 X
1


Zi âˆ’ Âµ â‰¤
.


m
Î´m
i=1
Proof

Applying Chebyshevâ€™s inequality we obtain that for all a > 0

"
#
m
1 X

Var[Z1 ]
1


P 
Zi âˆ’ Âµ > a â‰¤
â‰¤
.
2
m

ma
m a2
i=1

The proof follows by denoting the right-hand side Î´ and solving for a.
The deviation between the empirical average and the mean given previously
decreases polynomially with m. It is possible to obtain a significantly faster
decrease. In the sections that follow we derive bounds that decrease exponentially
fast.

B.3

Chernoffâ€™s Bounds
Let Z1 , . . . , Zm be independent Bernoulli variables where for every i, P[Zi = 1] =
Pm
Pm
pi and P[Zi = 0] = 1 âˆ’ pi . Let p = i=1 pi and let Z = i=1 Zi . Using the

424

Measure Concentration

monotonicity of the exponent function and Markovâ€™s inequality, we have that for
every t > 0
P[Z > (1 + Î´)p] = P[etZ > et(1+Î´)p ] â‰¤

E[etZ ]
.
e(1+Î´)tp

(B.5)

Next,
E[etZ ] = E[et

P

i

Zi

Y
] = E[ etZi ]
i

=

Y

E[e

tZi

]

by independence

i

=

Y

=

Y

â‰¤

Y

pi et + (1 âˆ’ pi )e0



i

1 + pi (et âˆ’ 1)



i

=e

epi (e

i
P

= e(e

i

t

t

âˆ’1)

using 1 + x â‰¤ ex

pi (et âˆ’1)

âˆ’1)p

.

Combining the above with Equation (B.5) and choosing t = log(1 + Î´) we obtain
lemma B.3 Let Z1 , . . . , Zm be independent Bernoulli variables where for every
Pm
Pm
i, P[Zi = 1] = pi and P[Zi = 0] = 1 âˆ’ pi . Let p = i=1 pi and let Z = i=1 Zi .
Then, for any Î´ > 0,
P[Z > (1 + Î´)p] â‰¤ eâˆ’h(Î´) p ,
where
h(Î´) = (1 + Î´) log(1 + Î´) âˆ’ Î´.
Using the inequality h(a) â‰¥ a2 /(2 + 2a/3) we obtain
lemma B.4

Using the notation of Lemma B.3 we also have
Î´2

P[Z > (1 + Î´)p] â‰¤ eâˆ’p 2+2Î´/3 .
For the other direction, we apply similar calculations:
P[Z < (1âˆ’Î´)p] = P[âˆ’Z > âˆ’(1âˆ’Î´)p] = P[eâˆ’tZ > eâˆ’t(1âˆ’Î´)p ] â‰¤

E[eâˆ’tZ ]
, (B.6)
eâˆ’(1âˆ’Î´)tp

B.4 Hoeffdingâ€™s Inequality

425

and,
E[eâˆ’tZ ] = E[eâˆ’t

P

i

Zi

Y
] = E[ eâˆ’tZi ]
i

=

Y

E[e

âˆ’tZi

]

by independence

i

=

Y

â‰¤

Y


1 + pi (eâˆ’t âˆ’ 1)

i

epi (e

âˆ’t

âˆ’1)

using 1 + x â‰¤ ex

i

=e

(eâˆ’t âˆ’1)p

.

Setting t = âˆ’ log(1 âˆ’ Î´) yields
P[Z < (1 âˆ’ Î´)p] â‰¤

eâˆ’Î´p
e(1âˆ’Î´) log(1âˆ’Î´) p

= eâˆ’ph(âˆ’Î´) .

It is easy to verify that h(âˆ’Î´) â‰¥ h(Î´) and hence
lemma B.5

Using the notation of Lemma B.3 we also have
Î´2

P[Z < (1 âˆ’ Î´)p] â‰¤ eâˆ’ph(âˆ’Î´) â‰¤ eâˆ’ph(Î´) â‰¤ eâˆ’p 2+2Î´/3 .

B.4

Hoeffdingâ€™s Inequality
lemma B.6 (Hoeffdingâ€™s inequality) Let Z1 , . . . , Zm be a sequence of i.i.d.
Pm
1
random variables and let ZÌ„ = m
i=1 Zi . Assume that E[ZÌ„] = Âµ and P[a â‰¤
Zi â‰¤ b] = 1 for every i. Then, for any  > 0

" m
#

 X

1

P m
Zi âˆ’ Âµ >  â‰¤ 2 exp âˆ’2 m 2 /(b âˆ’ a)2 .


i=1

P
1
Proof Denote Xi = Zi âˆ’ E[Zi ] and XÌ„ = m
i Xi . Using the monotonicity of
the exponent function and Markovâ€™s inequality, we have that for every Î» > 0
and  > 0,
P[XÌ„ â‰¥ ] = P[eÎ»XÌ„ â‰¥ eÎ» ] â‰¤ eâˆ’Î» E[eÎ»XÌ„ ].
Using the independence assumption we also have
"
#
Y
Y
Î»XÌ„
Î»Xi /m
E[e ] = E
e
=
E[eÎ»Xi /m ].
i

i

By Hoeffdingâ€™s lemma (Lemma B.7 later), for every i we have
E[eÎ»Xi /m ] â‰¤ e

Î»2 (bâˆ’a)2
8m2

.

426

Measure Concentration

Therefore,
P[XÌ„ â‰¥ ] â‰¤ eâˆ’Î»

Y

e

Î»2 (bâˆ’a)2
8m2

= eâˆ’Î»+

Î»2 (bâˆ’a)2
8m

.

i

Setting Î» = 4m/(b âˆ’ a)2 we obtain
2

P[XÌ„ â‰¥ ] â‰¤ e

2m
âˆ’ (bâˆ’a)
2

.

Applying the same arguments on the variable âˆ’XÌ„ we obtain that P[XÌ„ â‰¤ âˆ’] â‰¤
2

2m
âˆ’ (bâˆ’a)
2

e

. The theorem follows by applying the union bound on the two cases.

lemma B.7 (Hoeffdingâ€™s lemma) Let X be a random variable that takes values
in the interval [a, b] and such that E[X] = 0. Then, for every Î» > 0,
E[eÎ»X ] â‰¤ e

Î»2 (bâˆ’a)2
8

.

Proof Since f (x) = eÎ»x is a convex function, we have that for every Î± âˆˆ (0, 1),
and x âˆˆ [a, b],
f (x) â‰¤ Î±f (a) + (1 âˆ’ Î±)f (b).
Setting Î± =

bâˆ’x
bâˆ’a

âˆˆ [0, 1] yields
eÎ»x â‰¤

b âˆ’ x Î»a x âˆ’ a Î»b
e +
e .
bâˆ’a
bâˆ’a

Taking the expectation, we obtain that
E[eÎ»X ] â‰¤

b Î»a
a Î»b
b âˆ’ E[X] Î»a E[x] âˆ’ a Î»b
e +
e =
e âˆ’
e ,
bâˆ’a
bâˆ’a
bâˆ’a
bâˆ’a

âˆ’a
where we used the fact that E[X] = 0. Denote h = Î»(b âˆ’ a), p = bâˆ’a
, and
h
L(h) = âˆ’hp + log(1 âˆ’ p + pe ). Then, the expression on the right-hand side of
the above can be rewritten as eL(h) . Therefore, to conclude our proof it suffices
2
to show that L(h) â‰¤ h8 . This follows from Taylorâ€™s theorem using the facts:
L(0) = L0 (0) = 0 and L00 (h) â‰¤ 1/4 for all h.

B.5

Bennetâ€™s and Bernsteinâ€™s Inequalities
Bennetâ€™s and Bernseinâ€™s inequalities are similar to Chernoffâ€™s bounds, but they
hold for any sequence of independent random variables. We state the inequalities
without proof, which can be found, for example, in Cesa-Bianchi & Lugosi (2006).
lemma B.8 (Bennetâ€™s inequality) Let Z1 , . . . , Zm be independent random variables with zero mean, and assume that Zi â‰¤ 1 with probability 1. Let
m

Ïƒ2 â‰¥

1 X
E[Zi2 ].
m i=1

B.5 Bennetâ€™s and Bernsteinâ€™s Inequalities

427

Then for all  > 0,
"
P

m
X

#


2
Zi >  â‰¤ eâˆ’mÏƒ h( mÏƒ2 ) .

i=1

where
h(a) = (1 + a) log(1 + a) âˆ’ a.
By using the inequality h(a) â‰¥ a2 /(2 + 2a/3) it is possible to derive the
following:
lemma B.9 (Bernsteinâ€™s inequality) Let Z1 , . . . , Zm be i.i.d. random variables
with a zero mean. If for all i, P(|Zi | < M ) = 1, then for all t > 0 :
"

m
X

#

t2 /2
P
Zi > t â‰¤ exp âˆ’ P
E Zj2 + M t/3
i=1

B.5.1

!
.

Application
Bernsteinâ€™s inequality can be used to interpolate between the rate 1/ we derived
for PAC learning in the realizable case (in Chapter 2) and the rate 1/2 we derived
for the unrealizable case (in Chapter 4).
lemma B.10 Let ` : H Ã— Z â†’ [0, 1] be a loss function. Let D be an arbitrary
distribution over Z. Fix some h. Then, for any Î´ âˆˆ (0, 1) we have
"
#
r
2LD (h) log(1/Î´) 2 log(1/Î´)
LS (h) â‰¥ LD (h) +
1.
P
+
â‰¤Î´
Sâˆ¼D m
3m
m
"
#
r
2LS (h) log(1/Î´) 4 log(1/Î´)
2.
P
LD (h) â‰¥ LS (h) +
+
â‰¤Î´
Sâˆ¼D m
m
m
Proof Define random variables Î±1 , . . . , Î±m s.t. Î±i = `(h, zi ) âˆ’ LD (h). Note that
E[Î±i ] = 0 and that
E[Î±i2 ] = E[`(h, zi )2 ] âˆ’ 2LD (h) E[`(h, zi )] + LD (h)2
= E[`(h, zi )2 ] âˆ’ LD (h)2
â‰¤ E[`(h, zi )2 ]
â‰¤ E[`(h, zi )] = LD (h),
where in the last inequality we used the fact that `(h, zi ) âˆˆ [0, 1] and thus
`(h, zi )2 â‰¤ `(h, zi ). Applying Bernseinâ€™s inequality over the Î±i â€™s yields
"m
#
!
X
t2 /2
P
Î±i > t â‰¤ exp âˆ’ P
E Î±j2 + t/3
i=1


t2 /2
def
â‰¤ exp âˆ’
= Î´.
m LD (h) + t/3

428

Measure Concentration

Solving for t yields
t2 /2
= log(1/Î´)
m LD (h) + t/3
log(1/Î´)
â‡’ t2 /2 âˆ’
t âˆ’ log(1/Î´) m LD (h) = 0
3
s

log(1/Î´)
log2 (1/Î´)
+ 2 log(1/Î´) m LD (h)
+
3
32
log(1/Î´) p
â‰¤2
+ 2 log(1/Î´) m LD (h)
3
â‡’ t=

1
m

P

Î±i = LS (h) âˆ’ LD (h), it follows that with probability of at least 1 âˆ’ Î´,
r
log(1/Î´)
2 log(1/Î´) LD (h)
LS (h) âˆ’ LD (h) â‰¤ 2
+
,
3m
m
which proves the first inequality. The second part of the lemma follows in a
similar way.

Since

B.6

i

Sludâ€™s Inequality
Pm
Let X be a (m, p) binomial variable. That is, X = i=1 Zi , where each Zi is 1
with probability p and 0 with probability 1âˆ’p. Assume that p = (1âˆ’)/2. Sludâ€™s
inequality (Slud 1977) tells us that P[X â‰¥ m/2] is lower bounded
by the probap
bility that a normal variable will be greater than or equal to m2 /(1 âˆ’ 2 ). The
following lemma follows by standard tail bounds for the normal distribution.
lemma B.11 Let X be a (m, p) binomial variable and assume that p = (1âˆ’)/2.
Then,

p
1
1 âˆ’ 1 âˆ’ exp(âˆ’m2 /(1 âˆ’ 2 )) .
P[X â‰¥ m/2] â‰¥
2

B.7

Concentration of Ï‡2 Variables
Let X1 , . . . , Xk be k independent normally distributed random variables. That
is, for all i, Xi âˆ¼ N (0, 1). The distribution of the random variable Xi2 is called
Ï‡2 (chi square) and the distribution of the random variable Z = X12 + Â· Â· Â· + Xk2
is called Ï‡2k (chi square with k degrees of freedom). Clearly, E[Xi2 ] = 1 and
E[Z] = k. The following lemma states that Xk2 is concentrated around its mean.
lemma B.12

Let Z âˆ¼ Ï‡2k . Then, for all  > 0 we have
2

k/6

,

2

k/6

.

P[Z â‰¤ (1 âˆ’ )k] â‰¤ eâˆ’
and for all  âˆˆ (0, 3) we have
P[Z â‰¥ (1 + )k] â‰¤ eâˆ’

B.7 Concentration of Ï‡2 Variables

429

Finally, for all  âˆˆ (0, 3),
2

P [(1 âˆ’ )k â‰¤ Z â‰¤ (1 + )k] â‰¥ 1 âˆ’ 2eâˆ’ k/6 .
Pk
Proof Let us write Z = i=1 Xi2 where Xi âˆ¼ N (0, 1). To prove both bounds
we use Chernoffâ€™s bounding method. For the first inequality, we first bound
2
2
E[eâˆ’Î»X1 ], where Î» > 0 will be specified later. Since eâˆ’a â‰¤ 1 âˆ’ a + a2 for all a â‰¥ 0
we have that
2
Î»2
E[eâˆ’Î»X1 ] â‰¤ 1 âˆ’ Î» E[X12 ] +
E[X14 ].
2
Using the well known equalities, E[X12 ] = 1 and E[X14 ] = 3, and the fact that
1 âˆ’ a â‰¤ eâˆ’a we obtain that
2

2

3

E[eâˆ’Î»X1 ] â‰¤ 1 âˆ’ Î» + 32 Î»2 â‰¤ eâˆ’Î»+ 2 Î» .
Now, applying Chernoffâ€™s bounding method we get that
h
i
P[âˆ’Z â‰¥ âˆ’(1 âˆ’ )k] = P eâˆ’Î»Z â‰¥ eâˆ’(1âˆ’)kÎ»


â‰¤ e(1âˆ’)kÎ» E eâˆ’Î»Z
 h
ik
2
= e(1âˆ’)kÎ» E eâˆ’Î»X1
3

2

â‰¤ e(1âˆ’)kÎ» eâˆ’Î»k+ 2 Î»
3

k

2

= eâˆ’kÎ»+ 2 kÎ» .
Choose Î» = /3 we obtain the first inequality stated in the lemma.
For the second inequality, we use a known closed form expression for the
moment generating function of a Ï‡2k distributed random variable:
h
i
2
âˆ€Î» < 21 , E eÎ»Z
= (1 âˆ’ 2Î»)âˆ’k/2 .
(B.7)
On the basis of the equation and using Chernoffâ€™s bounding method we have
h
i
P[Z â‰¥ (1 + )k)] = P eÎ»Z â‰¥ e(1+)kÎ»


â‰¤ eâˆ’(1+)kÎ» E eÎ»Z
âˆ’k/2

= eâˆ’(1+)kÎ» (1 âˆ’ 2Î»)

â‰¤ eâˆ’(1+)kÎ» ekÎ» = eâˆ’kÎ» ,
where the last inequality occurs because (1 âˆ’ a) â‰¤ eâˆ’a . Setting Î» = /6 (which
is in (0, 1/2) by our assumption) we obtain the second inequality stated in the
lemma.
Finally, the last inequality follows from the first two inequalities and the union
bound.

Appendix C Linear Algebra

C.1

Basic Definitions
In this chapter we only deal with linear algebra over finite dimensional Euclidean
spaces. We refer to vectors as column vectors.
Given two d dimensional vectors u, v âˆˆ Rd , their inner product is

hu, vi =

d
X

ui vi .

i=1

p
The Euclidean norm (a.k.a. the `2 norm) is kuk = hu, ui. We also use the `1
Pd
norm, kuk1 = i=1 |ui | and the `âˆž norm kukâˆž = maxi |ui |.
A subspace of Rd is a subset of Rd which is closed under addition and scalar
multiplication. The span of a set of vectors u1 , . . . , uk is the subspace containing
all vectors of the form
k
X

Î±i ui

i=1

where for all i, Î±i âˆˆ R.
A set of vectors U = {u1 , . . . , uk } is independent if for every i, ui is not in the
span of u1 , . . . , uiâˆ’1 , ui+1 , . . . , uk . We say that U spans a subspace V if V is the
span of the vectors in U . We say that U is a basis of V if it is both independent
and spans V. The dimension of V is the size of a basis of V (and it can be verified
that all bases of V have the same size). We say that U is an orthogonal set if for
all i 6= j, hui , uj i = 0. We say that U is an orthonormal set if it is orthogonal
and if for every i, kui k = 1.
Given a matrix A âˆˆ Rn,d , the range of A is the span of its columns and the
null space of A is the subspace of all vectors that satisfy Au = 0. The rank of A
is the dimension of its range.
The transpose of a matrix A, denoted A> , is the matrix whose (i, j) entry
equals the (j, i) entry of A. We say that A is symmetric if A = A> .
c 2014 by Shai Shalev-Shwartz and Shai Ben-David
Understanding Machine Learning, 
Published 2014 by Cambridge University Press.
Personal use only. Not for distribution. Do not post.
Please link to http://www.cs.huji.ac.il/~shais/UnderstandingMachineLearning

C.2 Eigenvalues and Eigenvectors

C.2

431

Eigenvalues and Eigenvectors
Let A âˆˆ Rd,d be a matrix. A non-zero vector u is an eigenvector of A with a
corresponding eigenvalue Î» if
Au = Î»u.
theorem C.1 (Spectral Decomposition) If A âˆˆ Rd,d is a symmetric matrix of
rank k, then there exists an orthonormal basis of Rd , u1 , . . . , ud , such that each
Pd
ui is an eigenvector of A. Furthermore, A can be written as A = i=1 Î»i ui u>
i ,
where each Î»i is the eigenvalue corresponding to the eigenvector ui . This can
be written equivalently as A = U DU > , where the columns of U are the vectors
u1 , . . . , ud , and D is a diagonal matrix with Di,i = Î»i and for i 6= j, Di,j =
0. Finally, the number of Î»i which are nonzero is the rank of the matrix, the
eigenvectors which correspond to the nonzero eigenvalues span the range of A,
and the eigenvectors which correspond to zero eigenvalues span the null space of
A.

C.3

Positive definite matrices
A symmetric matrix A âˆˆ Rd,d is positive definite if all its eigenvalues are positive.
A is positive semidefinite if all its eigenvalues are nonnegative.
theorem C.2 Let A âˆˆ Rd,d be a symmetric matrix. Then, the following are
equivalent definitions of positive semidefiniteness of A:
â€¢ All the eigenvalues of A are nonnegative.
â€¢ For every vector u, hu, Aui â‰¥ 0.
â€¢ There exists a matrix B such that A = BB > .

C.4

Singular Value Decomposition (SVD)
Let A âˆˆ Rm,n be a matrix of rank r. When m 6= n, the eigenvalue decomposition
given in Theorem C.1 cannot be applied. We will describe another decomposition
of A, which is called Singular Value Decomposition, or SVD for short.
Unit vectors v âˆˆ Rn and u âˆˆ Rm are called right and left singular vectors of
A with corresponding singular value Ïƒ > 0 if
Av = Ïƒu

and A> u = Ïƒv.

We first show that if we can find r orthonormal singular vectors with positive
singular values, then we can decompose A = U DV > , with the columns of U and
V containing the left and right singular vectors, and D being a diagonal r Ã— r
matrix with the singular values on its diagonal.

432

Linear Algebra

lemma C.3 Let A âˆˆ Rm,n be a matrix of rank r. Assume that v1 , . . . , vr is an
orthonormal set of right singular vectors of A, u1 , . . . , ur is an orthonormal set
of corresponding left singular vectors of A, and Ïƒ1 , . . . , Ïƒr are the corresponding
singular values. Then,
r
X
A=
Ïƒi ui vi> .
i=1

It follows that if U is a matrix whose columns are the ui â€™s, V is a matrix whose
columns are the vi â€™s, and D is a diagonal matrix with Di,i = Ïƒi , then
A = U DV > .
Proof Any right singular vector of A must be in the range of A> (otherwise,
the singular value will have to be zero). Therefore, v1 , . . . , vr is an orthonormal
basis of the range of A. Let us complete it to an orthonormal basis of Rn by
Pr
adding the vectors vr+1 , . . . , vn . Define B = i=1 Ïƒi ui vi> . It suffices to prove
that for all i, Avi = Bvi . Clearly, if i > r then Avi = 0 and Bvi = 0 as well.
For i â‰¤ r we have
Bvi =

r
X

Ïƒj uj vj> vi = Ïƒi ui = Avi ,

j=1

where the last equality follows from the definition.
The next lemma relates the singular values of A to the eigenvalues of A> A
and AA> .
lemma C.4 v, u are right and left singular vectors of A with singular value Ïƒ
iff v is an eigenvector of A> A with corresponding eigenvalue Ïƒ 2 and u = Ïƒ âˆ’1 Av
is an eigenvector of AA> with corresponding eigenvalue Ïƒ 2 .
Proof Suppose that Ïƒ is a singular value of A with v âˆˆ Rn being the corresponding right singular vector. Then,
A> Av = ÏƒA> u = Ïƒ 2 v.
Similarly,
AA> u = ÏƒAv = Ïƒ 2 u.
For the other direction, if Î» 6= 0 is an eigenvalue of A> A, with v being the
corresponding
eigenvector, then Î» > 0 because A> A is positive semidefinite. Let
âˆš
âˆ’1
Ïƒ = Î», u = Ïƒ Av. Then,
âˆš Av
Ïƒu = Î» âˆš = Av,
Î»
and
A> u =

1 >
Î»
A Av = v = Ïƒv.
Ïƒ
Ïƒ

C.4 Singular Value Decomposition (SVD)

433

Finally, we show that if A has rank r then it has r orthonormal singular
vectors.
lemma C.5

Let A âˆˆ Rm,n with rank r. Define the following vectors:
v1 = argmax kAvk
vâˆˆRn :kvk=1

v2 = argmax kAvk
vâˆˆRn :kvk=1
hv,v1 i=0

..
.
vr =

kAvk

argmax
vâˆˆRn :kvk=1
âˆ€i<r, hv,vi i=0

Then, v1 , . . . , vr is an orthonormal set of right singular vectors of A.
Proof First note that since the rank of A is r, the range of A is a subspace of
dimension r, and therefore it is easy to verify that for all i = 1, . . . , r, kAvi k > 0.
Let W âˆˆ Rn,n be an orthonormal matrix obtained by the eigenvalue decomposition of A> A, namely, A> A = W DW > , with D being a diagonal matrix with
D1,1 â‰¥ D2,2 â‰¥ Â· Â· Â· â‰¥ 0. We will show that v1 , . . . , vr are eigenvectors of A> A
that correspond to nonzero eigenvalues, and, hence, using Lemma C.4 it follows
that these are also right singular vectors of A. The proof is by induction. For the
basis of the induction, note that any unit vector v can be written as v = W x,
for x = W > v, and note that kxk = 1. Therefore,
kAvk2 = kAW xk2 = kW DW > W xk2 = kW Dxk2 = kDxk2 =

n
X

2
Di,i
xi 2 .

i=1

Therefore,
max kAvk2 = max
v:kvk=1

x:kxk=1

n
X

2
Di,i
xi 2 .

i=1

The solution of the right-hand side is to set x = (1, 0, . . . , 0), which implies that
v1 is the first eigenvector of A> A. Since kAv1 k > 0 it follows that D1,1 > 0 as
required. For the induction step, assume that the claim holds for some 1 â‰¤ t â‰¤
r âˆ’ 1. Then, any v which is orthogonal to v1 , . . . , vt can be written as v = W x
with all the first t elements of x being zero. It follows that
max

v:kvk=1,âˆ€iâ‰¤t,v> vi =0

kAvk2 = max
x:kxk=1

n
X

2
Di,i
xi 2 .

i=t+1

The solution of the right-hand side is the all zeros vector except xt+1 = 1. This
implies that vt+1 is the (t + 1)th column of W . Finally, since kAvt+1 k > 0 it
follows that Dt+1,t+1 > 0 as required. This concludes our proof.

434

Linear Algebra

corollary C.6 (The SVD theorem) Let A âˆˆ Rm,n with rank r. Then A =
U DV > where D is an r Ã— r matrix with nonzero singular values of A and the
columns of U, V are orthonormal left and right singular vectors of A. Further2
more, for all i, Di,i
is an eigenvalue of A> A, the ith column of V is the corresponding eigenvector of A> A and the ith column of U is the corresponding
eigenvector of AA> .

Notes

c 2014 by Shai Shalev-Shwartz and Shai Ben-David
Understanding Machine Learning, 
Published 2014 by Cambridge University Press.
Personal use only. Not for distribution. Do not post.
Please link to http://www.cs.huji.ac.il/~shais/UnderstandingMachineLearning

References

Abernethy, J., Bartlett, P. L., Rakhlin, A. & Tewari, A. (2008), Optimal strategies and
minimax lower bounds for online convex games, in â€˜Proceedings of the Nineteenth
Annual Conference on Computational Learning Theoryâ€™.
Ackerman, M. & Ben-David, S. (2008), Measures of clustering quality: A working set
of axioms for clustering, in â€˜Proceedings of Neural Information Processing Systems
(NIPS)â€™, pp. 121â€“128.
Agarwal, S. & Roth, D. (2005), Learnability of bipartite ranking functions, in â€˜Proceedings of the 18th Annual Conference on Learning Theoryâ€™, pp. 16â€“31.
Agmon, S. (1954), â€˜The relaxation method for linear inequalitiesâ€™, Canadian Journal
of Mathematics 6(3), 382â€“392.
Aizerman, M. A., Braverman, E. M. & Rozonoer, L. I. (1964), â€˜Theoretical foundations
of the potential function method in pattern recognition learningâ€™, Automation and
Remote Control 25, 821â€“837.
Allwein, E. L., Schapire, R. & Singer, Y. (2000), â€˜Reducing multiclass to binary: A unifying approach for margin classifiersâ€™, Journal of Machine Learning Research 1, 113â€“
141.
Alon, N., Ben-David, S., Cesa-Bianchi, N. & Haussler, D. (1997), â€˜Scale-sensitive dimensions, uniform convergence, and learnabilityâ€™, Journal of the ACM 44(4), 615â€“631.
Anthony, M. & Bartlet, P. (1999), Neural Network Learning: Theoretical Foundations,
Cambridge University Press.
Baraniuk, R., Davenport, M., DeVore, R. & Wakin, M. (2008), â€˜A simple proof of
the restricted isometry property for random matricesâ€™, Constructive Approximation
28(3), 253â€“263.
Barber, D. (2012), Bayesian reasoning and machine learning, Cambridge University
Press.
Bartlett, P., Bousquet, O. & Mendelson, S. (2005), â€˜Local rademacher complexitiesâ€™,
Annals of Statistics 33(4), 1497â€“1537.
Bartlett, P. L. & Ben-David, S. (2002), â€˜Hardness results for neural network approximation problemsâ€™, Theor. Comput. Sci. 284(1), 53â€“66.
Bartlett, P. L., Long, P. M. & Williamson, R. C. (1994), Fat-shattering and the learnability of real-valued functions, in â€˜Proceedings of the seventh annual conference on
Computational learning theoryâ€™, ACM, pp. 299â€“310.
Bartlett, P. L. & Mendelson, S. (2001), Rademacher and Gaussian complexities: Risk
bounds and structural results, in â€˜14th Annual Conference on Computational Learning Theory, COLT 2001â€™, Vol. 2111, Springer, Berlin, pp. 224â€“240.
c 2014 by Shai Shalev-Shwartz and Shai Ben-David
Understanding Machine Learning, 
Published 2014 by Cambridge University Press.
Personal use only. Not for distribution. Do not post.
Please link to http://www.cs.huji.ac.il/~shais/UnderstandingMachineLearning

438

References

Bartlett, P. L. & Mendelson, S. (2002), â€˜Rademacher and Gaussian complexities: Risk
bounds and structural resultsâ€™, Journal of Machine Learning Research 3, 463â€“482.
Ben-David, S., Cesa-Bianchi, N., Haussler, D. & Long, P. (1995), â€˜Characterizations
of learnability for classes of {0, . . . , n}-valued functionsâ€™, Journal of Computer and
System Sciences 50, 74â€“86.
Ben-David, S., Eiron, N. & Long, P. (2003), â€˜On the difficulty of approximately maximizing agreementsâ€™, Journal of Computer and System Sciences 66(3), 496â€“514.
Ben-David, S. & Litman, A. (1998), â€˜Combinatorial variability of vapnik-chervonenkis
classes with applications to sample compression schemesâ€™, Discrete Applied Mathematics 86(1), 3â€“25.
Ben-David, S., Pal, D., & Shalev-Shwartz, S. (2009), Agnostic online learning, in â€˜Conference on Learning Theory (COLT)â€™.
Ben-David, S. & Simon, H. (2001), â€˜Efficient learning of linear perceptronsâ€™, Advances
in Neural Information Processing Systems pp. 189â€“195.
Bengio, Y. (2009), â€˜Learning deep architectures for AIâ€™, Foundations and Trends in
Machine Learning 2(1), 1â€“127.
Bengio, Y. & LeCun, Y. (2007), â€˜Scaling learning algorithms towards aiâ€™, Large-Scale
Kernel Machines 34.
Bertsekas, D. (1999), Nonlinear Programming, Athena Scientific.
Beygelzimer, A., Langford, J. & Ravikumar, P. (2007), â€˜Multiclass classification with
filter treesâ€™, Preprint, June .
Birkhoff, G. (1946), â€˜Three observations on linear algebraâ€™, Revi. Univ. Nac. Tucuman,
ser A 5, 147â€“151.
Bishop, C. M. (2006), Pattern recognition and machine learning, Vol. 1, springer New
York.
Blum, L., Shub, M. & Smale, S. (1989), â€˜On a theory of computation and complexity
over the real numbers: Np-completeness, recursive functions and universal machinesâ€™,
Am. Math. Soc 21(1), 1â€“46.
Blumer, A., Ehrenfeucht, A., Haussler, D. & Warmuth, M. K. (1987), â€˜Occamâ€™s razorâ€™,
Information Processing Letters 24(6), 377â€“380.
Blumer, A., Ehrenfeucht, A., Haussler, D. & Warmuth, M. K. (1989), â€˜Learnability
and the Vapnik-Chervonenkis dimensionâ€™, Journal of the Association for Computing
Machinery 36(4), 929â€“965.
Borwein, J. & Lewis, A. (2006), Convex Analysis and Nonlinear Optimization, Springer.
Boser, B. E., Guyon, I. M. & Vapnik, V. N. (1992), A training algorithm for optimal
margin classifiers, in â€˜Conference on Learning Theory (COLT)â€™, pp. 144â€“152.
Bottou, L. & Bousquet, O. (2008), The tradeoffs of large scale learning, in â€˜NIPSâ€™,
pp. 161â€“168.
Boucheron, S., Bousquet, O. & Lugosi, G. (2005), â€˜Theory of classification: a survey of
recent advancesâ€™, ESAIM: Probability and Statistics 9, 323â€“375.
Bousquet, O. (2002), Concentration Inequalities and Empirical Processes Theory Applied to the Analysis of Learning Algorithms, PhD thesis, Ecole Polytechnique.
Bousquet, O. & Elisseeff, A. (2002), â€˜Stability and generalizationâ€™, Journal of Machine
Learning Research 2, 499â€“526.
Boyd, S. & Vandenberghe, L. (2004), Convex Optimization, Cambridge University
Press.

References

439

Breiman, L. (1996), Bias, variance, and arcing classifiers, Technical Report 460, Statistics Department, University of California at Berkeley.
Breiman, L. (2001), â€˜Random forestsâ€™, Machine learning 45(1), 5â€“32.
Breiman, L., Friedman, J. H., Olshen, R. A. & Stone, C. J. (1984), Classification and
Regression Trees, Wadsworth & Brooks.
CandeÌ€s, E. (2008), â€˜The restricted isometry property and its implications for compressed sensingâ€™, Comptes Rendus Mathematique 346(9), 589â€“592.
Candes, E. J. (2006), Compressive sampling, in â€˜Proc. of the Int. Congress of Math.,
Madrid, Spainâ€™.
Candes, E. & Tao, T. (2005), â€˜Decoding by linear programmingâ€™, IEEE Trans. on
Information Theory 51, 4203â€“4215.
Cesa-Bianchi, N. & Lugosi, G. (2006), Prediction, learning, and games, Cambridge
University Press.
Chang, H. S., Weiss, Y. & Freeman, W. T. (2009), â€˜Informative sensingâ€™, arXiv preprint
arXiv:0901.4275 .
Chapelle, O., Le, Q. & Smola, A. (2007), Large margin optimization of ranking measures, in â€˜NIPS Workshop: Machine Learning for Web Searchâ€™.
Collins, M. (2000), Discriminative reranking for natural language parsing, in â€˜Machine
Learningâ€™.
Collins, M. (2002), Discriminative training methods for hidden Markov models: Theory
and experiments with perceptron algorithms, in â€˜Conference on Empirical Methods
in Natural Language Processingâ€™.
Collobert, R. & Weston, J. (2008), A unified architecture for natural language processing: deep neural networks with multitask learning, in â€˜International Conference on
Machine Learning (ICML)â€™.
Cortes, C. & Vapnik, V. (1995), â€˜Support-vector networksâ€™, Machine Learning
20(3), 273â€“297.
Cover, T. (1965), â€˜Behavior of sequential predictors of binary sequencesâ€™, Trans. 4th
Prague Conf. Information Theory Statistical Decision Functions, Random Processes
pp. 263â€“272.
Cover, T. & Hart, P. (1967), â€˜Nearest neighbor pattern classificationâ€™, Information
Theory, IEEE Transactions on 13(1), 21â€“27.
Crammer, K. & Singer, Y. (2001), â€˜On the algorithmic implementation of multiclass
kernel-based vector machinesâ€™, Journal of Machine Learning Research 2, 265â€“292.
Cristianini, N. & Shawe-Taylor, J. (2000), An Introduction to Support Vector Machines,
Cambridge University Press.
Daniely, A., Sabato, S., Ben-David, S. & Shalev-Shwartz, S. (2011), Multiclass learnability and the erm principle, in â€˜Conference on Learning Theory (COLT)â€™.
Daniely, A., Sabato, S. & Shwartz, S. S. (2012), Multiclass learning approaches: A
theoretical comparison with implications, in â€˜NIPSâ€™.
Davis, G., Mallat, S. & Avellaneda, M. (1997), â€˜Greedy adaptive approximationâ€™, Journal of Constructive Approximation 13, 57â€“98.
Devroye, L. & GyoÌˆrfi, L. (1985), Nonparametric Density Estimation: The L B1 S View,
Wiley.
Devroye, L., GyoÌˆrfi, L. & Lugosi, G. (1996), A Probabilistic Theory of Pattern Recognition, Springer.

440

References

Dietterich, T. G. & Bakiri, G. (1995), â€˜Solving multiclass learning problems via errorcorrecting output codesâ€™, Journal of Artificial Intelligence Research 2, 263â€“286.
Donoho, D. L. (2006), â€˜Compressed sensingâ€™, Information Theory, IEEE Transactions
on 52(4), 1289â€“1306.
Dudley, R., Gine, E. & Zinn, J. (1991), â€˜Uniform and universal glivenko-cantelli classesâ€™,
Journal of Theoretical Probability 4(3), 485â€“510.
Dudley, R. M. (1987), â€˜Universal Donsker classes and metric entropyâ€™, Annals of Probability 15(4), 1306â€“1326.
Fisher, R. A. (1922), â€˜On the mathematical foundations of theoretical statisticsâ€™, Philosophical Transactions of the Royal Society of London. Series A, Containing Papers
of a Mathematical or Physical Character 222, 309â€“368.
Floyd, S. (1989), Space-bounded learning and the Vapnik-Chervonenkis dimension, in
â€˜Conference on Learning Theory (COLT)â€™, pp. 349â€“364.
Floyd, S. & Warmuth, M. (1995), â€˜Sample compression, learnability, and the VapnikChervonenkis dimensionâ€™, Machine Learning 21(3), 269â€“304.
Frank, M. & Wolfe, P. (1956), â€˜An algorithm for quadratic programmingâ€™, Naval Res.
Logist. Quart. 3, 95â€“110.
Freund, Y. & Schapire, R. (1995), A decision-theoretic generalization of on-line learning
and an application to boosting, in â€˜European Conference on Computational Learning
Theory (EuroCOLT)â€™, Springer-Verlag, pp. 23â€“37.
Freund, Y. & Schapire, R. E. (1999), â€˜Large margin classification using the perceptron
algorithmâ€™, Machine Learning 37(3), 277â€“296.
Garcia, J. & Koelling, R. (1996), â€˜Relation of cue to consequence in avoidance learningâ€™,
Foundations of animal behavior: classic papers with commentaries 4, 374.
Gentile, C. (2003), â€˜The robustness of the p-norm algorithmsâ€™, Machine Learning
53(3), 265â€“299.
Georghiades, A., Belhumeur, P. & Kriegman, D. (2001), â€˜From few to many: Illumination cone models for face recognition under variable lighting and poseâ€™, IEEE Trans.
Pattern Anal. Mach. Intelligence 23(6), 643â€“660.
Gordon, G. (1999), Regret bounds for prediction problems, in â€˜Conference on Learning
Theory (COLT)â€™.
Gottlieb, L.-A., Kontorovich, L. & Krauthgamer, R. (2010), Efficient classification for
metric data, in â€˜23rd Conference on Learning Theoryâ€™, pp. 433â€“440.
Guyon, I. & Elisseeff, A. (2003), â€˜An introduction to variable and feature selectionâ€™,
Journal of Machine Learning Research, Special Issue on Variable and Feature Selection 3, 1157â€“1182.
Hadamard, J. (1902), â€˜Sur les probleÌ€mes aux deÌriveÌes partielles et leur signification
physiqueâ€™, Princeton University Bulletin 13, 49â€“52.
Hastie, T., Tibshirani, R. & Friedman, J. (2001), The Elements of Statistical Learning,
Springer.
Haussler, D. (1992), â€˜Decision theoretic generalizations of the PAC model for neural
net and other learning applicationsâ€™, Information and Computation 100(1), 78â€“150.
Haussler, D. & Long, P. M. (1995), â€˜A generalization of sauerâ€™s lemmaâ€™, Journal of
Combinatorial Theory, Series A 71(2), 219â€“240.
Hazan, E., Agarwal, A. & Kale, S. (2007), â€˜Logarithmic regret algorithms for online
convex optimizationâ€™, Machine Learning 69(2â€“3), 169â€“192.

References

441

Hinton, G. E., Osindero, S. & Teh, Y.-W. (2006), â€˜A fast learning algorithm for deep
belief netsâ€™, Neural Computation 18(7), 1527â€“1554.
Hiriart-Urruty, J.-B. & LemareÌchal, C. (1996), Convex Analysis and Minimization Algorithms: Part 1: Fundamentals, Vol. 1, Springer.
Hsu, C.-W., Chang, C.-C. & Lin, C.-J. (2003), â€˜A practical guide to support vector
classificationâ€™.
Hyafil, L. & Rivest, R. L. (1976), â€˜Constructing optimal binary decision trees is NPcompleteâ€™, Information Processing Letters 5(1), 15â€“17.
Joachims, T. (2005), A support vector method for multivariate performance measures,
in â€˜Proceedings of the International Conference on Machine Learning (ICML)â€™.
Kakade, S., Sridharan, K. & Tewari, A. (2008), On the complexity of linear prediction:
Risk bounds, margin bounds, and regularization, in â€˜NIPSâ€™.
Karp, R. M. (1972), Reducibility among combinatorial problems, Springer.
Kearns, M. J., Schapire, R. E. & Sellie, L. M. (1994), â€˜Toward efficient agnostic learningâ€™, Machine Learning 17, 115â€“141.
Kearns, M. & Mansour, Y. (1996), On the boosting ability of top-down decision tree
learning algorithms, in â€˜ACM Symposium on the Theory of Computing (STOC)â€™.
Kearns, M. & Ron, D. (1999), â€˜Algorithmic stability and sanity-check bounds for leaveone-out cross-validationâ€™, Neural Computation 11(6), 1427â€“1453.
Kearns, M. & Valiant, L. G. (1988), Learning Boolean formulae or finite automata is
as hard as factoring, Technical Report TR-14-88, Harvard University Aiken Computation Laboratory.
Kearns, M. & Vazirani, U. (1994), An Introduction to Computational Learning Theory,
MIT Press.
Kleinberg, J. (2003), â€˜An impossibility theorem for clusteringâ€™, Advances in Neural
Information Processing Systems pp. 463â€“470.
Klivans, A. R. & Sherstov, A. A. (2006), Cryptographic hardness for learning intersections of halfspaces, in â€˜FOCSâ€™.
Koller, D. & Friedman, N. (2009), Probabilistic Graphical Models: Principles and Techniques, MIT Press.
Koltchinskii, V. & Panchenko, D. (2000), Rademacher processes and bounding the risk
of function learning, in â€˜High Dimensional Probability IIâ€™, Springer, pp. 443â€“457.
Kuhn, H. W. (1955), â€˜The hungarian method for the assignment problemâ€™, Naval research logistics quarterly 2(1-2), 83â€“97.
Kutin, S. & Niyogi, P. (2002), Almost-everywhere algorithmic stability and generalization error, in â€˜Proceedings of the 18th Conference in Uncertainty in Artificial
Intelligenceâ€™, pp. 275â€“282.
Lafferty, J., McCallum, A. & Pereira, F. (2001), Conditional random fields: Probabilistic
models for segmenting and labeling sequence data, in â€˜International Conference on
Machine Learningâ€™, pp. 282â€“289.
Langford, J. (2006), â€˜Tutorial on practical prediction theory for classificationâ€™, Journal
of machine learning research 6(1), 273.
Langford, J. & Shawe-Taylor, J. (2003), PAC-Bayes & margins, in â€˜NIPSâ€™, pp. 423â€“430.
Le Cun, L. (2004), Large scale online learning., in â€˜Advances in Neural Information
Processing Systems 16: Proceedings of the 2003 Conferenceâ€™, Vol. 16, MIT Press,
p. 217.

442

References

Le, Q. V., Ranzato, M.-A., Monga, R., Devin, M., Corrado, G., Chen, K., Dean, J. &
Ng, A. Y. (2012), Building high-level features using large scale unsupervised learning,
in â€˜International Conference on Machine Learning (ICML)â€™.
Lecun, Y. & Bengio, Y. (1995), Convolutional Networks for Images, Speech and Time
Series, The MIT Press, pp. 255â€“258.
Lee, H., Grosse, R., Ranganath, R. & Ng, A. (2009), Convolutional deep belief networks
for scalable unsupervised learning of hierarchical representations, in â€˜International
Conference on Machine Learning (ICML)â€™.
Littlestone, N. (1988), â€˜Learning quickly when irrelevant attributes abound: A new
linear-threshold algorithmâ€™, Machine Learning 2, 285â€“318.
Littlestone, N. & Warmuth, M. (1986), Relating data compression and learnability.
Unpublished manuscript.
Littlestone, N. & Warmuth, M. K. (1994), â€˜The weighted majority algorithmâ€™, Information and Computation 108, 212â€“261.
Livni, R., Shalev-Shwartz, S. & Shamir, O. (2013), â€˜A provably efficient algorithm for
training deep networksâ€™, arXiv preprint arXiv:1304.7045 .
Livni, R. & Simon, P. (2013), Honest compressions and their application to compression
schemes, in â€˜Conference on Learning Theory (COLT)â€™.
MacKay, D. J. (2003), Information theory, inference and learning algorithms,
Cambridge university press.
Mallat, S. & Zhang, Z. (1993), â€˜Matching pursuits with time-frequency dictionariesâ€™,
IEEE Transactions on Signal Processing 41, 3397â€“3415.
McAllester, D. A. (1998), Some PAC-Bayesian theorems, in â€˜Conference on Learning
Theory (COLT)â€™.
McAllester, D. A. (1999), PAC-Bayesian model averaging, in â€˜Conference on Learning
Theory (COLT)â€™, pp. 164â€“170.
McAllester, D. A. (2003), Simplified PAC-Bayesian margin bounds., in â€˜Conference on
Learning Theory (COLT)â€™, pp. 203â€“215.
Minsky, M. & Papert, S. (1969), Perceptrons: An Introduction to Computational Geometry, The MIT Press.
Mukherjee, S., Niyogi, P., Poggio, T. & Rifkin, R. (2006), â€˜Learning theory: stability is
sufficient for generalization and necessary and sufficient for consistency of empirical
risk minimizationâ€™, Advances in Computational Mathematics 25(1-3), 161â€“193.
Murata, N. (1998), â€˜A statistical study of on-line learningâ€™, Online Learning and Neural
Networks. Cambridge University Press, Cambridge, UK .
Murphy, K. P. (2012), Machine learning: a probabilistic perspective, The MIT Press.
Natarajan, B. (1995), â€˜Sparse approximate solutions to linear systemsâ€™, SIAM J. Computing 25(2), 227â€“234.
Natarajan, B. K. (1989), â€˜On learning sets and functionsâ€™, Mach. Learn. 4, 67â€“97.
Nemirovski, A., Juditsky, A., Lan, G. & Shapiro, A. (2009), â€˜Robust stochastic approximation approach to stochastic programmingâ€™, SIAM Journal on Optimization
19(4), 1574â€“1609.
Nemirovski, A. & Yudin, D. (1978), Problem complexity and method efficiency in optimization, Nauka Publishers, Moscow.
Nesterov, Y. (2005), Primal-dual subgradient methods for convex problems, Technical
report, Center for Operations Research and Econometrics (CORE), Catholic University of Louvain (UCL).

References

443

Nesterov, Y. & Nesterov, I. (2004), Introductory lectures on convex optimization: A
basic course, Vol. 87, Springer Netherlands.
Novikoff, A. B. J. (1962), On convergence proofs on perceptrons, in â€˜Proceedings of the
Symposium on the Mathematical Theory of Automataâ€™, Vol. XII, pp. 615â€“622.
Parberry, I. (1994), Circuit complexity and neural networks, The MIT press.
Pearson, K. (1901), â€˜On lines and planes of closest fit to systems of points in spaceâ€™,
The London, Edinburgh, and Dublin Philosophical Magazine and Journal of Science
2(11), 559â€“572.
Phillips, D. L. (1962), â€˜A technique for the numerical solution of certain integral equations of the first kindâ€™, Journal of the ACM 9(1), 84â€“97.
Pisier, G. (1980-1981), â€˜Remarques sur un reÌsultat non publieÌ de B. maureyâ€™.
Pitt, L. & Valiant, L. (1988), â€˜Computational limitations on learning from examplesâ€™,
Journal of the Association for Computing Machinery 35(4), 965â€“984.
Poon, H. & Domingos, P. (2011), Sum-product networks: A new deep architecture, in
â€˜Conference on Uncertainty in Artificial Intelligence (UAI)â€™.
Quinlan, J. R. (1986), â€˜Induction of decision treesâ€™, Machine Learning 1, 81â€“106.
Quinlan, J. R. (1993), C4.5: Programs for Machine Learning, Morgan Kaufmann.
Rabiner, L. & Juang, B. (1986), â€˜An introduction to hidden markov modelsâ€™, IEEE
ASSP Magazine 3(1), 4â€“16.
Rakhlin, A., Shamir, O. & Sridharan, K. (2012), Making gradient descent optimal for
strongly convex stochastic optimization, in â€˜International Conference on Machine
Learning (ICML)â€™.
Rakhlin, A., Sridharan, K. & Tewari, A. (2010), Online learning: Random averages,
combinatorial parameters, and learnability, in â€˜NIPSâ€™.
Rakhlin, S., Mukherjee, S. & Poggio, T. (2005), â€˜Stability results in learning theoryâ€™,
Analysis and Applications 3(4), 397â€“419.
Ranzato, M., Huang, F., Boureau, Y. & Lecun, Y. (2007), Unsupervised learning of
invariant feature hierarchies with applications to object recognition, in â€˜Computer
Vision and Pattern Recognition, 2007. CVPRâ€™07. IEEE Conference onâ€™, IEEE, pp. 1â€“
8.
Rissanen, J. (1978), â€˜Modeling by shortest data descriptionâ€™, Automatica 14, 465â€“471.
Rissanen, J. (1983), â€˜A universal prior for integers and estimation by minimum description lengthâ€™, The Annals of Statistics 11(2), 416â€“431.
Robbins, H. & Monro, S. (1951), â€˜A stochastic approximation methodâ€™, The Annals of
Mathematical Statistics pp. 400â€“407.
Rogers, W. & Wagner, T. (1978), â€˜A finite sample distribution-free performance bound
for local discrimination rulesâ€™, The Annals of Statistics 6(3), 506â€“514.
Rokach, L. (2007), Data mining with decision trees: theory and applications, Vol. 69,
World scientific.
Rosenblatt, F. (1958), â€˜The perceptron: A probabilistic model for information storage
and organization in the brainâ€™, Psychological Review 65, 386â€“407. (Reprinted in
Neurocomputing (MIT Press, 1988).).
Rumelhart, D. E., Hinton, G. E. & Williams, R. J. (1986), Learning internal representations by error propagation, in D. E. Rumelhart & J. L. McClelland, eds, â€˜Parallel Distributed Processing â€“ Explorations in the Microstructure of Cognitionâ€™, MIT
Press, chapter 8, pp. 318â€“362.

444

References

Sankaran, J. K. (1993), â€˜A note on resolving infeasibility in linear programs by constraint relaxationâ€™, Operations Research Letters 13(1), 19â€“20.
Sauer, N. (1972), â€˜On the density of families of setsâ€™, Journal of Combinatorial Theory
Series A 13, 145â€“147.
Schapire, R. (1990), â€˜The strength of weak learnabilityâ€™, Machine Learning 5(2), 197â€“
227.
Schapire, R. E. & Freund, Y. (2012), Boosting: Foundations and Algorithms, MIT press.
SchoÌˆlkopf, B., Herbrich, R. & Smola, A. (2001), A generalized representer theorem, in
â€˜Computational learning theoryâ€™, pp. 416â€“426.
SchoÌˆlkopf, B., Herbrich, R., Smola, A. & Williamson, R. (2000), A generalized representer theorem, in â€˜NeuroCOLTâ€™.
SchoÌˆlkopf, B. & Smola, A. J. (2002), Learning with Kernels: Support Vector Machines,
Regularization, Optimization and Beyond, MIT Press.
SchoÌˆlkopf, B., Smola, A. & MuÌˆller, K.-R. (1998), â€˜Nonlinear component analysis as a
kernel eigenvalue problemâ€™, Neural computation 10(5), 1299â€“1319.
Seeger, M. (2003), â€˜Pac-bayesian generalisation error bounds for gaussian process classificationâ€™, The Journal of Machine Learning Research 3, 233â€“269.
Shakhnarovich, G., Darrell, T. & Indyk, P. (2006), Nearest-neighbor methods in learning
and vision: theory and practice, MIT Press.
Shalev-Shwartz, S. (2007), Online Learning: Theory, Algorithms, and Applications,
PhD thesis, The Hebrew University.
Shalev-Shwartz, S. (2011), â€˜Online learning and online convex optimizationâ€™, FoundaR in Machine Learning 4(2), 107â€“194.
tions and Trends
Shalev-Shwartz, S., Shamir, O., Srebro, N. & Sridharan, K. (2010), â€˜Learnability,
stability and uniform convergenceâ€™, The Journal of Machine Learning Research
9999, 2635â€“2670.
Shalev-Shwartz, S., Shamir, O. & Sridharan, K. (2010), Learning kernel-based halfspaces with the zero-one loss, in â€˜Conference on Learning Theory (COLT)â€™.
Shalev-Shwartz, S., Shamir, O., Sridharan, K. & Srebro, N. (2009), Stochastic convex
optimization, in â€˜Conference on Learning Theory (COLT)â€™.
Shalev-Shwartz, S. & Singer, Y. (2008), On the equivalence of weak learnability and
linear separability: New relaxations and efficient boosting algorithms, in â€˜Proceedings
of the Nineteenth Annual Conference on Computational Learning Theoryâ€™.
Shalev-Shwartz, S., Singer, Y. & Srebro, N. (2007), Pegasos: Primal Estimated subGrAdient SOlver for SVM, in â€˜International Conference on Machine Learningâ€™,
pp. 807â€“814.
Shalev-Shwartz, S. & Srebro, N. (2008), SVM optimization: Inverse dependence on
training set size, in â€˜International Conference on Machine Learningâ€™, pp. 928â€“935.
Shalev-Shwartz, S., Zhang, T. & Srebro, N. (2010), â€˜Trading accuracy for sparsity
in optimization problems with sparsity constraintsâ€™, Siam Journal on Optimization
20, 2807â€“2832.
Shamir, O. & Zhang, T. (2013), Stochastic gradient descent for non-smooth optimization: Convergence results and optimal averaging schemes, in â€˜International Conference on Machine Learning (ICML)â€™.
Shapiro, A., Dentcheva, D. & RuszczynÌski, A. (2009), Lectures on stochastic programming: modeling and theory, Vol. 9, Society for Industrial and Applied Mathematics.

References

445

Shelah, S. (1972), â€˜A combinatorial problem; stability and order for models and theories
in infinitary languagesâ€™, Pac. J. Math 4, 247â€“261.
Sipser, M. (2006), Introduction to the Theory of Computation, Thomson Course Technology.
Slud, E. V. (1977), â€˜Distribution inequalities for the binomial lawâ€™, The Annals of
Probability 5(3), 404â€“412.
Steinwart, I. & Christmann, A. (2008), Support vector machines, Springerverlag New
York.
Stone, C. (1977), â€˜Consistent nonparametric regressionâ€™, The annals of statistics
5(4), 595â€“620.
Taskar, B., Guestrin, C. & Koller, D. (2003), Max-margin markov networks, in â€˜NIPSâ€™.
Tibshirani, R. (1996), â€˜Regression shrinkage and selection via the lassoâ€™, J. Royal.
Statist. Soc B. 58(1), 267â€“288.
Tikhonov, A. N. (1943), â€˜On the stability of inverse problemsâ€™, Dolk. Akad. Nauk SSSR
39(5), 195â€“198.
Tishby, N., Pereira, F. & Bialek, W. (1999), The information bottleneck method, in
â€˜The 37â€™th Allerton Conference on Communication, Control, and Computingâ€™.
Tsochantaridis, I., Hofmann, T., Joachims, T. & Altun, Y. (2004), Support vector
machine learning for interdependent and structured output spaces, in â€˜Proceedings
of the Twenty-First International Conference on Machine Learningâ€™.
Valiant, L. G. (1984), â€˜A theory of the learnableâ€™, Communications of the ACM
27(11), 1134â€“1142.
Vapnik, V. (1992), Principles of risk minimization for learning theory, in J. E. Moody,
S. J. Hanson & R. P. Lippmann, eds, â€˜Advances in Neural Information Processing
Systems 4â€™, Morgan Kaufmann, pp. 831â€“838.
Vapnik, V. (1995), The Nature of Statistical Learning Theory, Springer.
Vapnik, V. N. (1982), Estimation of Dependences Based on Empirical Data, SpringerVerlag.
Vapnik, V. N. (1998), Statistical Learning Theory, Wiley.
Vapnik, V. N. & Chervonenkis, A. Y. (1971), â€˜On the uniform convergence of relative
frequencies of events to their probabilitiesâ€™, Theory of Probability and its applications
XVI(2), 264â€“280.
Vapnik, V. N. & Chervonenkis, A. Y. (1974), Theory of pattern recognition, Nauka,
Moscow. (In Russian).
Von Luxburg, U. (2007), â€˜A tutorial on spectral clusteringâ€™, Statistics and computing
17(4), 395â€“416.
von Neumann, J. (1928), â€˜Zur theorie der gesellschaftsspiele (on the theory of parlor
games)â€™, Math. Ann. 100, 295â€”320.
Von Neumann, J. (1953), â€˜A certain zero-sum two-person game equivalent to the optimal assignment problemâ€™, Contributions to the Theory of Games 2, 5â€“12.
Vovk, V. G. (1990), Aggregating strategies, in â€˜Conference on Learning Theory
(COLT)â€™, pp. 371â€“383.
Warmuth, M., Glocer, K. & Vishwanathan, S. (2008), Entropy regularized lpboost, in
â€˜Algorithmic Learning Theory (ALT)â€™.
Warmuth, M., Liao, J. & Ratsch, G. (2006), Totally corrective boosting algorithms
that maximize the margin, in â€˜Proceedings of the 23rd international conference on
Machine learningâ€™.

446

References

Weston, J., Chapelle, O., Vapnik, V., Elisseeff, A. & SchoÌˆlkopf, B. (2002), Kernel dependency estimation, in â€˜Advances in neural information processing systemsâ€™, pp. 873â€“
880.
Weston, J. & Watkins, C. (1999), Support vector machines for multi-class pattern
recognition, in â€˜Proceedings of the Seventh European Symposium on Artificial Neural
Networksâ€™.
Wolpert, D. H. & Macready, W. G. (1997), â€˜No free lunch theorems for optimizationâ€™,
Evolutionary Computation, IEEE Transactions on 1(1), 67â€“82.
Zhang, T. (2004), Solving large scale linear prediction problems using stochastic gradient descent algorithms, in â€˜Proceedings of the Twenty-First International Conference
on Machine Learningâ€™.
Zhao, P. & Yu, B. (2006), â€˜On model selection consistency of Lassoâ€™, Journal of Machine
Learning Research 7, 2541â€“2567.
Zinkevich, M. (2003), Online convex programming and generalized infinitesimal gradient ascent, in â€˜International Conference on Machine Learningâ€™.

Index

3-term DNF, 107
F1 -score, 244
`1 norm, 183, 332, 363, 386
accuracy, 38, 43
activation function, 269
AdaBoost, 130, 134, 362
all-pairs, 228, 404
approximation error, 61, 64
auto-encoders, 368
backpropagation, 278
backward elimination, 363
bag-of-words, 209
base hypothesis, 137
Bayes optimal, 46, 52, 260
Bayes rule, 354
Bayesian reasoning, 353
Bennetâ€™s inequality, 426
Bernsteinâ€™s inequality, 426
bias, 37, 61, 64
bias-complexity tradeoff, 65
boolean conjunctions, 51, 79, 106
boosting, 130
boosting the confidence, 142
boundedness, 165
C4.5, 254
CART, 254
chaining, 389
Chebyshevâ€™s inequality, 423
Chernoff bounds, 423
class-sensitive feature mapping, 230
classifier, 34
clustering, 307
spectral, 315
compressed sensing, 330
compression bounds, 410
compression scheme, 411
computational complexity, 100
confidence, 38, 43
consistency, 92
Consistent, 289
contraction lemma, 381
convex, 156
function, 157

set, 156
strongly convex, 174, 195
convex-Lipschitz-bounded learning, 166
convex-smooth-bounded learning, 166
covering numbers, 388
curse of dimensionality, 263
decision stumps, 132, 133
decision trees, 250
dendrogram, 309, 310
dictionary learning, 368
differential set, 188
dimensionality reduction, 323
discretization trick, 57
discriminative, 342
distribution free, 342
domain, 33
domain of examples, 48
doubly stochastic matrix, 242
duality, 211
strong duality, 211
weak duality, 211
Dudley classes, 81
efficient computable, 100
EM, 348
empirical error, 35
empirical risk, 35, 48
Empirical Risk Minimization, see ERM
entropy, 345
relative entropy, 345
epigraph, 157
ERM, 35
error decomposition, 64, 168
estimation error, 61, 64
Expectation-Maximization, see EM
face recognition, see Viola-Jones
feasible, 100
feature, 33
feature learning, 368
feature normalization, 365
feature selection, 357, 358
feature space, 215
feature transformations, 367
filters, 359

c 2014 by Shai Shalev-Shwartz and Shai Ben-David
Understanding Machine Learning, 
Published 2014 by Cambridge University Press.
Personal use only. Not for distribution. Do not post.
Please link to http://www.cs.huji.ac.il/~shais/UnderstandingMachineLearning

448

Index

forward greedy selection, 360
frequentist, 353
gain, 253
GD, see gradient descent
generalization error, 35
generative models, 342
Gini index, 254
Glivenko-Cantelli, 58
gradient, 158
gradient descent, 185
Gram matrix, 219
growth function, 73
halfspace, 118
homogenous, 118, 205
non-separable, 119
separable, 118
Halving, 289
hidden layers, 270
Hilbert space, 217
Hoeffdingâ€™s inequality, 56, 425
hold out, 146
hypothesis, 34
hypothesis class, 36

homogenous, 118
linear programming, 119
linear regression, 122
linkage, 310
Lipschitzness, 160, 176, 191
sub-gradient, 190
Littlestone dimension, see Ldim
local minimum, 158
logistic regression, 126
loss, 35
loss function, 48
0-1 loss, 48, 167
absolute value loss, 124, 128, 166
convex loss, 163
generalized hinge-loss, 233
hinge loss, 167
Lipschitz loss, 166
log-loss, 345
logistic loss, 127
ramp loss, 209
smooth loss, 166
square loss, 48
surrogate loss, 167, 302

k-means, 311, 313
soft k-means, 352
k-median, 312
k-medoids, 312
Kendall tau, 239
kernel PCA, 326
kernels, 215
Gaussian kernel, 220
kernel trick, 217
polynomial kernel, 220
RBF kernel, 220

margin, 203
Markovâ€™s inequality, 422
Massart lemma, 380
max linkage, 310
maximum a-posteriori, 355
maximum likelihood, 343
McDiarmidâ€™s inequality, 378
MDL, 89, 90, 251
measure concentration, 55, 422
Minimum Description Length, see MDL
mistake bound, 288
mixture of Gaussians, 348
model selection, 144, 147
multiclass, 47, 227, 402
cost-sensitive, 232
linear predictors, 230, 405
multi-vector, 231, 406
Perceptron, 248
reductions, 227, 405
SGD, 235
SVM, 234
multivariate performance measures, 243

label, 33
Lasso, 365, 386
generalization bounds, 386
latent variables, 348
LDA, 347
Ldim, 290, 291
learning curves, 153
least squares, 124
likelihood ratio, 348
linear discriminant analysis, see LDA
linear predictor, 117

Naive Bayes, 347
Natarajan dimension, 402
NDCG, 239
Nearest Neighbor, 258
k-NN, 258
neural networks, 268
feedforward networks, 269
layered networks, 269
SGD, 277
no-free-lunch, 61
non-uniform learning, 84

i.i.d., 38
ID3, 252
improper, see representation independent
inductive bias, see bias
information bottleneck, 317
information gain, 254
instance, 33
instance space, 33
integral image, 143
Johnson-Lindenstrauss lemma, 329

Index

Normalized Discounted Cumulative Gain,
see NDCG
Occamâ€™s razor, 91
OMP, 360
one-vs-all, 227
one-vs-rest, see one-vs-all
one-vs.-all, 404
online convex optimization, 300
online gradient descent, 300
online learning, 287
optimization error, 168
oracle inequality, 179
orthogonal matching pursuit, see OMP
overfitting, 35, 65, 152
PAC, 43
agnostic PAC, 45, 46
agnostic PAC for general loss, 49
PAC-Bayes, 415
parametric density estimation, 342
PCA, 324
Pearsonâ€™s correlation coefficient, 359
Perceptron, 120
kernelized Perceptron, 225
multiclass, 248
online, 301
permutation matrix, 242
polynomial regression, 125
precision, 244
predictor, 34
prefix free language, 89
Principal Component Analysis, see PCA
prior knowledge, 63
Probably Approximately Correct, see PAC
projection, 193
projection lemma, 193
proper, 49
pruning, 254
Rademacher complexity, 375
random forests, 255
random projections, 329
ranking, 238
bipartite, 243
realizability, 37
recall, 244
regression, 47, 122, 172
regularization, 171
Tikhonov, 172, 174
regularized loss minimization, see RLM
representation independent, 49, 107
representative sample, 54, 375
representer theorem, 218
ridge regression, 172
kernel ridge regression, 225
RIP, 331
risk, 35, 45, 48
RLM, 171, 199

sample complexity, 44
Sauerâ€™s lemma, 73
self-boundedness, 162
sensitivity, 244
SGD, 190
shattering, 69, 403
single linkage, 310
Singular Value Decomposition, see SVD
Sludâ€™s inequality, 428
smoothness, 162, 177, 198
SOA, 292
sparsity-inducing norms, 363
specificity, 244
spectral clustering, 315
SRM, 85, 145
stability, 173
Stochastic Gradient Descent, see SGD
strong learning, 132
Structural Risk Minimization, see SRM
structured output prediction, 236
sub-gradient, 188
Support Vector Machines, see SVM
SVD, 431
SVM, 202, 383
duality, 211
generalization bounds, 208, 383
hard-SVM, 203, 204
homogenous, 205
kernel trick, 217
soft-SVM, 206
support vectors, 210
target set, 47
term-frequency, 231
TF-IDF, 231
training error, 35
training set, 33
true error, 35, 45
underfitting, 65, 152
uniform convergence, 54, 55
union bound, 39
unsupervised learning, 308
validation, 144, 146
cross validation, 149
train-validation-test split, 150
Vapnik-Chervonenkis dimension, see VC
dimension
VC dimension, 67, 70
version space, 289
Viola-Jones, 139
weak learning, 130, 131
Weighted-Majority, 295

449

